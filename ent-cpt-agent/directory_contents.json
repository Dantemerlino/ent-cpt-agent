{
    "name": "ent-cpt-agent",
    "folders": [
        {
            "name": ".",
            "files": [
                {
                    "name": "project-summary.md",
                    "content": "# ENT CPT Code Agent - Project Summary\n\n## Project Overview\n\nThe ENT CPT Code Agent is a comprehensive AI-powered assistant designed to help medical professionals accurately determine the appropriate CPT codes for ENT (Ear, Nose, Throat) procedures according to official coding guidelines. The system leverages LM Studio to provide an intelligent interface that can understand natural language descriptions of procedures and recommend the most appropriate codes based on medical coding rules.\n\n## Key Components\n\n### 1. CPT Code Database\n\nThe `CPTCodeDatabase` class manages the loading, storing, and querying of CPT codes from an Excel file. It provides functionality for:\n- Searching for codes by description or keywords\n- Retrieving code details and validating codes\n- Organizing codes by category\n- Identifying related codes\n\n### 2. Rules Engine\n\nThe `RulesEngine` class implements medical coding rules for CPT code selection, handling:\n- Bundled procedures (codes that should not be reported together)\n- Bilateral procedures (requiring modifier 50)\n- Multiple procedures (requiring modifier 51)\n- Medical necessity validation\n- Custom rule creation and application\n\n### 3. Conversation Manager\n\nThe `ConversationManager` and `Conversation` classes handle user interactions, managing:\n- Conversation history storage and retrieval\n- Message tracking and organization\n- Conversion between internal representation and LM Studio chat format\n- CPT code extraction from conversation text\n\n### 4. Agent Core\n\nThe `ENTCPTAgent` class serves as the central component, integrating:\n- The LM Studio model for natural language understanding\n- Tool functions for CPT code operations\n- Query processing and response generation\n- Interactive session management\n\n### 5. API Interface\n\nThe `APIInterface` class provides a REST API for the agent, offering endpoints for:\n- Submitting queries to the agent\n- Searching for and validating CPT codes\n- Analyzing procedure descriptions\n- Managing conversation sessions\n\n### 6. Web UI\n\nA web-based user interface built with Flask that provides:\n- A chat interface for interacting with the agent\n- Tools for code search, validation, and analysis\n- Conversation history management\n- Detected code tracking and display\n\n## Architecture Design\n\nThe project follows a modular architecture with clear separation of concerns:\n\n1. **Data Layer**: CPT code database and persistence\n2. **Business Logic Layer**: Rules engine and agent core\n3. **Presentation Layer**: API interface and web UI\n4. **Integration Layer**: LM Studio integration\n\nComponents communicate through well-defined interfaces, allowing for:\n- Independent testing and development\n- Easy replacement or enhancement of individual components\n- Flexible deployment options (CLI, API, web)\n\n## Integration with LM Studio\n\nThe system integrates with LM Studio through its Python SDK. Key integration points:\n\n### LLM Initialization\n\n```python\n# Configure and load the model\nself.model = lms.llm(self.model_name, config={\n    \"temperature\": self.model_temperature,\n    \"maxTokens\": self.model_max_tokens\n})\n```\n\n### Tool Function Registration\n\nThe agent provides tool functions that the language model can use:\n- `search_cpt_codes`: Search for CPT codes based on a procedure description\n- `validate_cpt_code`: Validate if a CPT code exists and is correct\n- `get_category_codes`: Get all CPT codes for a specific category\n- `explain_coding_rules`: Explain the rules for using a specific CPT code\n- `analyze_procedure`: Analyze a procedure description to determine appropriate codes\n\n### Query Processing\n\n```python\n# Define the tool functions\ntools = [\n    self.search_cpt_codes,\n    self.validate_cpt_code,\n    self.get_category_codes,\n    self.explain_coding_rules,\n    self.analyze_procedure\n]\n\n# Let the model use tools to process the query\nresult = self.model.act(\n    chat,\n    tools,\n    on_message=lambda msg: conversation.add_message(\"assistant\", msg.content) if conversation else None\n)\n```\n\n## Getting Started\n\n1. Install the requirements: `pip install -r requirements.txt`\n2. Initialize the configuration: `python main.py init`\n3. Place the CPT code database file in the data directory\n4. Run the application in interactive mode: `python main.py interactive`\n\n## Development Workflow\n\nTo further develop and extend the project:\n\n1. **Setup the Development Environment**:\n   ```bash\n   # Clone the repository\n   git clone <repository-url> ent-cpt-agent\n   cd ent-cpt-agent\n   \n   # Create a virtual environment\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   \n   # Install development dependencies\n   pip install -r requirements-dev.txt\n   ```\n\n2. **Run Tests**:\n   ```bash\n   # Run all tests\n   python -m unittest discover\n   \n   # Run specific test file\n   python -m unittest tests.test_cpt_database\n   ```\n\n3. **Add New Features**:\n   - Create or modify code in the `src` directory\n   - Add tests in the `tests` directory\n   - Update documentation as needed\n\n4. **Build and Package**:\n   ```bash\n   # Build the package\n   python setup.py sdist bdist_wheel\n   \n   # Install locally for testing\n   pip install -e .\n   ```\n\n## Extending the Project\n\nThe ENT CPT Code Agent is designed to be extensible. Here are some ways to enhance it:\n\n1. **Add New Rules**: Create new `CodeRule` instances in the `RulesEngine` for additional coding guidelines.\n\n2. **Enhance the Database**: Add more fields to the CPT code database to support additional information, such as:\n   - Reimbursement rates\n   - Payer-specific guidelines\n   - Historical coding data\n\n3. **Improve the UI**: Enhance the web interface with additional features:\n   - Visualization of coding relationships\n   - Interactive procedure diagrams\n   - Documentation templates\n\n4. **Extend to Other Specialties**: Adapt the framework to support other medical specialties beyond ENT.\n\n## Deployment Options\n\nThe ENT CPT Code Agent supports multiple deployment scenarios:\n\n1. **Standalone Application**: Run the interactive CLI or web UI locally for individual users.\n\n2. **API Server**: Deploy as a service that other applications can integrate with via REST API.\n\n3. **Embedded Component**: Integrate the core logic into existing electronic medical record (EMR) systems.\n\n## Conclusion\n\nThe ENT CPT Code Agent provides a comprehensive solution for ENT procedure coding assistance. Its modular design, integration with LM Studio, and extensible architecture make it a powerful tool for medical professionals and coding specialists.\n"
                },
                {
                    "name": "requirements.txt",
                    "content": "lmstudio\npandas\nopenpyxl\nfastapi\nuvicorn\nflask\nrequests\npython-dotenv\npytest\nargparse\nlogging\nopenai\n\n\n"
                },
                {
                    "name": "run_web_ui.py",
                    "content": "#!/usr/bin/env python3\n#file: run_web_ui.py\n\"\"\"\nScript to run the web UI for ENT CPT Code Agent.\n\"\"\"\n\nfrom src.web.web_ui import app\n\nif __name__ == \"__main__\":\n    # Get port from environment variable or use default\n    import os\n    port = int(os.environ.get(\"WEB_PORT\", \"5000\"))\n    host = os.environ.get(\"WEB_HOST\", \"0.0.0.0\")\n    debug = os.environ.get(\"DEBUG\", \"False\").lower() == \"true\"\n    \n    print(f\"Starting web UI server on {host}:{port} (debug={debug})\")\n    app.run(host=host, port=port, debug=debug)"
                },
                {
                    "name": "config.json",
                    "content": "{\n    \"model\": {\n      \"name\": \"qwen2.5-7b-instruct\",\n      \"temperature\": 0.2,\n      \"max_tokens\": 1024,\n      \"context_length\": 8192\n    },\n    \"cpt_database\": {\n      \"file_path\": \"CPT codes for ENT.xlsx\",\n      \"sheet_name\": \"Sheet1\"\n    },\n    \"agent\": {\n      \"log_level\": \"INFO\",\n      \"save_conversations\": true,\n      \"conversation_dir\": \"conversations\"\n    },\n    \"server\": {\n      \"host\": \"localhost\",\n      \"port\": 8000,\n      \"enable_api\": false\n    }\n  }"
                },
                {
                    "name": "system-architecture.svg",
                    "content": "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 800 500\">\n  <!-- Background -->\n  <rect width=\"800\" height=\"500\" fill=\"#f8f9fa\" rx=\"10\" ry=\"10\" />\n  \n  <!-- Title -->\n  <text x=\"400\" y=\"40\" font-family=\"Arial\" font-size=\"24\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#333\">ENT CPT Code Agent Architecture</text>\n  \n  <!-- User Interface -->\n  <rect x=\"50\" y=\"80\" width=\"200\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#e3f2fd\" stroke=\"#2196f3\" stroke-width=\"2\" />\n  <text x=\"150\" y=\"110\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#0d47a1\">User Interface</text>\n  <text x=\"150\" y=\"135\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Command Line / Web UI</text>\n  <text x=\"150\" y=\"155\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Query Input / Results Display</text>\n  \n  <!-- LM Studio Engine -->\n  <rect x=\"300\" y=\"80\" width=\"200\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#e8f5e9\" stroke=\"#4caf50\" stroke-width=\"2\" />\n  <text x=\"400\" y=\"110\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#1b5e20\">LM Studio Engine</text>\n  <text x=\"400\" y=\"135\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Language Model (Qwen/Llama)</text>\n  <text x=\"400\" y=\"155\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Reasoning & Tool Use</text>\n  \n  <!-- CPT Code Database -->\n  <rect x=\"550\" y=\"80\" width=\"200\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#fff3e0\" stroke=\"#ff9800\" stroke-width=\"2\" />\n  <text x=\"650\" y=\"110\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#e65100\">CPT Code Database</text>\n  <text x=\"650\" y=\"135\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- ENT CPT Codes</text>\n  <text x=\"650\" y=\"155\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Code Descriptions & Rules</text>\n  \n  <!-- Agent Core -->\n  <rect x=\"300\" y=\"230\" width=\"200\" height=\"120\" rx=\"5\" ry=\"5\" fill=\"#e8eaf6\" stroke=\"#3f51b5\" stroke-width=\"2\" />\n  <text x=\"400\" y=\"260\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#1a237e\">Agent Core</text>\n  <text x=\"400\" y=\"285\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Query Processing</text>\n  <text x=\"400\" y=\"305\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Tool Selection & Execution</text>\n  <text x=\"400\" y=\"325\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">- Response Generation</text>\n  \n  <!-- Tool Functions -->\n  <rect x=\"100\" y=\"350\" width=\"600\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#f3e5f5\" stroke=\"#9c27b0\" stroke-width=\"2\" />\n  <text x=\"400\" y=\"380\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#4a148c\">Tool Functions</text>\n  \n  <!-- Tools -->\n  <rect x=\"120\" y=\"400\" width=\"120\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" />\n  <text x=\"180\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">Code Search</text>\n  \n  <rect x=\"260\" y=\"400\" width=\"120\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" />\n  <text x=\"320\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">Code Validation</text>\n  \n  <rect x=\"400\" y=\"400\" width=\"120\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" />\n  <text x=\"460\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">Rule Application</text>\n  \n  <rect x=\"540\" y=\"400\" width=\"140\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" />\n  <text x=\"610\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\">Explanation Generator</text>\n  \n  <!-- Connecting Lines -->\n  <!-- UI to Agent -->\n  <line x1=\"150\" y1=\"180\" x2=\"300\" y2=\"230\" stroke=\"#333\" stroke-width=\"2\" stroke-dasharray=\"5,5\" />\n  \n  <!-- LM Studio to Agent -->\n  <line x1=\"400\" y1=\"180\" x2=\"400\" y2=\"230\" stroke=\"#333\" stroke-width=\"2\" />\n  \n  <!-- CPT Database to Agent -->\n  <line x1=\"650\" y1=\"180\" x2=\"500\" y2=\"230\" stroke=\"#333\" stroke-width=\"2\" stroke-dasharray=\"5,5\" />\n  \n  <!-- Agent to Tools -->\n  <line x1=\"400\" y1=\"350\" x2=\"400\" y2=\"380\" stroke=\"#333\" stroke-width=\"2\" />\n</svg>\n"
                },
                {
                    "name": "readme.md",
                    "content": "# ENT CPT Code Agent\n\nAn AI-powered assistant for ENT (Ear, Nose, Throat) CPT code selection and validation.\n\n## Overview\n\nThe ENT CPT Code Agent is a comprehensive tool designed to help medical professionals accurately determine the appropriate CPT codes for ENT procedures according to official coding rules. It uses LM Studio to power an intelligent assistant that can understand natural language descriptions of procedures and recommend the most appropriate codes.\n\n## Features\n\n- **Natural Language Understanding**: Describe procedures in plain English and get accurate code recommendations\n- **CPT Code Search**: Search for codes based on keywords or descriptions\n- **Code Validation**: Verify if a CPT code is valid and appropriate for a given procedure\n- **Procedure Analysis**: Analyze detailed procedure descriptions to determine the correct codes\n- **Educational Guidance**: Learn about coding rules, modifiers, and best practices\n- **Multiple Interfaces**: Command-line, Web UI, and API options for different usage scenarios\n- **Conversation History**: Save and review past conversations for reference\n\n## Installation\n\n### Prerequisites\n\n- Python 3.8+\n- LM Studio desktop application\n- CPT codes database (Excel format)\n\n### Quick Install\n\n```bash\n# Clone the repository\ngit clone https://github.com/Dantemerlino/ent-cpt-agent.git\ncd ent-cpt-agent\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Initialize default configuration\npython -m src.main init\n```\n\nFor detailed installation instructions, see the [Installation Guide](docs/installation_guide.md).\n\n## Usage\n\n### Interactive Mode\n\n```bash\npython -m src.main interactive\n```\n\nThis starts an interactive session where you can ask questions about ENT procedures and CPT codes.\n\n### API Server Mode\n\n```bash\npython -m src.main server --host localhost --port 8000\n```\n\nThis starts the API server, allowing you to integrate the agent with other applications.\n\n### Web UI\n\n```bash\npython run_web_ui.py\n```\n\nThis starts the web interface server. Navigate to http://localhost:5000 to access the web UI.\n\n### Single Query Mode\n\n```bash\npython -m src.main query \"What is the CPT code for bilateral myringotomy with tube insertion?\"\n```\n\nThis processes a single query and exits, useful for scripts and automation.\n\n## Documentation\n\n- [Installation Guide](docs/installation_guide.md): Detailed installation instructions\n- [Usage Examples](docs/usage_examples.md): Examples of how to use the agent\n- [API Documentation](docs/api_docs.md): Documentation for the REST API\n- [Project summary](docs/PROJECT_SUMMARY.md): Project summary\n\n## License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n\n## Acknowledgments\n\n- This project uses LM Studio for AI language model processing\n- Special thanks to the medical coding community for guidance\n"
                },
                {
                    "name": "setup.py",
                    "content": "from setuptools import setup, find_packages\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nwith open(\"requirements.txt\", \"r\", encoding=\"utf-8\") as fh:\n    requirements = fh.read().splitlines()\n\nsetup(\n    name=\"ent-cpt-agent\",\n    version=\"1.0.0\",\n    author=\"Your Name\",\n    author_email=\"your.email@example.com\",\n    description=\"An AI-powered assistant for ENT CPT code selection and validation\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/your-organization/ent-cpt-agent\",\n    packages=find_packages(),\n    include_package_data=True,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n    ],\n    python_requires=\">=3.8\",\n    install_requires=requirements,\n    entry_points={\n        \"console_scripts\": [\n            \"ent-cpt-agent=main:main\",\n        ],\n    },\n)\n"
                },
                {
                    "name": "directory_contents.txt",
                    "content": ""
                },
                {
                    "name": "directory_contents.xml",
                    "content": "<?xml version='1.0' encoding='utf-8'?>\n<directory name=\"ent-cpt-agent\">\n  <folder name=\".\">\n    <file name=\"project-summary.md\"># ENT CPT Code Agent - Project Summary\n\n## Project Overview\n\nThe ENT CPT Code Agent is a comprehensive AI-powered assistant designed to help medical professionals accurately determine the appropriate CPT codes for ENT (Ear, Nose, Throat) procedures according to official coding guidelines. The system leverages LM Studio to provide an intelligent interface that can understand natural language descriptions of procedures and recommend the most appropriate codes based on medical coding rules.\n\n## Key Components\n\n### 1. CPT Code Database\n\nThe `CPTCodeDatabase` class manages the loading, storing, and querying of CPT codes from an Excel file. It provides functionality for:\n- Searching for codes by description or keywords\n- Retrieving code details and validating codes\n- Organizing codes by category\n- Identifying related codes\n\n### 2. Rules Engine\n\nThe `RulesEngine` class implements medical coding rules for CPT code selection, handling:\n- Bundled procedures (codes that should not be reported together)\n- Bilateral procedures (requiring modifier 50)\n- Multiple procedures (requiring modifier 51)\n- Medical necessity validation\n- Custom rule creation and application\n\n### 3. Conversation Manager\n\nThe `ConversationManager` and `Conversation` classes handle user interactions, managing:\n- Conversation history storage and retrieval\n- Message tracking and organization\n- Conversion between internal representation and LM Studio chat format\n- CPT code extraction from conversation text\n\n### 4. Agent Core\n\nThe `ENTCPTAgent` class serves as the central component, integrating:\n- The LM Studio model for natural language understanding\n- Tool functions for CPT code operations\n- Query processing and response generation\n- Interactive session management\n\n### 5. API Interface\n\nThe `APIInterface` class provides a REST API for the agent, offering endpoints for:\n- Submitting queries to the agent\n- Searching for and validating CPT codes\n- Analyzing procedure descriptions\n- Managing conversation sessions\n\n### 6. Web UI\n\nA web-based user interface built with Flask that provides:\n- A chat interface for interacting with the agent\n- Tools for code search, validation, and analysis\n- Conversation history management\n- Detected code tracking and display\n\n## Architecture Design\n\nThe project follows a modular architecture with clear separation of concerns:\n\n1. **Data Layer**: CPT code database and persistence\n2. **Business Logic Layer**: Rules engine and agent core\n3. **Presentation Layer**: API interface and web UI\n4. **Integration Layer**: LM Studio integration\n\nComponents communicate through well-defined interfaces, allowing for:\n- Independent testing and development\n- Easy replacement or enhancement of individual components\n- Flexible deployment options (CLI, API, web)\n\n## Integration with LM Studio\n\nThe system integrates with LM Studio through its Python SDK. Key integration points:\n\n### LLM Initialization\n\n```python\n# Configure and load the model\nself.model = lms.llm(self.model_name, config={\n    \"temperature\": self.model_temperature,\n    \"maxTokens\": self.model_max_tokens\n})\n```\n\n### Tool Function Registration\n\nThe agent provides tool functions that the language model can use:\n- `search_cpt_codes`: Search for CPT codes based on a procedure description\n- `validate_cpt_code`: Validate if a CPT code exists and is correct\n- `get_category_codes`: Get all CPT codes for a specific category\n- `explain_coding_rules`: Explain the rules for using a specific CPT code\n- `analyze_procedure`: Analyze a procedure description to determine appropriate codes\n\n### Query Processing\n\n```python\n# Define the tool functions\ntools = [\n    self.search_cpt_codes,\n    self.validate_cpt_code,\n    self.get_category_codes,\n    self.explain_coding_rules,\n    self.analyze_procedure\n]\n\n# Let the model use tools to process the query\nresult = self.model.act(\n    chat,\n    tools,\n    on_message=lambda msg: conversation.add_message(\"assistant\", msg.content) if conversation else None\n)\n```\n\n## Getting Started\n\n1. Install the requirements: `pip install -r requirements.txt`\n2. Initialize the configuration: `python main.py init`\n3. Place the CPT code database file in the data directory\n4. Run the application in interactive mode: `python main.py interactive`\n\n## Development Workflow\n\nTo further develop and extend the project:\n\n1. **Setup the Development Environment**:\n   ```bash\n   # Clone the repository\n   git clone &lt;repository-url&gt; ent-cpt-agent\n   cd ent-cpt-agent\n   \n   # Create a virtual environment\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   \n   # Install development dependencies\n   pip install -r requirements-dev.txt\n   ```\n\n2. **Run Tests**:\n   ```bash\n   # Run all tests\n   python -m unittest discover\n   \n   # Run specific test file\n   python -m unittest tests.test_cpt_database\n   ```\n\n3. **Add New Features**:\n   - Create or modify code in the `src` directory\n   - Add tests in the `tests` directory\n   - Update documentation as needed\n\n4. **Build and Package**:\n   ```bash\n   # Build the package\n   python setup.py sdist bdist_wheel\n   \n   # Install locally for testing\n   pip install -e .\n   ```\n\n## Extending the Project\n\nThe ENT CPT Code Agent is designed to be extensible. Here are some ways to enhance it:\n\n1. **Add New Rules**: Create new `CodeRule` instances in the `RulesEngine` for additional coding guidelines.\n\n2. **Enhance the Database**: Add more fields to the CPT code database to support additional information, such as:\n   - Reimbursement rates\n   - Payer-specific guidelines\n   - Historical coding data\n\n3. **Improve the UI**: Enhance the web interface with additional features:\n   - Visualization of coding relationships\n   - Interactive procedure diagrams\n   - Documentation templates\n\n4. **Extend to Other Specialties**: Adapt the framework to support other medical specialties beyond ENT.\n\n## Deployment Options\n\nThe ENT CPT Code Agent supports multiple deployment scenarios:\n\n1. **Standalone Application**: Run the interactive CLI or web UI locally for individual users.\n\n2. **API Server**: Deploy as a service that other applications can integrate with via REST API.\n\n3. **Embedded Component**: Integrate the core logic into existing electronic medical record (EMR) systems.\n\n## Conclusion\n\nThe ENT CPT Code Agent provides a comprehensive solution for ENT procedure coding assistance. Its modular design, integration with LM Studio, and extensible architecture make it a powerful tool for medical professionals and coding specialists.\n</file>\n    <file name=\"requirements.txt\">lmstudio\npandas\nopenpyxl\nfastapi\nuvicorn\nflask\nrequests\npython-dotenv\npytest\nargparse\nlogging\nopenai\n\n\n</file>\n    <file name=\"run_web_ui.py\">#!/usr/bin/env python3\n#file: run_web_ui.py\n\"\"\"\nScript to run the web UI for ENT CPT Code Agent.\n\"\"\"\n\nfrom src.web.web_ui import app\n\nif __name__ == \"__main__\":\n    # Get port from environment variable or use default\n    import os\n    port = int(os.environ.get(\"WEB_PORT\", \"5000\"))\n    host = os.environ.get(\"WEB_HOST\", \"0.0.0.0\")\n    debug = os.environ.get(\"DEBUG\", \"False\").lower() == \"true\"\n    \n    print(f\"Starting web UI server on {host}:{port} (debug={debug})\")\n    app.run(host=host, port=port, debug=debug)</file>\n    <file name=\"config.json\">{\n    \"model\": {\n      \"name\": \"qwen2.5-7b-instruct\",\n      \"temperature\": 0.2,\n      \"max_tokens\": 1024,\n      \"context_length\": 8192\n    },\n    \"cpt_database\": {\n      \"file_path\": \"CPT codes for ENT.xlsx\",\n      \"sheet_name\": \"Sheet1\"\n    },\n    \"agent\": {\n      \"log_level\": \"INFO\",\n      \"save_conversations\": true,\n      \"conversation_dir\": \"conversations\"\n    },\n    \"server\": {\n      \"host\": \"localhost\",\n      \"port\": 8000,\n      \"enable_api\": false\n    }\n  }</file>\n    <file name=\"system-architecture.svg\">&lt;svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 800 500\"&gt;\n  &lt;!-- Background --&gt;\n  &lt;rect width=\"800\" height=\"500\" fill=\"#f8f9fa\" rx=\"10\" ry=\"10\" /&gt;\n  \n  &lt;!-- Title --&gt;\n  &lt;text x=\"400\" y=\"40\" font-family=\"Arial\" font-size=\"24\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#333\"&gt;ENT CPT Code Agent Architecture&lt;/text&gt;\n  \n  &lt;!-- User Interface --&gt;\n  &lt;rect x=\"50\" y=\"80\" width=\"200\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#e3f2fd\" stroke=\"#2196f3\" stroke-width=\"2\" /&gt;\n  &lt;text x=\"150\" y=\"110\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#0d47a1\"&gt;User Interface&lt;/text&gt;\n  &lt;text x=\"150\" y=\"135\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Command Line / Web UI&lt;/text&gt;\n  &lt;text x=\"150\" y=\"155\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Query Input / Results Display&lt;/text&gt;\n  \n  &lt;!-- LM Studio Engine --&gt;\n  &lt;rect x=\"300\" y=\"80\" width=\"200\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#e8f5e9\" stroke=\"#4caf50\" stroke-width=\"2\" /&gt;\n  &lt;text x=\"400\" y=\"110\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#1b5e20\"&gt;LM Studio Engine&lt;/text&gt;\n  &lt;text x=\"400\" y=\"135\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Language Model (Qwen/Llama)&lt;/text&gt;\n  &lt;text x=\"400\" y=\"155\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Reasoning &amp; Tool Use&lt;/text&gt;\n  \n  &lt;!-- CPT Code Database --&gt;\n  &lt;rect x=\"550\" y=\"80\" width=\"200\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#fff3e0\" stroke=\"#ff9800\" stroke-width=\"2\" /&gt;\n  &lt;text x=\"650\" y=\"110\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#e65100\"&gt;CPT Code Database&lt;/text&gt;\n  &lt;text x=\"650\" y=\"135\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- ENT CPT Codes&lt;/text&gt;\n  &lt;text x=\"650\" y=\"155\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Code Descriptions &amp; Rules&lt;/text&gt;\n  \n  &lt;!-- Agent Core --&gt;\n  &lt;rect x=\"300\" y=\"230\" width=\"200\" height=\"120\" rx=\"5\" ry=\"5\" fill=\"#e8eaf6\" stroke=\"#3f51b5\" stroke-width=\"2\" /&gt;\n  &lt;text x=\"400\" y=\"260\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#1a237e\"&gt;Agent Core&lt;/text&gt;\n  &lt;text x=\"400\" y=\"285\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Query Processing&lt;/text&gt;\n  &lt;text x=\"400\" y=\"305\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Tool Selection &amp; Execution&lt;/text&gt;\n  &lt;text x=\"400\" y=\"325\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;- Response Generation&lt;/text&gt;\n  \n  &lt;!-- Tool Functions --&gt;\n  &lt;rect x=\"100\" y=\"350\" width=\"600\" height=\"100\" rx=\"5\" ry=\"5\" fill=\"#f3e5f5\" stroke=\"#9c27b0\" stroke-width=\"2\" /&gt;\n  &lt;text x=\"400\" y=\"380\" font-family=\"Arial\" font-size=\"16\" font-weight=\"bold\" text-anchor=\"middle\" fill=\"#4a148c\"&gt;Tool Functions&lt;/text&gt;\n  \n  &lt;!-- Tools --&gt;\n  &lt;rect x=\"120\" y=\"400\" width=\"120\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" /&gt;\n  &lt;text x=\"180\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;Code Search&lt;/text&gt;\n  \n  &lt;rect x=\"260\" y=\"400\" width=\"120\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" /&gt;\n  &lt;text x=\"320\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;Code Validation&lt;/text&gt;\n  \n  &lt;rect x=\"400\" y=\"400\" width=\"120\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" /&gt;\n  &lt;text x=\"460\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;Rule Application&lt;/text&gt;\n  \n  &lt;rect x=\"540\" y=\"400\" width=\"140\" height=\"30\" rx=\"5\" ry=\"5\" fill=\"#e1bee7\" stroke=\"#9c27b0\" stroke-width=\"1\" /&gt;\n  &lt;text x=\"610\" y=\"420\" font-family=\"Arial\" font-size=\"12\" text-anchor=\"middle\" fill=\"#333\"&gt;Explanation Generator&lt;/text&gt;\n  \n  &lt;!-- Connecting Lines --&gt;\n  &lt;!-- UI to Agent --&gt;\n  &lt;line x1=\"150\" y1=\"180\" x2=\"300\" y2=\"230\" stroke=\"#333\" stroke-width=\"2\" stroke-dasharray=\"5,5\" /&gt;\n  \n  &lt;!-- LM Studio to Agent --&gt;\n  &lt;line x1=\"400\" y1=\"180\" x2=\"400\" y2=\"230\" stroke=\"#333\" stroke-width=\"2\" /&gt;\n  \n  &lt;!-- CPT Database to Agent --&gt;\n  &lt;line x1=\"650\" y1=\"180\" x2=\"500\" y2=\"230\" stroke=\"#333\" stroke-width=\"2\" stroke-dasharray=\"5,5\" /&gt;\n  \n  &lt;!-- Agent to Tools --&gt;\n  &lt;line x1=\"400\" y1=\"350\" x2=\"400\" y2=\"380\" stroke=\"#333\" stroke-width=\"2\" /&gt;\n&lt;/svg&gt;\n</file>\n    <file name=\"readme.md\"># ENT CPT Code Agent\n\nAn AI-powered assistant for ENT (Ear, Nose, Throat) CPT code selection and validation.\n\n## Overview\n\nThe ENT CPT Code Agent is a comprehensive tool designed to help medical professionals accurately determine the appropriate CPT codes for ENT procedures according to official coding rules. It uses LM Studio to power an intelligent assistant that can understand natural language descriptions of procedures and recommend the most appropriate codes.\n\n## Features\n\n- **Natural Language Understanding**: Describe procedures in plain English and get accurate code recommendations\n- **CPT Code Search**: Search for codes based on keywords or descriptions\n- **Code Validation**: Verify if a CPT code is valid and appropriate for a given procedure\n- **Procedure Analysis**: Analyze detailed procedure descriptions to determine the correct codes\n- **Educational Guidance**: Learn about coding rules, modifiers, and best practices\n- **Multiple Interfaces**: Command-line, Web UI, and API options for different usage scenarios\n- **Conversation History**: Save and review past conversations for reference\n\n## Installation\n\n### Prerequisites\n\n- Python 3.8+\n- LM Studio desktop application\n- CPT codes database (Excel format)\n\n### Quick Install\n\n```bash\n# Clone the repository\ngit clone https://github.com/Dantemerlino/ent-cpt-agent.git\ncd ent-cpt-agent\n\n# Create a virtual environment\npython -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Initialize default configuration\npython -m src.main init\n```\n\nFor detailed installation instructions, see the [Installation Guide](docs/installation_guide.md).\n\n## Usage\n\n### Interactive Mode\n\n```bash\npython -m src.main interactive\n```\n\nThis starts an interactive session where you can ask questions about ENT procedures and CPT codes.\n\n### API Server Mode\n\n```bash\npython -m src.main server --host localhost --port 8000\n```\n\nThis starts the API server, allowing you to integrate the agent with other applications.\n\n### Web UI\n\n```bash\npython run_web_ui.py\n```\n\nThis starts the web interface server. Navigate to http://localhost:5000 to access the web UI.\n\n### Single Query Mode\n\n```bash\npython -m src.main query \"What is the CPT code for bilateral myringotomy with tube insertion?\"\n```\n\nThis processes a single query and exits, useful for scripts and automation.\n\n## Documentation\n\n- [Installation Guide](docs/installation_guide.md): Detailed installation instructions\n- [Usage Examples](docs/usage_examples.md): Examples of how to use the agent\n- [API Documentation](docs/api_docs.md): Documentation for the REST API\n- [Project summary](docs/PROJECT_SUMMARY.md): Project summary\n\n## License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n\n## Acknowledgments\n\n- This project uses LM Studio for AI language model processing\n- Special thanks to the medical coding community for guidance\n</file>\n    <file name=\"setup.py\">from setuptools import setup, find_packages\n\nwith open(\"README.md\", \"r\", encoding=\"utf-8\") as fh:\n    long_description = fh.read()\n\nwith open(\"requirements.txt\", \"r\", encoding=\"utf-8\") as fh:\n    requirements = fh.read().splitlines()\n\nsetup(\n    name=\"ent-cpt-agent\",\n    version=\"1.0.0\",\n    author=\"Your Name\",\n    author_email=\"your.email@example.com\",\n    description=\"An AI-powered assistant for ENT CPT code selection and validation\",\n    long_description=long_description,\n    long_description_content_type=\"text/markdown\",\n    url=\"https://github.com/your-organization/ent-cpt-agent\",\n    packages=find_packages(),\n    include_package_data=True,\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"License :: OSI Approved :: MIT License\",\n        \"Operating System :: OS Independent\",\n        \"Development Status :: 4 - Beta\",\n        \"Intended Audience :: Healthcare Industry\",\n        \"Topic :: Scientific/Engineering :: Medical Science Apps.\",\n    ],\n    python_requires=\"&gt;=3.8\",\n    install_requires=requirements,\n    entry_points={\n        \"console_scripts\": [\n            \"ent-cpt-agent=main:main\",\n        ],\n    },\n)\n</file>\n    <file name=\"directory_contents.txt\" />\n  </folder>\n  <folder name=\"tests\">\n    <file name=\"test_rules_engine.py\">import os\nimport sys\nimport unittest\nfrom unittest.mock import Mock, MagicMock\nimport logging\n\n# Add the src directory to the path so we can import our modules\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Import the classes to test\nfrom src.agent.rules_engine import RulesEngine, CodeRule\n\n# Disable logging output during tests\nlogging.disable(logging.CRITICAL)\n\nclass TestRulesEngine(unittest.TestCase):\n    \"\"\"\n    Unit tests for the RulesEngine class.\n    \n    These tests validate the rule application logic and code recommendations.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        # Create a RulesEngine instance\n        self.rules_engine = RulesEngine()\n        \n        # Create a mock CPT database\n        self.mock_cpt_db = MagicMock()\n        \n        # Set up mock code details responses\n        self.mock_cpt_db.get_code_details.side_effect = self._mock_get_code_details\n    \n    def _mock_get_code_details(self, code):\n        \"\"\"Mock implementation of get_code_details.\"\"\"\n        # Define some test code details\n        code_details = {\n            '31231': {\n                'code': '31231',\n                'description': 'Nasal endoscopy, diagnostic',\n                'related_codes': ['31233', '31235']\n            },\n            '31233': {\n                'code': '31233',\n                'description': 'Nasal endoscopy with biopsy',\n                'related_codes': ['31231']\n            },\n            '69436': {\n                'code': '69436',\n                'description': 'Tympanostomy with tubes, bilateral',\n                'related_codes': ['69433']\n            },\n            '30520': {\n                'code': '30520',\n                'description': 'Septoplasty',\n                'related_codes': ['30930']\n            }\n        }\n        \n        if code in code_details:\n            return code_details[code]\n        else:\n            return {\"error\": f\"CPT code {code} not found\"}\n    \n    def test_initialize_rules(self):\n        \"\"\"Test that default rules are properly initialized.\"\"\"\n        # Check that rules were loaded\n        self.assertGreater(len(self.rules_engine.rules), 0)\n        \n        # Check that rules are sorted by priority\n        priorities = [rule.priority for rule in self.rules_engine.rules]\n        self.assertEqual(priorities, sorted(priorities, reverse=True))\n        \n        # Check that specific rules exist\n        rule_ids = [rule.rule_id for rule in self.rules_engine.rules]\n        self.assertIn(\"R001\", rule_ids)  # Bundled procedures\n        self.assertIn(\"R002\", rule_ids)  # Bilateral procedures\n    \n    def test_add_rule(self):\n        \"\"\"Test adding a custom rule.\"\"\"\n        # Initial rule count\n        initial_count = len(self.rules_engine.rules)\n        \n        # Add a new rule\n        new_rule = CodeRule(\n            rule_id=\"TEST001\",\n            description=\"Test rule\",\n            conditions=[{\"type\": \"test\"}],\n            priority=100\n        )\n        self.rules_engine.add_rule(new_rule)\n        \n        # Check rule was added\n        self.assertEqual(len(self.rules_engine.rules), initial_count + 1)\n        \n        # Check rule is first (highest priority)\n        self.assertEqual(self.rules_engine.rules[0].rule_id, \"TEST001\")\n    \n    def test_evaluate_bundled_codes(self):\n        \"\"\"Test evaluation of bundled codes.\"\"\"\n        # Test case: two potentially bundled codes\n        candidate_codes = ['31231', '31233']\n        procedure_text = \"Diagnostic nasal endoscopy with biopsy\"\n        \n        recommended, excluded, explanations = self.rules_engine.evaluate_bundled_codes(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Either 31231 or 31233 should be recommended, and the other excluded\n        self.assertEqual(len(recommended), 1)\n        self.assertEqual(len(excluded), 1)\n        self.assertEqual(len(explanations), 1)\n        \n        # Check that related code is properly identified\n        self.assertIn(explanations[0][\"rule_id\"], \"R001\")\n    \n    def test_evaluate_bilateral_procedures(self):\n        \"\"\"Test evaluation of bilateral procedures.\"\"\"\n        # Test case: bilateral procedure\n        candidate_codes = ['30520']\n        procedure_text = \"Bilateral septoplasty\"\n        \n        modified_codes, explanations = self.rules_engine.evaluate_bilateral_procedures(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Should add modifier 50 to the code\n        self.assertEqual(len(modified_codes), 1)\n        self.assertEqual(modified_codes[0], \"30520-50\")\n        self.assertEqual(len(explanations), 1)\n        \n        # Test case: non-bilateral procedure\n        candidate_codes = ['30520']\n        procedure_text = \"Septoplasty\"\n        \n        modified_codes, explanations = self.rules_engine.evaluate_bilateral_procedures(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Should not modify the code\n        self.assertEqual(len(modified_codes), 1)\n        self.assertEqual(modified_codes[0], \"30520\")\n        self.assertEqual(len(explanations), 0)\n    \n    def test_analyze_procedure(self):\n        \"\"\"Test the main analyze_procedure method.\"\"\"\n        # Test case: bilateral procedure with potential bundling\n        procedure_text = \"Bilateral nasal endoscopy with biopsy\"\n        candidate_codes = ['31231', '31233']\n        \n        result = self.rules_engine.analyze_procedure(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Check overall result structure\n        self.assertEqual(result[\"status\"], \"success\")\n        self.assertEqual(result[\"procedure_text\"], procedure_text)\n        self.assertIn(\"recommended_codes\", result)\n        self.assertIn(\"excluded_codes\", result)\n        self.assertIn(\"explanations\", result)\n        \n        # Check that at least one recommended code has modifier 50\n        has_bilateral_code = any(\"-50\" in code for code in result[\"recommended_codes\"])\n        self.assertTrue(has_bilateral_code)\n    \n    def test_analyze_procedure_no_candidates(self):\n        \"\"\"Test analyze_procedure with no candidate codes.\"\"\"\n        procedure_text = \"Some procedure description\"\n        candidate_codes = []\n        \n        result = self.rules_engine.analyze_procedure(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Should return an error\n        self.assertEqual(result[\"status\"], \"error\")\n        self.assertIn(\"message\", result)\n        self.assertEqual(result[\"recommended_codes\"], [])\n    \n    def test_get_coding_tips(self):\n        \"\"\"Test retrieving coding tips for a code.\"\"\"\n        # Test case: endoscopic procedure\n        tips = self.rules_engine.get_coding_tips(\n            '31231', 'Nasal endoscopy, diagnostic, endoscopic procedure'\n        )\n        \n        # Should return a list of tips\n        self.assertIsInstance(tips, list)\n        self.assertGreater(len(tips), 0)\n        \n        # Should include endoscopy-specific tips\n        has_endoscopy_tip = any(\"endoscopic\" in tip.lower() for tip in tips)\n        self.assertTrue(has_endoscopy_tip)\n        \n        # All procedures should have general tips\n        has_general_tips = any(\"medical necessity\" in tip.lower() for tip in tips)\n        self.assertTrue(has_general_tips)\n\n\nif __name__ == '__main__':\n    unittest.main()</file>\n    <file name=\"__init__.py\">\"\"\"\nTest package for the ENT CPT Code Agent.\n\nThis package contains unit tests for the various components of the agent.\n\"\"\"</file>\n    <file name=\"test_cpt_database.py\">import os\nimport sys\nimport unittest\nimport tempfile\nimport pandas as pd\nfrom pathlib import Path\nimport logging\n\n# Add the src directory to the path so we can import our modules\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Import the class to test\nfrom src.agent.cpt_database import CPTCodeDatabase\n\n# Disable logging output during tests\nlogging.disable(logging.CRITICAL)\n\nclass TestCPTCodeDatabase(unittest.TestCase):\n    \"\"\"\n    Unit tests for the CPTCodeDatabase class.\n    \n    These tests validate the functionality of loading, searching,\n    and retrieving CPT codes from the database.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        # Create a temporary Excel file with test data\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.test_file = os.path.join(self.temp_dir.name, \"test_cpt_codes.xlsx\")\n        \n        # Create test data\n        data = {\n            'CPT Code': ['31231', '69436', '42820', '30520'],\n            'Description': [\n                'Nasal endoscopy, diagnostic', \n                'Tympanostomy with tubes, bilateral', \n                'Tonsillectomy and adenoidectomy, under age 12', \n                'Septoplasty'\n            ],\n            'Category': ['Nose', 'Ear', 'Throat', 'Nose'],\n            'Related Codes': ['31233, 31235', '69433', '42821, 42825', '30930']\n        }\n        \n        # Create a DataFrame and save to Excel\n        df = pd.DataFrame(data)\n        df.to_excel(self.test_file, index=False)\n        \n        # Initialize the database with test data\n        self.cpt_db = CPTCodeDatabase(self.test_file)\n    \n    def tearDown(self):\n        \"\"\"Tear down test fixtures after each test method.\"\"\"\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n    \n    def test_load_data(self):\n        \"\"\"Test that data is loaded correctly from Excel file.\"\"\"\n        # Verify number of codes loaded\n        self.assertEqual(len(self.cpt_db.code_descriptions), 4)\n        \n        # Verify code descriptions\n        self.assertEqual(self.cpt_db.code_descriptions['31231'], 'Nasal endoscopy, diagnostic')\n        self.assertEqual(self.cpt_db.code_descriptions['69436'], 'Tympanostomy with tubes, bilateral')\n        \n        # Verify categories\n        self.assertIn('31231', self.cpt_db.code_categories['Nose'])\n        self.assertIn('69436', self.cpt_db.code_categories['Ear'])\n        \n        # Verify related codes\n        self.assertEqual(self.cpt_db.related_codes['31231'], ['31233', '31235'])\n        self.assertEqual(self.cpt_db.related_codes['69436'], ['69433'])\n    \n    def test_search_codes(self):\n        \"\"\"Test searching for codes by query.\"\"\"\n        # Search by code\n        results = self.cpt_db.search_codes('31231')\n        self.assertEqual(len(results), 1)\n        self.assertEqual(results[0]['code'], '31231')\n        \n        # Search by partial description\n        results = self.cpt_db.search_codes('endoscopy')\n        self.assertEqual(len(results), 1)\n        self.assertEqual(results[0]['code'], '31231')\n        \n        # Search by category (should match multiple)\n        results = self.cpt_db.search_codes('nose')\n        self.assertEqual(len(results), 2)\n        codes = [r['code'] for r in results]\n        self.assertIn('31231', codes)\n        self.assertIn('30520', codes)\n        \n        # Search with no matches\n        results = self.cpt_db.search_codes('xyz123')\n        self.assertEqual(len(results), 0)\n    \n    def test_get_code_details(self):\n        \"\"\"Test retrieving details for a specific code.\"\"\"\n        # Get details for valid code\n        details = self.cpt_db.get_code_details('42820')\n        self.assertEqual(details['code'], '42820')\n        self.assertEqual(details['description'], 'Tonsillectomy and adenoidectomy, under age 12')\n        self.assertEqual(details['related_codes'], ['42821', '42825'])\n        \n        # Get details for invalid code\n        details = self.cpt_db.get_code_details('99999')\n        self.assertIn('error', details)\n        self.assertEqual(details['error'], 'CPT code 99999 not found')\n    \n    def test_get_codes_by_category(self):\n        \"\"\"Test retrieving codes by category.\"\"\"\n        # Get codes for Nose category\n        results = self.cpt_db.get_codes_by_category('Nose')\n        self.assertEqual(len(results), 2)\n        codes = [r['code'] for r in results]\n        self.assertIn('31231', codes)\n        self.assertIn('30520', codes)\n        \n        # Get codes for non-existent category\n        results = self.cpt_db.get_codes_by_category('Unknown')\n        self.assertEqual(len(results), 0)\n    \n    def test_get_code_validation(self):\n        \"\"\"Test code validation functionality.\"\"\"\n        # Validate valid code\n        result = self.cpt_db.get_code_validation('30520')\n        self.assertTrue(result['valid'])\n        self.assertEqual(result['description'], 'Septoplasty')\n        \n        # Validate invalid code\n        result = self.cpt_db.get_code_validation('12345')\n        self.assertFalse(result['valid'])\n        self.assertIn('error', result)\n\nif __name__ == '__main__':\n    unittest.main()</file>\n  </folder>\n  <folder name=\"docs\">\n    <file name=\"PROJECT_SUMMARY.md\"># ENT CPT Code Agent - Project Summary\n\n## Project Overview\n\nThe ENT CPT Code Agent is a comprehensive AI-powered assistant designed to help medical professionals accurately determine the appropriate CPT codes for ENT (Ear, Nose, Throat) procedures according to official coding guidelines. The system leverages LM Studio to provide an intelligent interface that can understand natural language descriptions of procedures and recommend the most appropriate codes based on medical coding rules.\n\n## Key Components\n\n### 1. CPT Code Database\n\nThe `CPTCodeDatabase` class manages the loading, storing, and querying of CPT codes from an Excel file. It provides functionality for:\n- Searching for codes by description or keywords\n- Retrieving code details and validating codes\n- Organizing codes by category\n- Identifying related codes\n\n### 2. Rules Engine\n\nThe `RulesEngine` class implements medical coding rules for CPT code selection, handling:\n- Bundled procedures (codes that should not be reported together)\n- Bilateral procedures (requiring modifier 50)\n- Multiple procedures (requiring modifier 51)\n- Medical necessity validation\n- Custom rule creation and application\n\n### 3. Conversation Manager\n\nThe `ConversationManager` and `Conversation` classes handle user interactions, managing:\n- Conversation history storage and retrieval\n- Message tracking and organization\n- Conversion between internal representation and LM Studio chat format\n- CPT code extraction from conversation text\n\n### 4. Agent Core\n\nThe `ENTCPTAgent` class serves as the central component, integrating:\n- The LM Studio model for natural language understanding\n- Tool functions for CPT code operations\n- Query processing and response generation\n- Interactive session management\n\n### 5. API Interface\n\nThe `APIInterface` class provides a REST API for the agent, offering endpoints for:\n- Submitting queries to the agent\n- Searching for and validating CPT codes\n- Analyzing procedure descriptions\n- Managing conversation sessions\n\n### 6. Web UI\n\nA web-based user interface built with Flask that provides:\n- A chat interface for interacting with the agent\n- Tools for code search, validation, and analysis\n- Conversation history management\n- Detected code tracking and display\n\n## Architecture Design\n\nThe project follows a modular architecture with clear separation of concerns:\n\n1. **Data Layer**: CPT code database and persistence\n2. **Business Logic Layer**: Rules engine and agent core\n3. **Presentation Layer**: API interface and web UI\n4. **Integration Layer**: LM Studio integration\n\nComponents communicate through well-defined interfaces, allowing for:\n- Independent testing and development\n- Easy replacement or enhancement of individual components\n- Flexible deployment options (CLI, API, web)\n\n## Integration with LM Studio\n\nThe system integrates with LM Studio through its Python SDK. Key integration points:\n\n### LLM Initialization\n\n```python\n# Configure and load the model\nself.model = lms.llm(self.model_name, config={\n    \"temperature\": self.model_temperature,\n    \"maxTokens\": self.model_max_tokens\n})\n```\n\n### Tool Function Registration\n\nThe agent provides tool functions that the language model can use:\n- `search_cpt_codes`: Search for CPT codes based on a procedure description\n- `validate_cpt_code`: Validate if a CPT code exists and is correct\n- `get_category_codes`: Get all CPT codes for a specific category\n- `explain_coding_rules`: Explain the rules for using a specific CPT code\n- `analyze_procedure`: Analyze a procedure description to determine appropriate codes\n\n### Query Processing\n\n```python\n# Define the tool functions\ntools = [\n    self.search_cpt_codes,\n    self.validate_cpt_code,\n    self.get_category_codes,\n    self.explain_coding_rules,\n    self.analyze_procedure\n]\n\n# Let the model use tools to process the query\nresult = self.model.act(\n    chat,\n    tools,\n    on_message=lambda msg: conversation.add_message(\"assistant\", msg.content) if conversation else None\n)\n```\n\n## Getting Started\n\n1. Install the requirements: `pip install -r requirements.txt`\n2. Initialize the configuration: `python main.py init`\n3. Place the CPT code database file in the data directory\n4. Run the application in interactive mode: `python main.py interactive`\n\n## Development Workflow\n\nTo further develop and extend the project:\n\n1. **Setup the Development Environment**:\n   ```bash\n   # Clone the repository\n   git clone &lt;repository-url&gt; ent-cpt-agent\n   cd ent-cpt-agent\n   \n   # Create a virtual environment\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   \n   # Install development dependencies\n   pip install -r requirements-dev.txt\n   ```\n\n2. **Run Tests**:\n   ```bash\n   # Run all tests\n   python -m unittest discover\n   \n   # Run specific test file\n   python -m unittest tests.test_cpt_database\n   ```\n\n3. **Add New Features**:\n   - Create or modify code in the `src` directory\n   - Add tests in the `tests` directory\n   - Update documentation as needed\n\n4. **Build and Package**:\n   ```bash\n   # Build the package\n   python setup.py sdist bdist_wheel\n   \n   # Install locally for testing\n   pip install -e .\n   ```\n\n## Extending the Project\n\nThe ENT CPT Code Agent is designed to be extensible. Here are some ways to enhance it:\n\n1. **Add New Rules**: Create new `CodeRule` instances in the `RulesEngine` for additional coding guidelines.\n\n2. **Enhance the Database**: Add more fields to the CPT code database to support additional information, such as:\n   - Reimbursement rates\n   - Payer-specific guidelines\n   - Historical coding data\n\n3. **Improve the UI**: Enhance the web interface with additional features:\n   - Visualization of coding relationships\n   - Interactive procedure diagrams\n   - Documentation templates\n\n4. **Extend to Other Specialties**: Adapt the framework to support other medical specialties beyond ENT.\n\n## Deployment Options\n\nThe ENT CPT Code Agent supports multiple deployment scenarios:\n\n1. **Standalone Application**: Run the interactive CLI or web UI locally for individual users.\n\n2. **API Server**: Deploy as a service that other applications can integrate with via REST API.\n\n3. **Embedded Component**: Integrate the core logic into existing electronic medical record (EMR) systems.\n\n## Conclusion\n\nThe ENT CPT Code Agent provides a comprehensive solution for ENT procedure coding assistance. Its modular design, integration with LM Studio, and extensible architecture make it a powerful tool for medical professionals and coding specialists.\n</file>\n    <file name=\"integration_flow.mermaid\">flowchart TB\n    subgraph User[\"User Interaction\"]\n        CLI[\"Command Line Interface\"]\n        API[\"API/Web Interface\"]\n    end\n\n    subgraph Config[\"Configuration Layer\"]\n        AG_CONFIG[\"Agent Config\"]\n        AG_CONFIG --&gt; LOGGING[\"Logging System\"]\n    end\n\n    subgraph Core[\"Core Agent Components\"]\n        ENT_AGENT[\"ENT CPT Agent\"]\n        CONV_MGR[\"Conversation Manager\"]\n        CPT_DB[\"CPT Code Database\"]\n        RULES[\"Rules Engine\"]\n    end\n\n    subgraph AI[\"AI Engine\"]\n        LM_STUDIO[\"LM Studio Engine\"]\n        TOOLS[\"Tool Functions\"]\n    end\n\n    subgraph Storage[\"Persistence Layer\"]\n        CONV_STORE[\"Conversation Storage\"]\n        CPT_DATA[\"CPT Code Data (Excel)\"]\n    end\n\n    %% Connections\n    CLI --&gt; ENT_AGENT\n    API --&gt; ENT_AGENT\n    \n    AG_CONFIG --&gt; ENT_AGENT\n    \n    ENT_AGENT --&gt; CONV_MGR\n    ENT_AGENT --&gt; CPT_DB\n    ENT_AGENT --&gt; RULES\n    ENT_AGENT --&gt; LM_STUDIO\n    \n    CONV_MGR &lt;--&gt; CONV_STORE\n    CPT_DB &lt;--&gt; CPT_DATA\n    \n    LM_STUDIO --&gt; TOOLS\n    TOOLS --&gt; CPT_DB\n    TOOLS --&gt; RULES\n    \n    %% Styling\n    classDef primary fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    classDef secondary fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    classDef tertiary fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    classDef data fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px\n    \n    class ENT_AGENT,CONV_MGR primary\n    class CPT_DB,RULES secondary\n    class LM_STUDIO,TOOLS tertiary\n    class CONV_STORE,CPT_DATA,AG_CONFIG data\n</file>\n    <file name=\"api_docs.md\"># 6. API Documentation\n\nWhen running in server mode, the API documentation is available at:\n\n- OpenAPI UI: `http://localhost:8000/docs`\n- ReDoc UI: `http://localhost:8000/redoc`\n\n## 6.1 API Endpoints\n\n- `POST /api/query`: Submit a query to the agent\n- `POST /api/search`: Search for CPT codes\n- `POST /api/validate`: Validate a CPT code\n- `POST /api/analyze`: Analyze a procedure description\n- `GET /api/conversations`: List all conversations\n- `GET /api/conversations/{session_id}`: Get a specific conversation\n- `DELETE /api/conversations/{session_id}`: Delete a specific conversation\n</file>\n    <file name=\"usage_examples.md\"># ENT CPT Code Agent - Usage Examples\n\nThis document provides examples of using the ENT CPT Code Agent in different scenarios to help you get started.\n\n## 1. Basic Querying\n\n### Example 1: Finding codes for a specific procedure\n\n**Query:**\n```\nWhat is the CPT code for bilateral myringotomy with tube insertion?\n```\n\n**Response:**\n```\nBased on your description, the appropriate CPT code for bilateral myringotomy with tube insertion is:\n\n69436 - Tympanostomy (requiring insertion of ventilating tube), general anesthesia, bilateral\n\nThis code is used when performing a bilateral myringotomy (making an incision in both eardrums) with the insertion of ventilation tubes under general anesthesia.\n\nIf the procedure was performed under local anesthesia or with conscious sedation rather than general anesthesia, the appropriate code would be:\n\n69433 - Tympanostomy (requiring insertion of ventilating tube), local or topical anesthesia, bilateral\n\nKey coding considerations:\n1. The -50 modifier is not used with codes 69433 and 69436 because these codes already specify bilateral procedures\n2. Documentation should clearly indicate that the procedure was performed on both ears\n3. Ensure that medical necessity is properly documented in the patient's chart\n```\n\n### Example 2: Explaining coding rules\n\n**Query:**\n```\nExplain the coding rules for CPT code 31231\n```\n\n**Response:**\n```\nCoding guidelines for CPT 31231:\n\nDescription: Nasal endoscopy, diagnostic, unilateral or bilateral (separate procedure)\n\nGeneral coding rules:\n1. Code 31231 is used for diagnostic nasal endoscopy, which involves examining the nasal cavity using an endoscope.\n2. This code can be used for either unilateral (one side) or bilateral (both sides) diagnostic nasal endoscopy.\n3. The term \"separate procedure\" means that if this procedure is performed as part of another, more comprehensive procedure, it should not be reported separately.\n4. This code should not be reported with surgical endoscopy codes (31237-31294) when performed on the same side.\n\nDocumentation requirements:\n1. Medical record must document medical necessity for the diagnostic procedure\n2. Documentation should specify which side(s) were examined (right, left, or bilateral)\n3. Findings from the endoscopy must be clearly documented\n\nBundling considerations:\n- Code 31231 is often bundled with surgical nasal/sinus endoscopy procedures\n- It should not be billed separately when a surgical endoscopy is performed during the same encounter on the same side\n- It may be reported with modifier -59 if performed on the contralateral side of a surgical endoscopy\n\nRelated codes to consider: 31233, 31235, 31237, 31575\n\nAlways verify current coding guidelines, as they may change over time.\n```\n\n## 2. Using the Rules Engine\n\n### Example 3: Analyzing a procedure description\n\n**Query:**\n```\nAnalyze this procedure: \"Patient underwent bilateral endoscopic sinus surgery including maxillary antrostomy, anterior ethmoidectomy, and removal of polyps from both maxillary sinuses.\"\n```\n\n**Response:**\n```\nAnalysis of procedure: Patient underwent bilateral endoscopic sinus surgery including maxillary antrostomy, anterior ethmoidectomy, and removal of polyps from both maxillary sinuses.\n\nRecommended CPT codes:\n- 31267-50: Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus (Modifier 50 for bilateral procedure)\n- 31254-50: Nasal/sinus endoscopy, surgical; with ethmoidectomy, partial (anterior) (Modifier 50 for bilateral procedure)\n\nRecommendation details:\n- Added modifier 50 to code 31267 for bilateral procedure.\n- Added modifier 50 to code 31254 for bilateral procedure.\n- Code 31267 includes the maxillary antrostomy with removal of tissue (polyps) from the maxillary sinus\n- Code 31254 addresses the anterior ethmoidectomy component\n\nCoding tips:\n1. Documentation should clearly indicate the extent of each sinus entered and the work performed in each sinus\n2. When coding sinus procedures, it's important to code for each sinus operated on separately\n3. Ensure that the procedural documentation supports bilateral procedures\n4. Verify medical necessity documentation for each sinus procedure\n5. Modifier 50 (bilateral) is appropriate since the procedures were performed on both sides\n\nNote: The order of the codes may affect reimbursement due to multiple procedure payment reduction rules. The highest valued procedure should typically be listed first.\n```\n\n### Example 4: Validating a CPT code\n\n**Query:**\n```\nIs 42820 the correct code for tonsillectomy and adenoidectomy in an adult?\n```\n\n**Response:**\n```\nCPT code 42820 is valid, but it's not the most appropriate code for tonsillectomy and adenoidectomy in an adult.\n\nThe description for 42820 is: \"Tonsillectomy and adenoidectomy; younger than age 12\"\n\nFor an adult patient, the correct code would be:\n42821 - Tonsillectomy and adenoidectomy; age 12 or over\n\nKey points about these codes:\n1. Age is a determining factor in code selection between 42820 and 42821\n2. For adult patients (age 12 or over), 42821 is the appropriate code\n3. The procedure includes both tonsillectomy and adenoidectomy\n4. No modifier is needed to indicate that both procedures were performed since the code description already includes both\n\nIf only one of the procedures was performed, you would use a different code:\n- 42825 or 42826 for tonsillectomy alone (based on age)\n- 42830 or 42831 for adenoidectomy alone (based on age)\n\nAlways ensure your documentation clearly indicates medical necessity for both the tonsillectomy and adenoidectomy components.\n```\n\n## 3. Advanced Queries\n\n### Example 5: Comparing related codes\n\n**Query:**\n```\nWhat's the difference between CPT codes 69421 and 69424 for myringotomy?\n```\n\n**Response:**\n```\nHere's a comparison of CPT codes 69421 and 69424 for myringotomy procedures:\n\nCPT Code 69421:\n- Description: Myringotomy including aspiration and/or eustachian tube inflation; requiring general anesthesia\n- Key elements: Includes incision of the tympanic membrane (eardrum) with aspiration and/or eustachian tube inflation\n- Anesthesia requirement: Must be performed under general anesthesia\n- Typical patients: Often used for younger children who cannot tolerate the procedure while awake\n- Does NOT include insertion of ventilation tubes\n\nCPT Code 69424:\n- Description: Myringotomy including aspiration and/or eustachian tube inflation; requiring local or topical anesthesia\n- Key elements: Includes the same procedure (incision of tympanic membrane with aspiration and/or eustachian tube inflation)\n- Anesthesia requirement: Performed under local or topical anesthesia\n- Typical patients: Generally used for older children or adults who can tolerate the procedure with local anesthesia\n- Does NOT include insertion of ventilation tubes\n\nKey differences:\n1. The primary distinction is the type of anesthesia used\n2. Code selection is based solely on the anesthesia method, not the procedure itself\n3. Neither code includes the insertion of ventilation/PE tubes\n\nIf tubes are inserted, you would use different codes:\n- 69433 (local anesthesia) or 69436 (general anesthesia) for tympanostomy with tube insertion\n\nDocumentation tips:\n- Clearly document the type of anesthesia used\n- Specify whether aspiration was performed\n- Note whether eustachian tube inflation was performed\n- Document medical necessity for the procedure\n```\n\n### Example 6: Complex scenario with multiple procedures\n\n**Query:**\n```\nWhat are the correct CPT codes for: Septoplasty, bilateral inferior turbinate reduction, and bilateral maxillary sinus surgery with tissue removal?\n```\n\n**Response:**\n```\nFor this complex ENT procedure involving septoplasty, bilateral inferior turbinate reduction, and bilateral maxillary sinus surgery with tissue removal, the appropriate CPT codes are:\n\n1. 30520 - Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft\n   - This code represents the septoplasty procedure\n   - No modifiers are needed as septoplasty is inherently a single procedure (not bilateral)\n\n2. 30140-50 - Submucous resection inferior turbinate, partial or complete, any method\n   - The -50 modifier indicates the procedure was performed bilaterally\n   - This code covers the bilateral inferior turbinate reduction\n\n3. 31267-50 - Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus\n   - The -50 modifier indicates the procedure was performed on both maxillary sinuses\n   - This code includes both the antrostomy (creating an opening) and tissue removal\n\nCoding guidelines to consider:\n1. These procedures are typically reported together when performed during the same operative session\n2. There are no specific NCCI edits that would prohibit reporting these codes together when properly documented\n3. Some payers may require modifier -51 (multiple procedures) on the second and third procedures\n4. The order of the codes may affect reimbursement (typically highest RVU procedure first)\n\nDocumentation requirements:\n1. Medical necessity for each procedure must be clearly documented\n2. Separate diagnoses supporting each procedure improve reimbursement likelihood\n3. Detailed operative notes should describe each procedure separately\n4. For the turbinate procedure, documentation should specify \"bilateral\" and the method used\n5. For the sinus procedure, documentation should indicate both sinuses were treated and describe the tissue removed\n\nAlways verify current coding guidelines with your specific payer, as policies may vary.\n```\n\n## 4. Tool Usage Examples\n\n### Example 7: Using the Search Tool\n\n**Query:**\n```\nSearch for CPT codes related to cochlear implants\n```\n\n**Response:**\n```\nI'll search for CPT codes related to cochlear implants.\n\nFound 4 CPT codes matching 'cochlear implants':\n\n1. Code 69930: Cochlear device implantation, with or without mastoidectomy\n   Related codes: 92601, 92602\n\n2. Code 69949: Unlisted procedure, inner ear\n   Related codes: None\n\n3. Code 92601: Diagnostic analysis of cochlear implant, patient younger than 7 years of age; with programming\n   Related codes: 69930, 92602\n\n4. Code 92602: Diagnostic analysis of cochlear implant, patient younger than 7 years of age; subsequent reprogramming\n   Related codes: 69930, 92601\n\nAdditionally, there are related codes for older patients and external components:\n\n5. Code 92603: Diagnostic analysis of cochlear implant, age 7 years or older; with programming\n   Related codes: 92604\n\n6. Code 92604: Diagnostic analysis of cochlear implant, age 7 years or older; subsequent reprogramming\n   Related codes: 92603\n\nThe main surgical code is 69930, which covers the implantation of the cochlear device. The other codes relate to programming and analysis of the implant, with different codes based on patient age.\n\nWould you like more specific information about any of these codes?\n```\n\n### Example 8: Using the Analyze Tool\n\n**Query:**\n```\nCan you analyze this procedure and tell me the correct codes: \"Functional endoscopic sinus surgery with left maxillary antrostomy, left ethmoidectomy, left sphenoidotomy, and septoplasty\"\n```\n\n**Response:**\n```\nAnalysis of procedure: Functional endoscopic sinus surgery with left maxillary antrostomy, left ethmoidectomy, left sphenoidotomy, and septoplasty\n\nRecommended CPT codes:\n- 31267: Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus\n- 31287: Nasal/sinus endoscopy, surgical, with sphenoidotomy\n- 31255: Nasal/sinus endoscopy, surgical; with ethmoidectomy, total (anterior and posterior)\n- 30520: Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft\n\nRecommendation details:\n- Code 31267 represents the left maxillary antrostomy\n- Code 31287 covers the left sphenoidotomy\n- Code 31255 is used for the left ethmoidectomy (assuming total ethmoidectomy from the description)\n- Code 30520 addresses the septoplasty procedure\n- No bilateral modifiers are needed as all sinus procedures are specified as left-sided\n- When reporting multiple endoscopic sinus procedures, each sinus is coded separately\n\nCoding guidelines:\n1. Proper sequencing is important - typically, the most resource-intensive procedure should be listed first\n2. No NCCI (National Correct Coding Initiative) edits prohibit reporting these codes together\n3. Some payers may require modifier -51 (multiple procedures) on the second and subsequent procedures\n4. Documentation must support medical necessity for each individual sinus procedure\n5. For the septoplasty (30520), be sure documentation indicates significant septal deviation requiring correction\n\nNote: If the ethmoidectomy was only partial/anterior rather than total, use code 31254 instead of 31255.\n```\n\n## 5. Web UI Examples\n\nThe Web UI provides a user-friendly interface for interacting with the ENT CPT Code Agent. Here are some key features:\n\n### Main Chat Interface\n\nThe main chat interface allows you to:\n\n- Ask questions about ENT procedures and CPT codes\n- View responses with detected CPT codes highlighted\n- Start new conversation sessions\n- Review conversation history\n\n### Tools Panel\n\nThe Tools panel provides specialized functions:\n\n1. **Search Tab**\n   - Search for CPT codes by keyword or description\n   - View matching codes with descriptions\n   - Add codes to the conversation with one click\n\n2. **Validate Tab**\n   - Validate specific CPT codes\n   - View code descriptions and validity\n   - Learn more about validated codes\n\n3. **Analyze Tab**\n   - Submit detailed procedure descriptions for analysis\n   - Specify candidate codes (optional)\n   - View recommended codes with explanations\n   - Discuss analysis results in the main chat\n\n### Detected Codes Panel\n\nThis panel displays all CPT codes detected in the conversation, allowing you to:\n\n- See a list of all codes mentioned in the conversation\n- Click on any code to validate it\n- Keep track of relevant codes for the current discussion\n\n## 6. API Integration Examples\n\n### Python Example\n\n```python\nimport requests\nimport json\n\nAPI_URL = \"http://localhost:8000/api\"\n\n# Query the agent\ndef query_agent(question, session_id=None):\n    response = requests.post(\n        f\"{API_URL}/query\",\n        json={\n            \"query\": question,\n            \"session_id\": session_id\n        }\n    )\n    return response.json()\n\n# Search for CPT codes\ndef search_codes(search_term):\n    response = requests.post(\n        f\"{API_URL}/search\",\n        json={\"search_term\": search_term}\n    )\n    return response.json()\n\n# Validate a CPT code\ndef validate_code(code):\n    response = requests.post(\n        f\"{API_URL}/validate\",\n        json={\"code\": code}\n    )\n    return response.json()\n\n# Analyze a procedure\ndef analyze_procedure(procedure_text, candidate_codes=None):\n    data = {\n        \"procedure_text\": procedure_text\n    }\n    if candidate_codes:\n        data[\"candidate_codes\"] = candidate_codes\n    \n    response = requests.post(\n        f\"{API_URL}/analyze\",\n        json=data\n    )\n    return response.json()\n\n# Example usage\nif __name__ == \"__main__\":\n    # Query about a procedure\n    result = query_agent(\"What is the CPT code for myringotomy with tube insertion?\")\n    print(json.dumps(result, indent=2))\n    \n    # Use the returned session ID for follow-up questions\n    session_id = result.get(\"session_id\")\n    result = query_agent(\"What if it's bilateral?\", session_id)\n    print(json.dumps(result, indent=2))\n    \n    # Search for related codes\n    search_result = search_codes(\"tympanoplasty\")\n    print(json.dumps(search_result, indent=2))\n```\n\n### JavaScript (Node.js) Example\n\n```javascript\nconst axios = require('axios');\n\nconst API_URL = 'http://localhost:8000/api';\n\n// Query the agent\nasync function queryAgent(question, sessionId = null) {\n  try {\n    const response = await axios.post(`${API_URL}/query`, {\n      query: question,\n      session_id: sessionId\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error querying agent:', error.message);\n    return null;\n  }\n}\n\n// Search for CPT codes\nasync function searchCodes(searchTerm) {\n  try {\n    const response = await axios.post(`${API_URL}/search`, {\n      search_term: searchTerm\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error searching codes:', error.message);\n    return null;\n  }\n}\n\n// Example usage\nasync function main() {\n  // Query about a procedure\n  const result = await queryAgent('What is the CPT code for balloon sinuplasty?');\n  console.log(JSON.stringify(result, null, 2));\n  \n  // Use the returned session ID for follow-up questions\n  const sessionId = result.session_id;\n  const followUpResult = await queryAgent('What documentation is required?', sessionId);\n  console.log(JSON.stringify(followUpResult, null, 2));\n  \n  // Search for related codes\n  const searchResult = await searchCodes('sinuplasty');\n  console.log(JSON.stringify(searchResult, null, 2));\n}\n\nmain();\n```\n\n### cURL Examples\n\n**Query the Agent:**\n```bash\ncurl -X POST http://localhost:8000/api/query \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"query\": \"What is the CPT code for nasal endoscopy?\",\n    \"session_id\": null\n  }'\n```\n\n**Search for CPT Codes:**\n```bash\ncurl -X POST http://localhost:8000/api/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"search_term\": \"endoscopy\"\n  }'\n```\n\n**Validate a CPT Code:**\n```bash\ncurl -X POST http://localhost:8000/api/validate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"code\": \"31231\"\n  }'\n```\n\n**Analyze a Procedure:**\n```bash\ncurl -X POST http://localhost:8000/api/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"procedure_text\": \"Bilateral myringotomy with tube placement under general anesthesia\",\n    \"candidate_codes\": [\"69433\", \"69436\"]\n  }'\n```\n\n## 7. Workflow Examples\n\n### Typical Coding Workflow\n\n#### Example A: New Patient with Sinusitis\n\n1. **Initial Assessment**:\n   - Query: \"What CPT codes are used for a new patient comprehensive ENT evaluation?\"\n   - Agent suggests E&amp;M codes (99202-99205) based on complexity\n\n2. **Diagnostic Procedures**:\n   - Query: \"The physician performed a nasal endoscopy. What code should I use?\"\n   - Agent suggests 31231 (Nasal endoscopy, diagnostic) with guidance on documentation requirements\n\n3. **Treatment Planning**:\n   - Query: \"The patient needs functional endoscopic sinus surgery for chronic sinusitis affecting the maxillary and ethmoid sinuses bilaterally. What codes apply?\"\n   - Agent analyzes the case and suggests appropriate surgical codes with modifiers\n\n4. **Code Validation**:\n   - Use the validation tool to verify all selected codes\n   - Review any bundling issues or modifier requirements\n\n#### Example B: Follow-up Visit After Surgery\n\n1. **Post-op Visit Coding**:\n   - Query: \"How do I code a follow-up visit 2 weeks after FESS surgery?\"\n   - Agent explains post-op period bundling rules and when separate E&amp;M codes can be used\n\n2. **Additional Procedures**:\n   - Query: \"The surgeon performed nasal debridement during the follow-up. Is this billable?\"\n   - Agent provides guidance on 31237 (Nasal/sinus endoscopy, surgical with debridement) and appropriate modifiers\n\n3. **Rule Clarification**:\n   - Query: \"Can you explain the global period for CPT 31255?\"\n   - Agent explains the standard global period and documentation requirements for separately billable services\n\n### Audit Preparation Workflow\n\n1. **Documentation Review**:\n   - Query: \"What documentation is required to support billing CPT 69436?\"\n   - Agent provides comprehensive documentation requirements\n\n2. **Code Selection Verification**:\n   - Query: \"Analyze this operative note: 'Patient underwent bilateral myringotomy with insertion of ventilation tubes under general anesthesia. Procedure performed due to recurrent otitis media with effusion refractory to medical management.'\"\n   - Agent analyzes the note and confirms correct code selection\n\n3. **Modifier Usage Review**:\n   - Query: \"When should modifier 59 be used with endoscopic sinus procedures?\"\n   - Agent explains appropriate use of modifier 59 for separate and distinct procedures\n\n## 8. Educational Examples\n\n### Learning About Coding Principles\n\n**Query:**\n```\nExplain the concept of bundling in ENT CPT coding\n```\n\n**Response:**\n```\nBundling in ENT CPT Coding:\n\nBundling refers to the practice of including multiple components of a procedure under a single CPT code rather than reporting them separately. This concept is fundamental to proper ENT coding and helps prevent inappropriate unbundling (reporting separate codes for procedures that should be reported together).\n\nKey principles of bundling in ENT coding:\n\n1. Comprehensive Codes: Many ENT CPT codes describe comprehensive procedures that include multiple steps or components. For example, code 69436 (bilateral tympanostomy tube insertion) includes the myringotomy (incision of the eardrum), aspiration of middle ear fluid, and placement of the tubes.\n\n2. \"Separate Procedure\" Designation: Some CPT codes are designated as \"separate procedures.\" This means that when the procedure is performed as part of a more comprehensive service, it should not be reported separately. For example, 31231 (diagnostic nasal endoscopy) is labeled as a separate procedure and should not be reported when a surgical nasal endoscopy is performed.\n\n3. NCCI Edits: The National Correct Coding Initiative (NCCI) maintains a database of procedure code pairs that should not be reported together. For ENT procedures, many diagnostic endoscopies are bundled with surgical endoscopies of the same anatomical site.\n\n4. Global Surgical Packages: Surgical procedures include a \"global period\" during which certain services are bundled with the procedure. For ENT surgeries, this typically includes:\n   - Preoperative evaluation on the day of surgery\n   - The surgical procedure itself\n   - Uncomplicated postoperative care for 10 or 90 days (depending on the procedure)\n   - Treatment of complications that don't require a return to the operating room\n\nCommon bundling scenarios in ENT coding:\n\n1. Endoscopic Sinus Surgery: When multiple sinuses are operated on during the same session, each sinus has its own CPT code, but diagnostic nasal endoscopy (31231) would be bundled.\n\n2. Ear Procedures: Microscopic examination of the ear is bundled into procedures like tympanostomy tube placement or tympanoplasty.\n\n3. Septoplasty with Turbinate Reduction: These are separate procedures with different CPT codes (30520 and 30140) that can be reported together when performed during the same operative session.\n\nTo avoid improper unbundling:\n- Thoroughly understand CPT code descriptions and included services\n- Regularly review NCCI edits for ENT procedures\n- Document each procedure component separately and clearly\n- Use appropriate modifiers only when truly separate, distinct services are performed\n\nRemember that improper unbundling can be considered fraudulent billing and may result in denied claims, audits, or compliance issues.\n```\n\n### Understanding Complex Coding Scenarios\n\n**Query:**\n```\nExplain how to code for a patient who had a septoplasty and then returned a week later with complications requiring surgical intervention\n```\n\n**Response:**\n```\nCoding for Septoplasty with Subsequent Complication Requiring Surgery:\n\nThis scenario involves two parts: the initial septoplasty and then the separate return to surgery for a complication. Here's how to approach coding for this situation:\n\nInitial Septoplasty:\n- CPT Code: 30520 (Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft)\n- This code has a 90-day global period, meaning postoperative care is bundled into the payment for 90 days after surgery\n\nReturn for Surgical Treatment of Complication:\n\nThe key coding principle here is whether the complication required a return to the operating room (OR). Complications treated in the OR during the global period are typically coded with:\n\n1. The appropriate CPT code for the procedure performed\n2. Modifier -78 (Unplanned Return to the Operating/Procedure Room by the Same Physician or Other Qualified Health Care Professional Following Initial Procedure for a Related Procedure During the Postoperative Period)\n\nFor example, if the patient developed a septal hematoma requiring drainage:\n- CPT Code: 30020-78 (Drainage of nasal septal abscess or hematoma, with modifier -78)\n\nIf the patient required revision septoplasty:\n- CPT Code: 30520-78 (Septoplasty with modifier -78)\n\nImportant coding guidelines:\n\n1. Documentation Requirements:\n   - The medical record must clearly establish that the complication is related to the initial procedure\n   - Documentation should specify the nature of the complication and why a return to the OR was necessary\n   - The operative report for the second procedure should reference the initial procedure\n\n2. Modifier -78:\n   - This modifier indicates an unplanned return to the OR for a related procedure\n   - It bypasses the global period restrictions\n   - The second procedure is typically reimbursed at a reduced rate (usually about 70% of the fee schedule)\n   - No additional E/M service should be reported for the decision to perform the second surgery\n\n3. Other Possible Modifiers:\n   - If the complication is treated without returning to the OR, no additional procedure coding is warranted (it's included in the global package)\n   - If the patient requires hospitalization for the complication, inpatient E/M services may be reported with modifier -24 (Unrelated E/M Service)\n\n4. Diagnosis Coding:\n   - The ICD-10 code for the second procedure should reflect the complication\n   - Consider using appropriate complication codes (T81.XXX series) that specify postprocedural complications\n   - Link the complication diagnosis to both the initial procedure and the complication\n\nExample scenario:\nA patient undergoes septoplasty (30520) on March 1st. On March 8th, the patient returns with a septal hematoma requiring drainage in the OR. The correct coding would be:\n- 30020-78 (Drainage of nasal septal hematoma with return to OR modifier)\n- Diagnosis: T81.0XXA (Hemorrhage and hematoma complicating a procedure, initial encounter)\n\nRemember that proper documentation is crucial for supporting the medical necessity of the second procedure and establishing its relationship to the initial surgery.\n```\n\n## 9. Continuous Learning and Improvement\n\nThe ENT CPT Code Agent continuously learns from interactions and improves its responses. Here are ways to help enhance the system:\n\n1. **Provide Feedback**: When the agent provides incorrect or incomplete information, inform it directly in the conversation.\n\n2. **Ask for Clarification**: If a response is unclear, ask follow-up questions to get more specific information.\n\n3. **Request Updates**: When coding rules change, inform the agent so it can provide the most current guidance.\n\n4. **Suggest New Features**: If you find yourself repeatedly performing certain tasks manually, suggest new tools or capabilities.\n\n5. **Share Complex Cases**: Challenging coding scenarios help the system improve its reasoning capabilities.\n\nBy actively engaging with the ENT CPT Code Agent and providing constructive feedback, you contribute to making it a more valuable coding resource for everyone.</file>\n    <file name=\"installation_guide.md\"># ENT CPT Code Agent - Installation &amp; Setup Guide\n\nThis guide will walk you through the installation and setup process for the ENT CPT Code Agent system.\n\n## 1. Prerequisites\n\nBefore starting, ensure you have the following installed:\n\n- **Python 3.8+**: Required for running the application\n- **pip**: Python package manager\n- **LM Studio**: Required for running the language models locally\n- **Excel**: For viewing/editing the CPT codes database\n\n## 2. Installation\n\n### 2.1 Clone the Repository\n\n```bash\ngit clone https://github.com/your-organization/ent-cpt-agent.git\ncd ent-cpt-agent\n```\n\n### 2.2 Create a Virtual Environment\n\n```bash\n# Create a virtual environment\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n```\n\n### 2.3 Install Dependencies\n\n```bash\npip install -r requirements.txt\n```\n\nThe `requirements.txt` file should include:\n\n```\nlmstudio\npandas\nopenpyxl\nflask\nfastapi\nuvicorn\nrequests\npython-dotenv\nlogging\nargparse\n```\n\n## 3. Configuration\n\n### 3.1 Initialize Default Configuration\n\n```bash\npython main-app.py init\n```\n\nThis will create a default `config.json` file with the following structure:\n\n```json\n{\n  \"model\": {\n    \"name\": \"qwen2.5-7b-instruct\",\n    \"temperature\": 0.2,\n    \"max_tokens\": 1024,\n    \"context_length\": 8192\n  },\n  \"cpt_database\": {\n    \"file_path\": \"CPT codes for ENT.xlsx\",\n    \"sheet_name\": \"Sheet1\"\n  },\n  \"agent\": {\n    \"log_level\": \"INFO\",\n    \"save_conversations\": true,\n    \"conversation_dir\": \"conversations\"\n  },\n  \"server\": {\n    \"host\": \"localhost\",\n    \"port\": 8000,\n    \"enable_api\": false\n  }\n}\n```\n\n### 3.2 Prepare the CPT Codes Database\n\n1. Ensure that the `CPT codes for ENT.xlsx` file is in the root directory\n2. The Excel file should have the following columns:\n   - CPT Code\n   - Description\n   - Category\n   - Related Codes (comma-separated)\n\n### 3.3 Set Up LM Studio\n\n1. Install and launch LM Studio\n2. Download the recommended model (default: qwen2.5-7b-instruct)\n3. Ensure LM Studio's Python SDK is properly installed:\n   \n   ```bash\n   pip install lmstudio\n   ```\n\n4. Set up LM Studio to run in server mode:\n   \n   ```bash\n   lms server start\n   ```\n\n## 4. Running the Application\n\n### 4.1 Interactive Mode\n\nRun the application in interactive command-line mode:\n\n```bash\npython main-app.py interactive\n```\n\nThis will start an interactive session where you can ask questions about ENT procedures and CPT codes.\n\n### 4.2 API Server Mode\n\nRun the application as an API server:\n\n```bash\npython main-app.py server --host localhost --port 8000\n```\n\nThis will start the API server on the specified host and port.\n\n### 4.3 Web UI Mode\n\nRun the web UI application:\n\n```bash\n# Set environment variables for API connection\nexport API_HOST=localhost\nexport API_PORT=8000\nexport WEB_PORT=5000\nexport DEBUG=False\n\n# Run the web UI\npython web_ui.py\n```\n\nThen open your web browser and navigate to `http://localhost:5000` to access the web UI.\n\n### 4.4 Single Query Mode\n\nProcess a single query and exit:\n\n```bash\npython main.py query \"What is the CPT code for tympanostomy tube insertion?\"\n```\n\n## 5. Advanced Configuration\n\n### 5.1 Changing the Language Model\n\nYou can change the LM Studio model used by the agent in the `config.json` file:\n\n```json\n{\n  \"model\": {\n    \"name\": \"llama-3.1-8b-instruct\",\n    \"temperature\": 0.2,\n    \"max_tokens\": 1024\n  }\n}\n```\n\nEnsure that the model is downloaded and available in LM Studio.\n\n### 5.2 Logging Configuration\n\nYou can adjust the logging level in the `config.json` file:\n\n```json\n{\n  \"agent\": {\n    \"log_level\": \"DEBUG\"\n  }\n}\n```\n\nAvailable logging levels: DEBUG, INFO, WARNING, ERROR, CRITICAL\n\n### 5.3 Conversation Storage\n\nBy default, conversations are stored in the `conversations` directory. You can change this in the `config.json` file:\n\n```json\n{\n  \"agent\": {\n    \"save_conversations\": true,\n    \"conversation_dir\": \"custom_conversations_dir\"\n  }\n}\n```\n\n## 6. API Documentation\n\nWhen running in server mode, the API documentation is available at:\n\n- OpenAPI UI: `http://localhost:8000/docs`\n- ReDoc UI: `http://localhost:8000/redoc`\n\n### 6.1 API Endpoints\n\n- `POST /api/query`: Submit a query to the agent\n- `POST /api/search`: Search for CPT codes\n- `POST /api/validate`: Validate a CPT code\n- `POST /api/analyze`: Analyze a procedure description\n- `GET /api/conversations`: List all conversations\n- `GET /api/conversations/{session_id}`: Get a specific conversation\n- `DELETE /api/conversations/{session_id}`: Delete a specific conversation\n\n## 7. Troubleshooting\n\n### 7.1 Common Issues\n\n#### LM Studio Connection Issues\n\nIf you encounter issues connecting to LM Studio:\n\n1. Ensure LM Studio is running in server mode: `lms server start`\n2. Check the logs for any error messages: `lms log stream`\n3. Verify the model is properly loaded in LM Studio\n\n#### CPT Database Issues\n\nIf you encounter issues with the CPT database:\n\n1. Ensure the `CPT codes for ENT.xlsx` file is in the correct location\n2. Verify the Excel file has the required columns\n3. Check for any error messages in the logs\n\n#### API Connection Issues\n\nIf the web UI cannot connect to the API:\n\n1. Ensure the API server is running: `python main.py server`\n2. Verify the API host and port settings are correct\n3. Check for any firewall issues that might block the connection\n\n### 7.2 Logs\n\nLogs are saved to `ent_cpt_agent.log` by default. You can check this file for detailed error messages and debugging information.\n\n## 8. Contributing\n\nWe welcome contributions to improve the ENT CPT Code Agent. Please follow these steps:\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Submit a pull request\n\n## 9. License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n</file>\n  </folder>\n  <folder name=\"conversations\" />\n  <folder name=\"scripts\">\n    <file name=\"install.sh\">#!/bin/bash\n# Installation script for ENT CPT Code Agent\n\n# Exit on error\nset -e\n\necho \"Installing ENT CPT Code Agent...\"\n\n# Create virtual environment if it doesn't exist\nif [ ! -d \"venv\" ]; then\n    echo \"Creating virtual environment...\"\n    python -m venv venv\nfi\n\n# Activate virtual environment\nif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"win32\" ]]; then\n    # Windows\n    source venv/Scripts/activate\nelse\n    # Unix-like\n    source venv/bin/activate\nfi\n\n# Install dependencies\necho \"Installing dependencies...\"\npip install -r requirements.txt\n\n# Initialize default configuration if it doesn't exist\nif [ ! -f \"config.json\" ]; then\n    echo \"Initializing default configuration...\"\n    python main.py init\nfi\n\n# Create required directories\necho \"Creating required directories...\"\nmkdir -p data conversations\n\n# Check if CPT codes database exists\nif [ ! -f \"data/CPT codes for ENT.xlsx\" ]; then\n    echo \"WARNING: CPT codes database file not found at 'data/CPT codes for ENT.xlsx'\"\n    echo \"Please add the database file before running the application.\"\nfi\n\n# Install package in development mode\necho \"Installing package in development mode...\"\npip install -e .\n\necho \"Installation complete!\"\necho \"\"\necho \"To start the interactive mode, run: python main.py interactive\"\necho \"To start the API server, run: python main.py server\"\necho \"To start the web UI, run: python web_ui.py\"</file>\n    <file name=\"run_server.sh\">#!/bin/bash\n# Script to run the ENT CPT Code Agent API and Web UI servers\n\n# Exit on error\nset -e\n\n# Default ports\nAPI_PORT=8000\nWEB_PORT=5000\nHOST=\"localhost\"\nDEBUG=false\n\n# Process command line arguments\nwhile [[ $# -gt 0 ]]; do\n    key=\"$1\"\n    case $key in\n        --api-port)\n        API_PORT=\"$2\"\n        shift\n        shift\n        ;;\n        --web-port)\n        WEB_PORT=\"$2\"\n        shift\n        shift\n        ;;\n        --host)\n        HOST=\"$2\"\n        shift\n        shift\n        ;;\n        --debug)\n        DEBUG=true\n        shift\n        ;;\n        *)\n        echo \"Unknown option: $key\"\n        echo \"Usage: $0 [--api-port PORT] [--web-port PORT] [--host HOST] [--debug]\"\n        exit 1\n        ;;\n    esac\ndone\n\n# Activate virtual environment\nif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"win32\" ]]; then\n    # Windows\n    source venv/Scripts/activate\nelse\n    # Unix-like\n    source venv/bin/activate\nfi\n\n# Start API server in the background\necho \"Starting API server on $HOST:$API_PORT...\"\npython main.py server --host $HOST --port $API_PORT &amp;\nAPI_PID=$!\n\n# Wait for API server to start\necho \"Waiting for API server to start...\"\nsleep 3\n\n# Start Web UI server\necho \"Starting Web UI on $HOST:$WEB_PORT...\"\nexport API_HOST=$HOST\nexport API_PORT=$API_PORT\nexport WEB_PORT=$WEB_PORT\nexport DEBUG=$DEBUG\npython web_ui.py\n\n# Clean up when Web UI is terminated\nkill $API_PID</file>\n  </folder>\n  <folder name=\"data\">\n    <file name=\"CPT codes for ENT.xlsx\">Error reading file: 'utf-8' codec can't decode bytes in position 15-16: invalid continuation byte</file>\n  </folder>\n  <folder name=\"src\">\n    <file name=\"__init__.py\">\"\"\"\nENT CPT Code Agent package.\nAn AI-powered assistant for ENT CPT code selection and validation.\n\"\"\"\n\n__version__ = '1.0.0'</file>\n    <file name=\"main.py\">\"\"\"\nMain module for the ENT CPT Code Agent.\nContains the main functionality for the CLI application.\n\"\"\"\n\nimport argparse\nimport logging\nimport os\nimport sys\nfrom typing import Dict, Any\n\nfrom .config.agent_config import AgentConfig, setup_logging\nfrom .conversation.conversation_manager import ConversationManager\nfrom .agent.ent_cpt_agent import ENTCPTAgent\nfrom .api.api_interface import APIInterface\n\ndef parse_arguments():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"ENT CPT Code Agent - An AI assistant for ENT procedure coding\"\n    )\n    \n    # General arguments\n    parser.add_argument(\n        \"--config\", \n        type=str, \n        default=\"config.json\",\n        help=\"Path to configuration file\"\n    )\n    parser.add_argument(\n        \"--log-level\", \n        type=str, \n        choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        default=None,\n        help=\"Logging level (overrides config file)\"\n    )\n    \n    # Subcommands\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Command to run\")\n    \n    # Interactive mode\n    interactive_parser = subparsers.add_parser(\n        \"interactive\", \n        help=\"Run in interactive command-line mode\"\n    )\n    \n    # Server mode\n    server_parser = subparsers.add_parser(\n        \"server\", \n        help=\"Run as an API server\"\n    )\n    server_parser.add_argument(\n        \"--host\", \n        type=str, \n        default=None,\n        help=\"Host to run the server on (overrides config file)\"\n    )\n    server_parser.add_argument(\n        \"--port\", \n        type=int, \n        default=None,\n        help=\"Port to run the server on (overrides config file)\"\n    )\n    \n    # Single query mode\n    query_parser = subparsers.add_parser(\n        \"query\", \n        help=\"Process a single query and exit\"\n    )\n    query_parser.add_argument(\n        \"text\", \n        type=str,\n        help=\"Query text to process\"\n    )\n    \n    # Initialize config\n    init_parser = subparsers.add_parser(\n        \"init\", \n        help=\"Initialize default configuration file\"\n    )\n    \n    return parser.parse_args()\n\ndef run_interactive_mode(agent: ENTCPTAgent):\n    \"\"\"Run the agent in interactive CLI mode.\"\"\"\n    agent.run_interactive_session()\n\ndef run_server_mode(agent: ENTCPTAgent, config: AgentConfig, host: str = None, port: int = None):\n    \"\"\"Run the agent as an API server.\"\"\"\n    # Use provided host/port or get from config\n    host = host or config.get(\"server\", \"host\")\n    port = port or config.get(\"server\", \"port\")\n    \n    # Create and start API server\n    api = APIInterface(agent, config, host, port)\n    api.start()\n\ndef run_single_query(agent: ENTCPTAgent, query: str):\n    \"\"\"Process a single query and print the result.\"\"\"\n    response = agent.process_query(query)\n    print(response)\n\ndef main():\n    \"\"\"Main entry point for the application.\"\"\"\n    # Parse command line arguments\n    args = parse_arguments()\n    \n    # Initialize configuration\n    config = AgentConfig(args.config)\n    \n    # Handle 'init' command first\n    if args.command == \"init\":\n        config.create_default_config()\n        print(f\"Initialized default configuration at {args.config}\")\n        return\n    \n    # Override config with command line arguments if provided\n    if args.log_level:\n        config.set(\"agent\", \"log_level\", args.log_level)\n    \n    # Setup logging\n    setup_logging(config)\n    logger = logging.getLogger(\"ent_cpt_agent.main\")\n    \n    try:\n        # Initialize conversation manager\n        conversation_manager = ConversationManager(\n            config.get(\"agent\", \"conversation_dir\")\n        )\n        \n        # Initialize the agent\n        logger.info(\"Initializing ENT CPT Agent\")\n        agent = ENTCPTAgent(config, conversation_manager)\n        \n        # Run the appropriate command\n        if args.command == \"interactive\":\n            logger.info(\"Starting interactive session\")\n            run_interactive_mode(agent)\n        \n        elif args.command == \"server\":\n            logger.info(\"Starting API server\")\n            # Override config with command line arguments if provided\n            host = args.host or config.get(\"server\", \"host\")\n            port = args.port or config.get(\"server\", \"port\")\n            run_server_mode(agent, config, host, port)\n        \n        elif args.command == \"query\":\n            logger.info(f\"Processing single query: {args.text}\")\n            run_single_query(agent, args.text)\n        \n        else:\n            # No command specified, default to interactive mode\n            logger.info(\"No command specified, starting interactive session\")\n            run_interactive_mode(agent)\n    \n    except KeyboardInterrupt:\n        logger.info(\"Application terminated by user\")\n    except Exception as e:\n        logger.error(f\"Error running application: {e}\", exc_info=True)\n        return 1\n    \n    return 0\n</file>\n  </folder>\n  <folder name=\"src/config\">\n    <file name=\"__init__.py\">\"\"\"\nConfiguration module for the ENT CPT Code Agent.\nHandles loading, saving, and accessing configuration settings.\n\"\"\"\n\nfrom .agent_config import AgentConfig, setup_logging\n\n__all__ = ['AgentConfig', 'setup_logging']</file>\n    <file name=\"agent_config.py\">import json\nimport os\nfrom typing import Dict, Any, Optional\nimport logging\n\nlogger = logging.getLogger(\"ent_cpt_agent.config\")\n\nclass AgentConfig:\n    \"\"\"\n    Configuration manager for the ENT CPT Code Agent.\n    Handles loading, saving, and accessing configuration settings.\n    \"\"\"\n    \n    DEFAULT_CONFIG = {\n        \"model\": {\n            \"name\": \"qwen2.5-7b-instruct\",\n            \"temperature\": 0.2,\n            \"max_tokens\": 1024,\n            \"context_length\": 8192\n        },\n        \"cpt_database\": {\n            \"file_path\": \"CPT codes for ENT.xlsx\",\n            \"sheet_name\": \"Sheet1\"\n        },\n        \"agent\": {\n            \"log_level\": \"INFO\",\n            \"save_conversations\": True,\n            \"conversation_dir\": \"conversations\"\n        },\n        \"server\": {\n            \"host\": \"localhost\",\n            \"port\": 8000,\n            \"enable_api\": False\n        }\n    }\n    \n    def __init__(self, config_path: Optional[str] = \"config.json\"):\n        \"\"\"\n        Initialize the configuration manager.\n        \n        Args:\n            config_path: Path to the configuration file (default: \"config.json\")\n        \"\"\"\n        self.config_path = config_path\n        self.config = self.DEFAULT_CONFIG.copy()\n        self.load_config()\n    \n    def load_config(self) -&gt; None:\n        \"\"\"Load configuration from file if it exists.\"\"\"\n        if not self.config_path or not os.path.exists(self.config_path):\n            logger.info(f\"Config file not found at {self.config_path}, using defaults\")\n            return\n        \n        try:\n            with open(self.config_path, 'r') as f:\n                loaded_config = json.load(f)\n                \n            # Update the default config with loaded values\n            self._update_nested_dict(self.config, loaded_config)\n            logger.info(f\"Loaded configuration from {self.config_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading config file: {e}\")\n    \n    def _update_nested_dict(self, d: Dict[str, Any], u: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"\n        Update a nested dictionary with values from another dictionary.\n        \n        Args:\n            d: Target dictionary to update\n            u: Source dictionary with new values\n            \n        Returns:\n            Updated dictionary\n        \"\"\"\n        for k, v in u.items():\n            if isinstance(v, dict) and k in d and isinstance(d[k], dict):\n                self._update_nested_dict(d[k], v)\n            else:\n                d[k] = v\n        return d\n    \n    def save_config(self) -&gt; None:\n        \"\"\"Save the current configuration to file.\"\"\"\n        if not self.config_path:\n            logger.warning(\"No config path specified, cannot save configuration\")\n            return\n        \n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(self.config_path)), exist_ok=True)\n            \n            with open(self.config_path, 'w') as f:\n                json.dump(self.config, f, indent=2)\n            \n            logger.info(f\"Saved configuration to {self.config_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving config file: {e}\")\n    \n    def get(self, section: str, key: Optional[str] = None) -&gt; Any:\n        \"\"\"\n        Get a configuration value.\n        \n        Args:\n            section: Configuration section (e.g., \"model\", \"agent\")\n            key: Specific key within the section (optional)\n            \n        Returns:\n            Configuration value or section dictionary\n        \"\"\"\n        if section not in self.config:\n            return None\n        \n        if key is None:\n            return self.config[section]\n        \n        return self.config[section].get(key)\n    \n    def set(self, section: str, key: str, value: Any) -&gt; None:\n        \"\"\"\n        Set a configuration value.\n        \n        Args:\n            section: Configuration section (e.g., \"model\", \"agent\")\n            key: Specific key within the section\n            value: Value to set\n        \"\"\"\n        if section not in self.config:\n            self.config[section] = {}\n        \n        self.config[section][key] = value\n    \n    def create_default_config(self) -&gt; None:\n        \"\"\"Create a default configuration file if it doesn't exist.\"\"\"\n        if not self.config_path:\n            logger.warning(\"No config path specified, cannot create default configuration\")\n            return\n        \n        if os.path.exists(self.config_path):\n            logger.info(f\"Config file already exists at {self.config_path}\")\n            return\n        \n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(self.config_path)), exist_ok=True)\n            \n            with open(self.config_path, 'w') as f:\n                json.dump(self.DEFAULT_CONFIG, f, indent=2)\n            \n            logger.info(f\"Created default configuration at {self.config_path}\")\n        except Exception as e:\n            logger.error(f\"Error creating default config file: {e}\")\n\n\ndef setup_logging(config: AgentConfig) -&gt; None:\n    \"\"\"\n    Set up logging based on configuration.\n    \n    Args:\n        config: Agent configuration object\n    \"\"\"\n    log_level_name = config.get(\"agent\", \"log_level\")\n    log_level = getattr(logging, log_level_name, logging.INFO)\n    \n    logging.basicConfig(\n        level=log_level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.StreamHandler(),\n            logging.FileHandler(\"ent_cpt_agent.log\")\n        ]\n    )</file>\n  </folder>\n  <folder name=\"src/web\">\n    <file name=\"__init__.py\">\"\"\"\nWeb module for the ENT CPT Code Agent.\nProvides a web-based user interface for interacting with the agent.\n\"\"\"\n__all__ = []</file>\n    <file name=\"web_ui.py\">#!/usr/bin/env python3\n\"\"\"\nWeb UI server for the ENT CPT Code Agent.\nThis script starts the web interface server for the ENT CPT Code Agent.\n\"\"\"\n\nimport os\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(\"ent_cpt_agent_web_ui\")\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from environment variable or use default\n        port = int(os.environ.get(\"WEB_PORT\", \"5000\"))\n        host = os.environ.get(\"WEB_HOST\", \"0.0.0.0\")\n        debug = os.environ.get(\"DEBUG\", \"False\").lower() == \"true\"\n        \n        logger.info(f\"Starting web UI server on {host}:{port} (debug={debug})\")\n        \n        # Start the Flask application\n        app.run(host=host, port=port, debug=debug)\n    except Exception as e:\n        logger.error(f\"Error starting web UI server: {e}\")\n        exit(1)</file>\n  </folder>\n  <folder name=\"src/web/templates\">\n    <file name=\"index.html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;ENT CPT Code Assistant&lt;/title&gt;\n    &lt;!-- Bootstrap CSS --&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\" rel=\"stylesheet\"&gt;\n    &lt;!-- Font Awesome --&gt;\n    &lt;link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f8f9fa;\n            padding-top: 20px;\n        }\n        .chat-container {\n            height: 500px;\n            overflow-y: auto;\n            border: 1px solid #dee2e6;\n            border-radius: 0.375rem;\n            background-color: white;\n            padding: 1rem;\n            margin-bottom: 1rem;\n        }\n        .user-message {\n            background-color: #f0f7ff;\n            border-radius: 15px 15px 0 15px;\n            padding: 10px 15px;\n            margin-bottom: 10px;\n            max-width: 80%;\n            align-self: flex-end;\n            margin-left: auto;\n        }\n        .assistant-message {\n            background-color: #f1f3f4;\n            border-radius: 15px 15px 15px 0;\n            padding: 10px 15px;\n            margin-bottom: 10px;\n            max-width: 80%;\n        }\n        .code-pill {\n            background-color: #e7f2fa;\n            color: #1a73e8;\n            border: 1px solid #c2e0f4;\n            border-radius: 16px;\n            padding: 4px 12px;\n            font-size: 0.8rem;\n            font-weight: 500;\n            margin-right: 5px;\n            margin-bottom: 5px;\n            display: inline-block;\n            cursor: pointer;\n        }\n        .code-pill:hover {\n            background-color: #d3e7f8;\n        }\n        .message-time {\n            font-size: 0.7rem;\n            color: #6c757d;\n            margin-top: 5px;\n            text-align: right;\n        }\n        .message-container {\n            display: flex;\n            flex-direction: column;\n            margin-bottom: 15px;\n        }\n        .spinner-border {\n            width: 1.5rem;\n            height: 1.5rem;\n        }\n        .tools-container {\n            background-color: #fff;\n            border: 1px solid #dee2e6;\n            border-radius: 0.375rem;\n            padding: 1rem;\n            margin-bottom: 1rem;\n        }\n        .session-info {\n            font-size: 0.8rem;\n            color: #6c757d;\n            margin-bottom: 10px;\n        }\n        .loading-message {\n            display: flex;\n            align-items: center;\n            font-style: italic;\n            color: #6c757d;\n        }\n        .nav-tabs .nav-link {\n            color: #495057;\n        }\n        .nav-tabs .nav-link.active {\n            font-weight: 500;\n        }\n        .tooltip-inner {\n            max-width: 300px;\n        }\n        #codesList {\n            margin-top: 10px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;div class=\"row mb-4\"&gt;\n            &lt;div class=\"col-12\"&gt;\n                &lt;h1 class=\"text-center mb-3\"&gt;ENT CPT Code Assistant&lt;/h1&gt;\n                &lt;p class=\"text-center text-muted\"&gt;Intelligent coding assistance for ENT procedures&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"row\"&gt;\n            &lt;!-- Main Chat Area --&gt;\n            &lt;div class=\"col-lg-8\"&gt;\n                &lt;div class=\"session-info\"&gt;\n                    Session ID: &lt;span id=\"sessionId\"&gt;{{ session_id }}&lt;/span&gt;\n                    &lt;button id=\"newSessionBtn\" class=\"btn btn-sm btn-outline-secondary ms-2\"&gt;\n                        &lt;i class=\"fas fa-plus-circle\"&gt;&lt;/i&gt; New Session\n                    &lt;/button&gt;\n                &lt;/div&gt;\n                \n                &lt;div class=\"chat-container\" id=\"chatContainer\"&gt;\n                    &lt;!-- Messages will appear here --&gt;\n                    &lt;div class=\"message-container\"&gt;\n                        &lt;div class=\"assistant-message\"&gt;\n                            Hello! I'm your ENT CPT Code Assistant. I can help you find the right CPT codes for ENT procedures. How can I help you today?\n                        &lt;/div&gt;\n                        &lt;div class=\"message-time\"&gt;\n                            Today, &lt;span id=\"currentTime\"&gt;&lt;/span&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                \n                &lt;form id=\"queryForm\" class=\"mb-4\"&gt;\n                    &lt;div class=\"input-group\"&gt;\n                        &lt;input type=\"text\" id=\"queryInput\" class=\"form-control\" placeholder=\"Describe the ENT procedure or ask a question...\" required&gt;\n                        &lt;button class=\"btn btn-primary\" type=\"submit\"&gt;\n                            &lt;i class=\"fas fa-paper-plane\"&gt;&lt;/i&gt; Send\n                        &lt;/button&gt;\n                    &lt;/div&gt;\n                &lt;/form&gt;\n            &lt;/div&gt;\n            \n            &lt;!-- Tools Panel --&gt;\n            &lt;div class=\"col-lg-4\"&gt;\n                &lt;div class=\"tools-container\"&gt;\n                    &lt;ul class=\"nav nav-tabs\" id=\"toolsTabs\" role=\"tablist\"&gt;\n                        &lt;li class=\"nav-item\" role=\"presentation\"&gt;\n                            &lt;button class=\"nav-link active\" id=\"search-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#search\" type=\"button\" role=\"tab\" aria-controls=\"search\" aria-selected=\"true\"&gt;Search&lt;/button&gt;\n                        &lt;/li&gt;\n                        &lt;li class=\"nav-item\" role=\"presentation\"&gt;\n                            &lt;button class=\"nav-link\" id=\"validate-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#validate\" type=\"button\" role=\"tab\" aria-controls=\"validate\" aria-selected=\"false\"&gt;Validate&lt;/button&gt;\n                        &lt;/li&gt;\n                        &lt;li class=\"nav-item\" role=\"presentation\"&gt;\n                            &lt;button class=\"nav-link\" id=\"analyze-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#analyze\" type=\"button\" role=\"tab\" aria-controls=\"analyze\" aria-selected=\"false\"&gt;Analyze&lt;/button&gt;\n                        &lt;/li&gt;\n                    &lt;/ul&gt;\n                    \n                    &lt;div class=\"tab-content p-3\" id=\"toolsTabContent\"&gt;\n                        &lt;!-- Search Tab --&gt;\n                        &lt;div class=\"tab-pane fade show active\" id=\"search\" role=\"tabpanel\" aria-labelledby=\"search-tab\"&gt;\n                            &lt;form id=\"searchForm\"&gt;\n                                &lt;div class=\"mb-3\"&gt;\n                                    &lt;label for=\"searchTerm\" class=\"form-label\"&gt;Search CPT Codes&lt;/label&gt;\n                                    &lt;div class=\"input-group\"&gt;\n                                        &lt;input type=\"text\" class=\"form-control\" id=\"searchTerm\" placeholder=\"Enter keywords...\" required&gt;\n                                        &lt;button class=\"btn btn-outline-primary\" type=\"submit\"&gt;\n                                            &lt;i class=\"fas fa-search\"&gt;&lt;/i&gt; Search\n                                        &lt;/button&gt;\n                                    &lt;/div&gt;\n                                    &lt;div class=\"form-text\"&gt;Search for CPT codes by keyword or description&lt;/div&gt;\n                                &lt;/div&gt;\n                            &lt;/form&gt;\n                            &lt;div id=\"searchResults\" class=\"mt-3\"&gt;&lt;/div&gt;\n                        &lt;/div&gt;\n                        \n                        &lt;!-- Validate Tab --&gt;\n                        &lt;div class=\"tab-pane fade\" id=\"validate\" role=\"tabpanel\" aria-labelledby=\"validate-tab\"&gt;\n                            &lt;form id=\"validateForm\"&gt;\n                                &lt;div class=\"mb-3\"&gt;\n                                    &lt;label for=\"codeToValidate\" class=\"form-label\"&gt;Validate CPT Code&lt;/label&gt;\n                                    &lt;div class=\"input-group\"&gt;\n                                        &lt;input type=\"text\" class=\"form-control\" id=\"codeToValidate\" placeholder=\"Enter CPT code...\" pattern=\"\\d{5}\" required&gt;\n                                        &lt;button class=\"btn btn-outline-primary\" type=\"submit\"&gt;\n                                            &lt;i class=\"fas fa-check-circle\"&gt;&lt;/i&gt; Validate\n                                        &lt;/button&gt;\n                                    &lt;/div&gt;\n                                    &lt;div class=\"form-text\"&gt;Enter a 5-digit CPT code to validate&lt;/div&gt;\n                                &lt;/div&gt;\n                            &lt;/form&gt;\n                            &lt;div id=\"validateResults\" class=\"mt-3\"&gt;&lt;/div&gt;\n                        &lt;/div&gt;\n                        \n                        &lt;!-- Analyze Tab --&gt;\n                        &lt;div class=\"tab-pane fade\" id=\"analyze\" role=\"tabpanel\" aria-labelledby=\"analyze-tab\"&gt;\n                            &lt;form id=\"analyzeForm\"&gt;\n                                &lt;div class=\"mb-3\"&gt;\n                                    &lt;label for=\"procedureText\" class=\"form-label\"&gt;Analyze Procedure&lt;/label&gt;\n                                    &lt;textarea class=\"form-control\" id=\"procedureText\" rows=\"3\" placeholder=\"Describe the ENT procedure in detail...\" required&gt;&lt;/textarea&gt;\n                                &lt;/div&gt;\n                                &lt;div class=\"mb-3\"&gt;\n                                    &lt;label for=\"candidateCodes\" class=\"form-label\"&gt;Candidate Codes (Optional)&lt;/label&gt;\n                                    &lt;input type=\"text\" class=\"form-control\" id=\"candidateCodes\" placeholder=\"Comma-separated CPT codes, e.g., 69436,69450\"&gt;\n                                    &lt;div class=\"form-text\"&gt;If you have specific codes in mind, enter them here&lt;/div&gt;\n                                &lt;/div&gt;\n                                &lt;button type=\"submit\" class=\"btn btn-outline-primary\"&gt;\n                                    &lt;i class=\"fas fa-microscope\"&gt;&lt;/i&gt; Analyze Procedure\n                                &lt;/button&gt;\n                            &lt;/form&gt;\n                            &lt;div id=\"analyzeResults\" class=\"mt-3\"&gt;&lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                \n                &lt;!-- Detected Codes Panel --&gt;\n                &lt;div class=\"tools-container\"&gt;\n                    &lt;h5&gt;&lt;i class=\"fas fa-tags\"&gt;&lt;/i&gt; Detected CPT Codes&lt;/h5&gt;\n                    &lt;p class=\"small text-muted\"&gt;Codes detected in the conversation&lt;/p&gt;\n                    &lt;div id=\"codesList\"&gt;\n                        &lt;p class=\"text-muted fst-italic\"&gt;No codes detected yet&lt;/p&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n    \n    &lt;!-- Bootstrap Bundle with Popper --&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js\"&gt;&lt;/script&gt;\n    &lt;!-- jQuery --&gt;\n    &lt;script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"&gt;&lt;/script&gt;\n    \n    &lt;script&gt;\n        $(document).ready(function() {\n            // Initialize tooltips\n            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'))\n            var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {\n                return new bootstrap.Tooltip(tooltipTriggerEl)\n            });\n            \n            // Set current time\n            const now = new Date();\n            $('#currentTime').text(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));\n            \n            // Scroll to bottom of chat\n            function scrollToBottom() {\n                const chatContainer = document.getElementById('chatContainer');\n                chatContainer.scrollTop = chatContainer.scrollHeight;\n            }\n            \n            // Format timestamp\n            function formatTime(timestamp) {\n                const date = new Date(timestamp);\n                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n            }\n            \n            // Add message to chat\n            function addMessage(content, role, timestamp = new Date().toISOString(), codes = []) {\n                const messageClass = role === 'user' ? 'user-message' : 'assistant-message';\n                const messageContainer = $('&lt;div class=\"message-container\"&gt;&lt;/div&gt;');\n                const messageElement = $(`&lt;div class=\"${messageClass}\"&gt;&lt;/div&gt;`).text(content);\n                const timeElement = $('&lt;div class=\"message-time\"&gt;&lt;/div&gt;').text(`Today, ${formatTime(timestamp)}`);\n                \n                messageContainer.append(messageElement).append(timeElement);\n                $('#chatContainer').append(messageContainer);\n                \n                // If there are codes in the message, extract and display them\n                if (codes &amp;&amp; codes.length &gt; 0) {\n                    updateDetectedCodes(codes);\n                }\n                \n                scrollToBottom();\n            }\n            \n            // Add loading message\n            function addLoadingMessage() {\n                const loadingContainer = $('&lt;div class=\"message-container\" id=\"loadingMessage\"&gt;&lt;/div&gt;');\n                const loadingMessage = $('&lt;div class=\"assistant-message loading-message\"&gt;&lt;/div&gt;')\n                    .append('&lt;div class=\"spinner-border text-primary me-2\" role=\"status\"&gt;&lt;span class=\"visually-hidden\"&gt;Loading...&lt;/span&gt;&lt;/div&gt;')\n                    .append('&lt;span&gt;Thinking...&lt;/span&gt;');\n                \n                loadingContainer.append(loadingMessage);\n                $('#chatContainer').append(loadingContainer);\n                scrollToBottom();\n            }\n            \n            // Remove loading message\n            function removeLoadingMessage() {\n                $('#loadingMessage').remove();\n            }\n            \n            // Update detected codes list\n            function updateDetectedCodes(newCodes) {\n                const codesListElement = $('#codesList');\n                \n                // Clear \"no codes\" message if present\n                if (codesListElement.find('.text-muted.fst-italic').length &gt; 0) {\n                    codesListElement.empty();\n                }\n                \n                // Add new codes\n                newCodes.forEach(code =&gt; {\n                    // Only add if not already present\n                    if (codesListElement.find(`[data-code=\"${code}\"]`).length === 0) {\n                        const codePill = $(`&lt;div class=\"code-pill\" data-code=\"${code}\" data-bs-toggle=\"tooltip\" title=\"Click to validate this code\"&gt;${code}&lt;/div&gt;`);\n                        codesListElement.append(codePill);\n                        \n                        // Initialize tooltip\n                        new bootstrap.Tooltip(codePill[0]);\n                        \n                        // Add click handler to validate code\n                        codePill.on('click', function() {\n                            // Set the code in the validate tab and switch to it\n                            $('#codeToValidate').val(code);\n                            $('#validate-tab').tab('show');\n                            $('#validateForm').submit();\n                        });\n                    }\n                });\n            }\n            \n            // Extract CPT codes from text\n            function extractCPTCodes(text) {\n                const pattern = /\\b\\d{5}\\b/g;\n                return text.match(pattern) || [];\n            }\n            \n            // Process query submission\n            $('#queryForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const queryInput = $('#queryInput');\n                const query = queryInput.val().trim();\n                \n                if (!query) return;\n                \n                // Add user message to chat\n                addMessage(query, 'user');\n                \n                // Clear input\n                queryInput.val('');\n                \n                // Show loading message\n                addLoadingMessage();\n                \n                // Send query to API\n                $.ajax({\n                    url: '/api/query',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        query: query,\n                        session_id: $('#sessionId').text()\n                    }),\n                    success: function(response) {\n                        // Remove loading message\n                        removeLoadingMessage();\n                        \n                        if (response.status === 'success') {\n                            // Add assistant message to chat\n                            addMessage(response.message, 'assistant', new Date().toISOString(), \n                                       response.data &amp;&amp; response.data.codes ? response.data.codes : []);\n                            \n                            // Update session ID if provided\n                            if (response.session_id) {\n                                $('#sessionId').text(response.session_id);\n                            }\n                        } else {\n                            // Add error message\n                            addMessage(`Error: ${response.message}`, 'assistant');\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        // Remove loading message\n                        removeLoadingMessage();\n                        \n                        // Add error message\n                        addMessage(`Sorry, there was an error processing your request: ${error}`, 'assistant');\n                    }\n                });\n            });\n            \n            // Process search form submission\n            $('#searchForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const searchTerm = $('#searchTerm').val().trim();\n                \n                if (!searchTerm) return;\n                \n                const searchResults = $('#searchResults');\n                searchResults.html('&lt;div class=\"d-flex align-items-center\"&gt;&lt;div class=\"spinner-border text-primary me-2\" role=\"status\"&gt;&lt;/div&gt;&lt;span&gt;Searching...&lt;/span&gt;&lt;/div&gt;');\n                \n                // Send search request to API\n                $.ajax({\n                    url: '/api/search',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        search_term: searchTerm\n                    }),\n                    success: function(response) {\n                        if (response.status === 'success' &amp;&amp; response.data) {\n                            const codes = response.data.codes;\n                            if (codes &amp;&amp; codes.length &gt; 0) {\n                                let resultsHtml = `&lt;div class=\"alert alert-success\"&gt;Found ${codes.length} matching CPT codes&lt;/div&gt;`;\n                                resultsHtml += '&lt;div class=\"list-group\"&gt;';\n                                \n                                codes.forEach(code =&gt; {\n                                    resultsHtml += `\n                                        &lt;div class=\"list-group-item list-group-item-action\"&gt;\n                                            &lt;div class=\"d-flex w-100 justify-content-between\"&gt;\n                                                &lt;h6 class=\"mb-1\"&gt;Code ${code.code}&lt;/h6&gt;\n                                                &lt;button class=\"btn btn-sm btn-outline-primary add-to-chat\" data-code=\"${code.code}\"&gt;\n                                                    &lt;i class=\"fas fa-plus\"&gt;&lt;/i&gt; Add to Chat\n                                                &lt;/button&gt;\n                                            &lt;/div&gt;\n                                            &lt;p class=\"mb-1\"&gt;${code.description}&lt;/p&gt;\n                                            ${code.related_codes &amp;&amp; code.related_codes.length &gt; 0 ? \n                                              `&lt;small class=\"text-muted\"&gt;Related codes: ${code.related_codes.join(', ')}&lt;/small&gt;` : ''}\n                                        &lt;/div&gt;\n                                    `;\n                                });\n                                \n                                resultsHtml += '&lt;/div&gt;';\n                                searchResults.html(resultsHtml);\n                                \n                                // Add event handler for \"Add to Chat\" buttons\n                                $('.add-to-chat').on('click', function() {\n                                    const code = $(this).data('code');\n                                    $('#queryInput').val(`Tell me about CPT code ${code}`);\n                                    $('#queryForm').submit();\n                                });\n                            } else {\n                                searchResults.html('&lt;div class=\"alert alert-warning\"&gt;No CPT codes found matching your search term.&lt;/div&gt;');\n                            }\n                        } else {\n                            searchResults.html(`&lt;div class=\"alert alert-danger\"&gt;Error: ${response.message || 'Unknown error'}&lt;/div&gt;`);\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        searchResults.html(`&lt;div class=\"alert alert-danger\"&gt;Error: ${error}&lt;/div&gt;`);\n                    }\n                });\n            });\n            \n            // Process validate form submission\n            $('#validateForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const code = $('#codeToValidate').val().trim();\n                \n                if (!code) return;\n                \n                const validateResults = $('#validateResults');\n                validateResults.html('&lt;div class=\"d-flex align-items-center\"&gt;&lt;div class=\"spinner-border text-primary me-2\" role=\"status\"&gt;&lt;/div&gt;&lt;span&gt;Validating...&lt;/span&gt;&lt;/div&gt;');\n                \n                // Send validate request to API\n                $.ajax({\n                    url: '/api/validate',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        code: code\n                    }),\n                    success: function(response) {\n                        if (response.status === 'success') {\n                            validateResults.html(`\n                                &lt;div class=\"alert alert-success\"&gt;\n                                    &lt;h6&gt;CPT Code ${code} is valid&lt;/h6&gt;\n                                    &lt;p&gt;${response.message || 'Valid CPT code'}&lt;/p&gt;\n                                    &lt;button class=\"btn btn-sm btn-outline-primary learn-more\" data-code=\"${code}\"&gt;\n                                        &lt;i class=\"fas fa-info-circle\"&gt;&lt;/i&gt; Learn More\n                                    &lt;/button&gt;\n                                &lt;/div&gt;\n                            `);\n                            \n                            // Add event handler for \"Learn More\" button\n                            $('.learn-more').on('click', function() {\n                                const code = $(this).data('code');\n                                $('#queryInput').val(`Explain the coding rules for CPT code ${code}`);\n                                $('#queryForm').submit();\n                            });\n                        } else {\n                            validateResults.html(`&lt;div class=\"alert alert-danger\"&gt;Error: ${response.message || 'Invalid CPT code'}&lt;/div&gt;`);\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        validateResults.html(`&lt;div class=\"alert alert-danger\"&gt;Error: ${error}&lt;/div&gt;`);\n                    }\n                });\n            });\n            \n            // Process analyze form submission\n            $('#analyzeForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const procedureText = $('#procedureText').val().trim();\n                const candidateCodesText = $('#candidateCodes').val().trim();\n                const candidateCodes = candidateCodesText ? candidateCodesText.split(',').map(code =&gt; code.trim()) : [];\n                \n                if (!procedureText) return;\n                \n                const analyzeResults = $('#analyzeResults');\n                analyzeResults.html('&lt;div class=\"d-flex align-items-center\"&gt;&lt;div class=\"spinner-border text-primary me-2\" role=\"status\"&gt;&lt;/div&gt;&lt;span&gt;Analyzing...&lt;/span&gt;&lt;/div&gt;');\n                \n                // Send analyze request to API\n                $.ajax({\n                    url: '/api/analyze',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        procedure_text: procedureText,\n                        candidate_codes: candidateCodes\n                    }),\n                    success: function(response) {\n                        if (response.status === 'success' &amp;&amp; response.data) {\n                            const analysis = response.data;\n                            \n                            let resultsHtml = `&lt;div class=\"alert alert-info\"&gt;\n                                &lt;h6&gt;Procedure Analysis&lt;/h6&gt;\n                                &lt;p class=\"small\"&gt;${analysis.procedure_text}&lt;/p&gt;\n                            &lt;/div&gt;`;\n                            \n                            if (analysis.recommended_codes &amp;&amp; analysis.recommended_codes.length &gt; 0) {\n                                resultsHtml += `&lt;h6 class=\"mt-3\"&gt;Recommended Codes:&lt;/h6&gt;\n                                &lt;ul class=\"list-group mb-3\"&gt;`;\n                                \n                                analysis.recommended_codes.forEach(code =&gt; {\n                                    resultsHtml += `&lt;li class=\"list-group-item d-flex justify-content-between align-items-center\"&gt;\n                                        ${code}\n                                        &lt;button class=\"btn btn-sm btn-outline-primary add-to-chat\" data-code=\"${code.split('-')[0]}\"&gt;\n                                            &lt;i class=\"fas fa-plus\"&gt;&lt;/i&gt;\n                                        &lt;/button&gt;\n                                    &lt;/li&gt;`;\n                                });\n                                \n                                resultsHtml += `&lt;/ul&gt;`;\n                                \n                                // Add explanations if available\n                                if (analysis.explanations &amp;&amp; analysis.explanations.length &gt; 0) {\n                                    resultsHtml += `&lt;h6&gt;Explanation:&lt;/h6&gt;\n                                    &lt;ul class=\"list-group\"&gt;`;\n                                    \n                                    analysis.explanations.forEach(explanation =&gt; {\n                                        resultsHtml += `&lt;li class=\"list-group-item\"&gt;${explanation.message}&lt;/li&gt;`;\n                                    });\n                                    \n                                    resultsHtml += `&lt;/ul&gt;`;\n                                }\n                                \n                                // Add \"Add to Chat\" button for the analysis\n                                resultsHtml += `&lt;div class=\"mt-3\"&gt;\n                                    &lt;button class=\"btn btn-primary add-analysis-to-chat\"&gt;\n                                        &lt;i class=\"fas fa-comment\"&gt;&lt;/i&gt; Discuss in Chat\n                                    &lt;/button&gt;\n                                &lt;/div&gt;`;\n                            } else {\n                                resultsHtml += `&lt;div class=\"alert alert-warning\"&gt;No recommended codes found for this procedure.&lt;/div&gt;`;\n                            }\n                            \n                            analyzeResults.html(resultsHtml);\n                            \n                            // Add event handler for \"Add to Chat\" buttons\n                            $('.add-to-chat').on('click', function() {\n                                const code = $(this).data('code');\n                                $('#queryInput').val(`Tell me about CPT code ${code}`);\n                                $('#queryForm').submit();\n                            });\n                            \n                            // Add event handler for \"Discuss in Chat\" button\n                            $('.add-analysis-to-chat').on('click', function() {\n                                $('#queryInput').val(`Can you explain why you recommended ${analysis.recommended_codes.join(', ')} for this procedure: \"${procedureText}\"`);\n                                $('#queryForm').submit();\n                            });\n                        } else {\n                            analyzeResults.html(`&lt;div class=\"alert alert-danger\"&gt;Error: ${response.message || 'Unknown error'}&lt;/div&gt;`);\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        analyzeResults.html(`&lt;div class=\"alert alert-danger\"&gt;Error: ${error}&lt;/div&gt;`);\n                    }\n                });\n            });\n            \n            // New session button\n            $('#newSessionBtn').on('click', function() {\n                // Confirm before starting new session\n                if (confirm('Start a new session? This will clear the current conversation.')) {\n                    // Request new session from server\n                    $.ajax({\n                        url: '/api/new_session',\n                        type: 'POST',\n                        contentType: 'application/json',\n                        data: JSON.stringify({}),\n                        success: function(response) {\n                            if (response.status === 'success') {\n                                // Update session ID\n                                $('#sessionId').text(response.session_id);\n                                \n                                // Clear chat\n                                $('#chatContainer').empty();\n                                \n                                // Add welcome message\n                                addMessage(\"Hello! I'm your ENT CPT Code Assistant. I can help you find the right CPT codes for ENT procedures. How can I help you today?\", 'assistant');\n                                \n                                // Clear codes list\n                                $('#codesList').html('&lt;p class=\"text-muted fst-italic\"&gt;No codes detected yet&lt;/p&gt;');\n                            } else {\n                                alert(`Error starting new session: ${response.message}`);\n                            }\n                        },\n                        error: function(xhr, status, error) {\n                            alert(`Error starting new session: ${error}`);\n                        }\n                    });\n                }\n            });\n            \n            // Health check on page load\n            $.ajax({\n                url: '/api/health',\n                type: 'GET',\n                success: function(response) {\n                    if (response.status !== 'success') {\n                        alert(`Warning: ${response.message}`);\n                    }\n                },\n                error: function(xhr, status, error) {\n                    alert(`Error: Cannot connect to the backend API (${error}). Some features may not work.`);\n                }\n            });\n        });\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</file>\n  </folder>\n  <folder name=\"src/agent\">\n    <file name=\"ent_cpt_agent.py\">import os\nimport pandas as pd\nimport re\nimport lmstudio as lms\nfrom typing import List, Dict, Any, Optional, Tuple\nimport argparse\nimport logging\nimport json\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(\"ent_cpt_agent\")\n\nclass CPTCodeDatabase:\n    \"\"\"\n    Handles loading, processing, and querying of CPT codes for ENT procedures.\n    \"\"\"\n    def __init__(self, file_path: str):\n        \"\"\"\n        Initialize the CPT code database from the provided Excel file.\n        \n        Args:\n            file_path: Path to the Excel file containing CPT codes\n        \"\"\"\n        self.file_path = file_path\n        self.df = None\n        self.code_descriptions = {}\n        self.code_categories = {}\n        self.related_codes = {}\n        self.load_data()\n    \n    def load_data(self) -&gt; None:\n        \"\"\"Load CPT code data from Excel file and process it.\"\"\"\n        logger.info(f\"Loading CPT codes from {self.file_path}\")\n        try:\n            self.df = pd.read_excel(self.file_path)\n            \n            # Process the dataframe to create lookup dictionaries\n            for _, row in self.df.iterrows():\n                code = str(row.get('CPT Code', '')).strip()\n                if code and not pd.isna(code):\n                    # Store description\n                    self.code_descriptions[code] = row.get('Description', '')\n                    \n                    # Store category\n                    category = row.get('Category', '')\n                    if category and not pd.isna(category):\n                        if category not in self.code_categories:\n                            self.code_categories[category] = []\n                        self.code_categories[category].append(code)\n                    \n                    # Store related codes\n                    related = row.get('Related Codes', '')\n                    if related and not pd.isna(related):\n                        related_codes = [r.strip() for r in str(related).split(',')]\n                        self.related_codes[code] = related_codes\n            \n            logger.info(f\"Loaded {len(self.code_descriptions)} CPT codes\")\n        except Exception as e:\n            logger.error(f\"Error loading CPT codes: {e}\")\n            raise\n    \n    def search_codes(self, query: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Search for CPT codes based on a text query.\n        \n        Args:\n            query: Search terms for finding relevant CPT codes\n            \n        Returns:\n            List of matching CPT codes with descriptions\n        \"\"\"\n        query = query.lower()\n        results = []\n        \n        for code, description in self.code_descriptions.items():\n            if query in description.lower() or query in code:\n                results.append({\n                    \"code\": code,\n                    \"description\": description,\n                    \"related_codes\": self.related_codes.get(code, [])\n                })\n        \n        return results\n    \n    def get_code_details(self, code: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific CPT code.\n        \n        Args:\n            code: The CPT code to look up\n            \n        Returns:\n            Dictionary containing detailed information about the code\n        \"\"\"\n        if code not in self.code_descriptions:\n            return {\"error\": f\"CPT code {code} not found\"}\n        \n        return {\n            \"code\": code,\n            \"description\": self.code_descriptions.get(code, \"\"),\n            \"related_codes\": self.related_codes.get(code, [])\n        }\n    \n    def get_codes_by_category(self, category: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get all CPT codes belonging to a specific category.\n        \n        Args:\n            category: The category to look up codes for\n            \n        Returns:\n            List of CPT codes in the specified category\n        \"\"\"\n        if category not in self.code_categories:\n            return []\n        \n        results = []\n        for code in self.code_categories[category]:\n            results.append({\n                \"code\": code,\n                \"description\": self.code_descriptions.get(code, \"\"),\n                \"related_codes\": self.related_codes.get(code, [])\n            })\n        \n        return results\n    \n    def get_code_validation(self, code: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Validate if a CPT code exists and is valid.\n        \n        Args:\n            code: The CPT code to validate\n            \n        Returns:\n            Dictionary with validation results\n        \"\"\"\n        if code in self.code_descriptions:\n            return {\"valid\": True, \"description\": self.code_descriptions[code]}\n        else:\n            return {\"valid\": False, \"error\": f\"Invalid CPT code: {code}\"}\n\n\nclass ENTCPTAgent:\n    \"\"\"\n    Agent for processing ENT procedure queries and determining appropriate CPT codes.\n    \"\"\"\n    def __init__(self, config, conversation_manager=None):\n        \"\"\"\n        Initialize the ENT CPT Agent.\n        \n        Args:\n            config: AgentConfig object with configuration settings\n            conversation_manager: Optional ConversationManager instance\n        \"\"\"\n        self.config = config\n        \n        # Get configuration values\n        self.model_name = config.get(\"model\", \"name\")\n        self.model_temperature = config.get(\"model\", \"temperature\")\n        self.model_max_tokens = config.get(\"model\", \"max_tokens\")\n        self.cpt_db_path = config.get(\"cpt_database\", \"file_path\")\n        \n        # Initialize components\n        self.cpt_db = CPTCodeDatabase(self.cpt_db_path)\n        self.rules_engine = RulesEngine()\n        self.conversation_manager = conversation_manager or ConversationManager(\n            config.get(\"agent\", \"conversation_dir\")\n        )\n        \n        # Initialize LM Studio model\n        self.model = None\n        self.system_prompt = self._create_system_prompt()\n        self.initialize_model()\n    \n    def _create_system_prompt(self) -&gt; str:\n        \"\"\"\n        Create the system prompt for the agent.\n        \n        Returns:\n            System prompt string\n        \"\"\"\n        return \"\"\"\n        You are an expert ENT (Ear, Nose, Throat) medical coding assistant specialized in CPT codes. \n        Your goal is to help medical professionals find the correct CPT codes for ENT procedures.\n        \n        You have access to the following tools:\n        1. search_cpt_codes: Search for CPT codes based on a procedure description\n        2. validate_cpt_code: Validate if a CPT code exists and is correct\n        3. get_category_codes: Get all CPT codes for a specific ENT category\n        4. explain_coding_rules: Explain the rules for using a specific CPT code\n        5. analyze_procedure: Analyze a procedure description to determine appropriate CPT codes\n        \n        When recommending CPT codes:\n        - Always verify that the procedure description matches the code exactly\n        - Check for any modifiers that may be needed (e.g., bilateral procedures)\n        - Explain why you're recommending specific codes\n        - Consider bundling rules and related codes\n        - Format CPT codes clearly using the format: XXXXX (description)\n        \n        Always provide educational explanations of your reasoning process so\n        medical professionals can learn the correct coding principles.\n        \"\"\"\n    \n    def initialize_model(self) -&gt; None:\n        \"\"\"Initialize the LM Studio model.\"\"\"\n        logger.info(f\"Initializing LM Studio model: {self.model_name}\")\n        try:\n            # Configure model with parameters from config\n            self.model = lms.llm(self.model_name, config={\n                \"temperature\": self.model_temperature,\n                \"maxTokens\": self.model_max_tokens\n            })\n            logger.info(\"Model initialized successfully\")\n        except Exception as e:\n            logger.error(f\"Error initializing model: {e}\")\n            raise\n    \n    def search_cpt_codes(self, query: str) -&gt; str:\n        \"\"\"\n        Tool function: Search for CPT codes based on a procedure description.\n        \n        Args:\n            query: The procedure or keywords to search for\n            \n        Returns:\n            Formatted search results as a string\n        \"\"\"\n        results = self.cpt_db.search_codes(query)\n        if not results:\n            return f\"No CPT codes found matching '{query}'\"\n        \n        response = f\"Found {len(results)} CPT codes matching '{query}':\\n\\n\"\n        for idx, result in enumerate(results, 1):\n            response += f\"{idx}. Code {result['code']}: {result['description']}\\n\"\n            if result['related_codes']:\n                response += f\"   Related codes: {', '.join(result['related_codes'])}\\n\"\n        \n        return response\n    \n    def validate_cpt_code(self, code: str) -&gt; str:\n        \"\"\"\n        Tool function: Validate if a CPT code exists and is correct.\n        \n        Args:\n            code: The CPT code to validate\n            \n        Returns:\n            Validation result as a string\n        \"\"\"\n        result = self.cpt_db.get_code_validation(code)\n        if result[\"valid\"]:\n            return f\"CPT code {code} is valid: {result['description']}\"\n        else:\n            return result[\"error\"]\n    \n    def get_category_codes(self, category: str) -&gt; str:\n        \"\"\"\n        Tool function: Get all CPT codes for a specific ENT category.\n        \n        Args:\n            category: The ENT category to get codes for\n            \n        Returns:\n            List of codes in the category as a formatted string\n        \"\"\"\n        results = self.cpt_db.get_codes_by_category(category)\n        if not results:\n            return f\"No CPT codes found for category '{category}'\"\n        \n        response = f\"CPT codes for category '{category}':\\n\\n\"\n        for idx, result in enumerate(results, 1):\n            response += f\"{idx}. Code {result['code']}: {result['description']}\\n\"\n        \n        return response\n    \n    def explain_coding_rules(self, code: str) -&gt; str:\n        \"\"\"\n        Tool function: Explain the rules for using a specific CPT code.\n        \n        Args:\n            code: The CPT code to explain rules for\n            \n        Returns:\n            Explanation of coding rules as a string\n        \"\"\"\n        # First get the code details\n        result = self.cpt_db.get_code_details(code)\n        if \"error\" in result:\n            return result[\"error\"]\n        \n        # Basic code information\n        response = f\"Coding guidelines for CPT {code}:\\n\\n\"\n        response += f\"Description: {result['description']}\\n\\n\"\n        \n        # Get coding tips from rules engine\n        tips = self.rules_engine.get_coding_tips(code, result['description'])\n        \n        response += \"Coding guidelines:\\n\"\n        for idx, tip in enumerate(tips, 1):\n            response += f\"{idx}. {tip}\\n\"\n        \n        # Add information about related codes\n        if result['related_codes']:\n            response += f\"\\nRelated codes to consider: {', '.join(result['related_codes'])}\\n\"\n            response += \"\\nAlways check if one of these related codes may be more appropriate based on specific procedure details.\"\n        \n        return response\n    \n    def analyze_procedure(self, procedure_text: str) -&gt; str:\n        \"\"\"\n        Tool function: Analyze a procedure description to determine appropriate CPT codes.\n        \n        Args:\n            procedure_text: Description of the ENT procedure\n            \n        Returns:\n            Analysis results as a formatted string\n        \"\"\"\n        # Search for potential codes\n        search_results = self.cpt_db.search_codes(procedure_text)\n        candidate_codes = [result[\"code\"] for result in search_results]\n        \n        if not candidate_codes:\n            return f\"No potential CPT codes found for this procedure description. Please provide more details about the procedure.\"\n        \n        # Analyze with rules engine\n        analysis = self.rules_engine.analyze_procedure(\n            procedure_text, candidate_codes, self.cpt_db)\n        \n        if analysis[\"status\"] != \"success\":\n            return f\"Error analyzing procedure: {analysis.get('message', 'Unknown error')}\"\n        \n        # Format the response\n        response = f\"Analysis of procedure: {procedure_text}\\n\\n\"\n        \n        # Add recommended codes\n        response += \"Recommended CPT codes:\\n\"\n        for code in analysis[\"recommended_codes\"]:\n            # Get description for the code\n            code_info = self.cpt_db.get_code_details(code.split('-')[0])  # Handle codes with modifiers\n            description = code_info.get(\"description\", \"Unknown\") if \"error\" not in code_info else \"Unknown\"\n            response += f\"- {code}: {description}\\n\"\n        \n        # Add explanations\n        if analysis[\"explanations\"]:\n            response += \"\\nRecommendation details:\\n\"\n            for explanation in analysis[\"explanations\"]:\n                response += f\"- {explanation['message']}\\n\"\n        \n        # Add excluded codes if any\n        if analysis[\"excluded_codes\"]:\n            response += \"\\nExcluded codes (may be bundled or inappropriate):\\n\"\n            for code in analysis[\"excluded_codes\"]:\n                code_info = self.cpt_db.get_code_details(code)\n                description = code_info.get(\"description\", \"Unknown\") if \"error\" not in code_info else \"Unknown\"\n                response += f\"- {code}: {description}\\n\"\n        \n        return response\n    \n    def process_query(self, query: str, conversation=None) -&gt; str:\n        \"\"\"\n        Process a user query about ENT procedures and CPT codes.\n        \n        Args:\n            query: The user's question or procedure description\n            conversation: Optional Conversation object to use\n            \n        Returns:\n            Agent's response with CPT code recommendations\n        \"\"\"\n        logger.info(f\"Processing query: {query}\")\n        \n        # Use provided conversation or create a temporary one\n        if conversation is None:\n            chat = lms.Chat(self.system_prompt)\n            chat.add_user_message(query)\n        else:\n            # Convert existing conversation to LM Studio chat\n            chat = conversation.to_lmstudio_chat(self.system_prompt)\n        \n        # Define the tool functions\n        tools = [\n            self.search_cpt_codes,\n            self.validate_cpt_code,\n            self.get_category_codes,\n            self.explain_coding_rules,\n            self.analyze_procedure\n        ]\n        \n        # Let the model use tools to process the query\n        result = self.model.act(\n            chat,\n            tools,\n            on_message=lambda msg: conversation.add_message(\"assistant\", msg.content) if conversation else None\n        )\n        \n        return result.content\n    \n    def run_interactive_session(self) -&gt; None:\n        \"\"\"Run an interactive session where the user can ask questions about CPT codes.\"\"\"\n        print(\"\\nENT CPT Code Assistant\")\n        print(\"=\" * 50)\n        print(\"Ask questions about ENT procedures and CPT codes.\")\n        print(\"Type 'quit' or 'exit' to end the session.\")\n        print(\"Type 'new' to start a new conversation.\")\n        print(\"=\" * 50)\n        \n        # Create initial conversation\n        conversation = self.conversation_manager.create_conversation()\n        print(f\"\\nSession ID: {conversation.session_id}\\n\")\n        \n        while True:\n            query = input(\"\\nQuestion: \")\n            \n            # Handle special commands\n            if query.lower() in ['quit', 'exit']:\n                # Save conversation before exiting\n                self.conversation_manager.save_conversation(conversation)\n                print(\"Conversation saved. Goodbye!\")\n                break\n            \n            elif query.lower() == 'new':\n                # Save current conversation and create a new one\n                self.conversation_manager.save_conversation(conversation)\n                conversation = self.conversation_manager.create_conversation()\n                print(f\"\\nStarted new conversation. Session ID: {conversation.session_id}\\n\")\n                continue\n            \n            # Add user message to conversation\n            conversation.add_message(\"user\", query)\n            \n            # Process query\n            response = self.process_query(query, conversation)\n            \n            # Extract CPT codes from response\n            codes = self.conversation_manager.extract_cpt_codes(response)\n            if codes:\n                # Update the last assistant message with found codes\n                if conversation.messages and conversation.messages[-1][\"role\"] == \"assistant\":\n                    conversation.messages[-1][\"codes\"] = codes\n            \n            # Save conversation after each interaction\n            self.conversation_manager.save_conversation(conversation)\n            \n            # Display response\n            print(\"\\nResponse:\")\n            print(response)\n            \n            # Display found CPT codes separately\n            if codes:\n                print(\"\\nCPT Codes found:\")\n                for code in codes:\n                    description = \"\"\n                    code_info = self.cpt_db.get_code_details(code)\n                    if \"error\" not in code_info:\n                        description = code_info.get(\"description\", \"\")\n                    print(f\"- {code}: {description}\")\n            \n            print(\"-\" * 50)\n\n\ndef main():\n    \"\"\"Main entry point for the ENT CPT Code Agent.\"\"\"\n    parser = argparse.ArgumentParser(description=\"ENT CPT Code Agent\")\n    parser.add_argument(\n        \"--cpt_db\", \n        type=str, \n        default=\"CPT codes for ENT.xlsx\",\n        help=\"Path to the CPT code database Excel file\"\n    )\n    parser.add_argument(\n        \"--model\", \n        type=str, \n        default=\"qwen2.5-7b-instruct\",\n        help=\"Name of the LM Studio model to use\"\n    )\n    args = parser.parse_args()\n    \n    try:\n        agent = ENTCPTAgent(args.cpt_db, args.model)\n        agent.run_interactive_session()\n    except KeyboardInterrupt:\n        print(\"\\nSession terminated by user.\")\n    except Exception as e:\n        logger.error(f\"Error running ENT CPT Agent: {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n</file>\n    <file name=\"__init__.py\">\"\"\"\nAgent module for the ENT CPT Code Agent.\nContains the core agent components for CPT code assistance.\n\"\"\"\n\nfrom .ent_cpt_agent import ENTCPTAgent\nfrom .cpt_database import CPTCodeDatabase\nfrom .rules_engine import RulesEngine\n\n__all__ = ['ENTCPTAgent', 'CPTCodeDatabase', 'RulesEngine']</file>\n    <file name=\"cpt_database.py\">import pandas as pd\nimport logging\nfrom typing import List, Dict, Any\n\nlogger = logging.getLogger(\"ent_cpt_agent.cpt_database\")\n\nclass CPTCodeDatabase:\n    \"\"\"\n    Handles loading, processing, and querying of CPT codes for ENT procedures.\n    \n    The CPTCodeDatabase class is responsible for:\n    - Loading CPT code data from an Excel file\n    - Providing search functionality for codes\n    - Retrieving code details and validating codes\n    - Organizing codes by category\n    \n    This serves as the data layer for the ENT CPT Code Agent.\n    \"\"\"\n    def __init__(self, file_path: str):\n        \"\"\"\n        Initialize the CPT code database from the provided Excel file.\n        \n        Args:\n            file_path: Path to the Excel file containing CPT codes\n        \"\"\"\n        self.file_path = file_path\n        self.df = None\n        # Dictionary of code to description mappings\n        self.code_descriptions = {}\n        # Dictionary of category to list of codes mappings\n        self.code_categories = {}\n        # Dictionary of code to related codes mappings\n        self.related_codes = {}\n        self.load_data()\n    \n    def load_data(self) -&gt; None:\n        \"\"\"\n        Load CPT code data from Excel file and process it.\n        \n        This method reads the Excel file and populates the internal\n        data structures for efficient code lookup and search.\n        \"\"\"\n        logger.info(f\"Loading CPT codes from {self.file_path}\")\n        try:\n            # Load the Excel file into a pandas DataFrame\n            self.df = pd.read_excel(self.file_path)\n            \n            # Process the dataframe to create lookup dictionaries\n            for _, row in self.df.iterrows():\n                code = str(row.get('CPT Code', '')).strip()\n                if code and not pd.isna(code):\n                    # Store description\n                    self.code_descriptions[code] = row.get('Description', '')\n                    \n                    # Store category\n                    category = row.get('Category', '')\n                    if category and not pd.isna(category):\n                        if category not in self.code_categories:\n                            self.code_categories[category] = []\n                        self.code_categories[category].append(code)\n                    \n                    # Store related codes\n                    related = row.get('Related Codes', '')\n                    if related and not pd.isna(related):\n                        related_codes = [r.strip() for r in str(related).split(',')]\n                        self.related_codes[code] = related_codes\n            \n            logger.info(f\"Loaded {len(self.code_descriptions)} CPT codes\")\n        except Exception as e:\n            logger.error(f\"Error loading CPT codes: {e}\")\n            raise\n    \n    def search_codes(self, query: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Search for CPT codes based on a text query.\n        \n        This method searches for codes whose descriptions or code numbers\n        contain the search query.\n        \n        Args:\n            query: Search terms for finding relevant CPT codes\n            \n        Returns:\n            List of matching CPT codes with descriptions\n        \"\"\"\n        query = query.lower()\n        results = []\n        \n        # Search in both code numbers and descriptions\n        for code, description in self.code_descriptions.items():\n            if query in description.lower() or query in code:\n                results.append({\n                    \"code\": code,\n                    \"description\": description,\n                    \"related_codes\": self.related_codes.get(code, [])\n                })\n        \n        return results\n    \n    def get_code_details(self, code: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific CPT code.\n        \n        This method retrieves all available information about a\n        specific CPT code, including its description and related codes.\n        \n        Args:\n            code: The CPT code to look up\n            \n        Returns:\n            Dictionary containing detailed information about the code\n        \"\"\"\n        if code not in self.code_descriptions:\n            return {\"error\": f\"CPT code {code} not found\"}\n        \n        return {\n            \"code\": code,\n            \"description\": self.code_descriptions.get(code, \"\"),\n            \"related_codes\": self.related_codes.get(code, [])\n        }\n    \n    def get_codes_by_category(self, category: str) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get all CPT codes belonging to a specific category.\n        \n        This method retrieves all codes that are classified under\n        a particular category (e.g., \"Ear\", \"Nose\", \"Throat\").\n        \n        Args:\n            category: The category to look up codes for\n            \n        Returns:\n            List of CPT codes in the specified category\n        \"\"\"\n        if category not in self.code_categories:\n            return []\n        \n        results = []\n        for code in self.code_categories[category]:\n            results.append({\n                \"code\": code,\n                \"description\": self.code_descriptions.get(code, \"\"),\n                \"related_codes\": self.related_codes.get(code, [])\n            })\n        \n        return results\n    \n    def get_code_validation(self, code: str) -&gt; Dict[str, Any]:\n        \"\"\"\n        Validate if a CPT code exists and is valid.\n        \n        This method checks if a given CPT code exists in the database\n        and returns its validation status.\n        \n        Args:\n            code: The CPT code to validate\n            \n        Returns:\n            Dictionary with validation results\n        \"\"\"\n        if code in self.code_descriptions:\n            return {\"valid\": True, \"description\": self.code_descriptions[code]}\n        else:\n            return {\"valid\": False, \"error\": f\"Invalid CPT code: {code}\"}</file>\n    <file name=\"rules_engine.py\">from typing import List, Dict, Any, Optional, Tuple\nimport re\nimport logging\nfrom dataclasses import dataclass\n\nlogger = logging.getLogger(\"ent_cpt_agent.rules_engine\")\n\n@dataclass\nclass CodeRule:\n    \"\"\"Represents a rule for CPT code selection.\"\"\"\n    rule_id: str\n    description: str\n    conditions: List[Dict[str, Any]]\n    priority: int = 0\n    \n    def __str__(self) -&gt; str:\n        return f\"Rule {self.rule_id}: {self.description} (Priority: {self.priority})\"\n\n\nclass RulesEngine:\n    \"\"\"\n    Implements a rules engine for CPT code selection based on medical coding guidelines.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the rules engine with ENT-specific CPT coding rules.\"\"\"\n        self.rules = []\n        self.initialize_rules()\n    \n    def initialize_rules(self) -&gt; None:\n        \"\"\"Load default rules for ENT CPT coding.\"\"\"\n        # Rule: Bundled procedures\n        self.rules.append(CodeRule(\n            rule_id=\"R001\",\n            description=\"Check for bundled procedures\",\n            conditions=[\n                {\"type\": \"bundled_codes\", \"codes\": []}\n            ],\n            priority=10\n        ))\n        \n        # Rule: Bilateral procedures\n        self.rules.append(CodeRule(\n            rule_id=\"R002\",\n            description=\"Check for bilateral procedures (use modifier 50)\",\n            conditions=[\n                {\"type\": \"procedure_bilateral\", \"keywords\": [\"bilateral\", \"both sides\", \"both ears\"]}\n            ],\n            priority=8\n        ))\n        \n        # Rule: Follow-up visits\n        self.rules.append(CodeRule(\n            rule_id=\"R003\",\n            description=\"Check for post-operative visits (usually included in surgical package)\",\n            conditions=[\n                {\"type\": \"post_op\", \"keywords\": [\"follow-up\", \"post-op\", \"postoperative\"]}\n            ],\n            priority=9\n        ))\n        \n        # Rule: Check for multiple procedures\n        self.rules.append(CodeRule(\n            rule_id=\"R004\",\n            description=\"Check for multiple procedures (additional procedures may require modifier 51)\",\n            conditions=[\n                {\"type\": \"multiple_procedures\", \"patterns\": [\n                    r\"\\bmultiple\\s+procedures\\b\",\n                    r\"\\bseveral\\s+procedures\\b\"\n                ]}\n            ],\n            priority=7\n        ))\n        \n        # Rule: Check for medical necessity\n        self.rules.append(CodeRule(\n            rule_id=\"R005\",\n            description=\"Verify medical necessity documentation\",\n            conditions=[\n                {\"type\": \"medical_necessity\", \"required\": True}\n            ],\n            priority=6\n        ))\n        \n        logger.info(f\"Initialized {len(self.rules)} CPT coding rules\")\n    \n    def add_rule(self, rule: CodeRule) -&gt; None:\n        \"\"\"\n        Add a new rule to the engine.\n        \n        Args:\n            rule: The rule to add\n        \"\"\"\n        self.rules.append(rule)\n        # Sort rules by priority (higher priority first)\n        self.rules.sort(key=lambda r: r.priority, reverse=True)\n        logger.info(f\"Added rule: {rule}\")\n    \n    def evaluate_bundled_codes(self, procedure_text: str, candidate_codes: List[str], \n                               code_db) -&gt; Tuple[List[str], List[str], List[Dict[str, Any]]]:\n        \"\"\"\n        Check for bundled procedure codes.\n        \n        Args:\n            procedure_text: Description of the procedure\n            candidate_codes: List of potential CPT codes\n            code_db: Database of CPT codes\n            \n        Returns:\n            Tuple of (recommended_codes, excluded_codes, explanations)\n        \"\"\"\n        recommended = []\n        excluded = []\n        explanations = []\n        \n        # Check each candidate code\n        for code in candidate_codes:\n            details = code_db.get_code_details(code)\n            \n            # Skip if code not found\n            if \"error\" in details:\n                continue\n            \n            # Check related codes for potential bundling\n            related_codes = details.get(\"related_codes\", [])\n            bundled_with = []\n            \n            for related in related_codes:\n                if related in candidate_codes:\n                    bundled_with.append(related)\n            \n            if bundled_with:\n                # This code might be bundled with others\n                # In a real implementation, we would check a bundling database\n                explanations.append({\n                    \"rule_id\": \"R001\",\n                    \"code\": code,\n                    \"message\": f\"Code {code} may be bundled with {', '.join(bundled_with)}. \"\n                               f\"Check coding guidelines to determine which code to use.\"\n                })\n                \n                # For demonstration, we'll add the main code and exclude related codes\n                # (This logic should be updated based on actual bundling rules)\n                if code not in excluded:\n                    recommended.append(code)\n                    excluded.extend(bundled_with)\n            elif code not in excluded:\n                recommended.append(code)\n        \n        return recommended, excluded, explanations\n    \n    def evaluate_bilateral_procedures(self, procedure_text: str, candidate_codes: List[str],\n                                     code_db) -&gt; Tuple[List[str], List[Dict[str, Any]]]:\n        \"\"\"\n        Check for bilateral procedures that require modifier 50.\n        \n        Args:\n            procedure_text: Description of the procedure\n            candidate_codes: List of potential CPT codes\n            code_db: Database of CPT codes\n            \n        Returns:\n            Tuple of (modified_codes, explanations)\n        \"\"\"\n        modified_codes = []\n        explanations = []\n        \n        # Check if the procedure description indicates a bilateral procedure\n        bilateral_keywords = [\"bilateral\", \"both sides\", \"both ears\", \"right and left\"]\n        is_bilateral = any(keyword in procedure_text.lower() for keyword in bilateral_keywords)\n        \n        if is_bilateral:\n            for code in candidate_codes:\n                # In a real implementation, we would check if the code is eligible for modifier 50\n                modified_codes.append(f\"{code}-50\")\n                explanations.append({\n                    \"rule_id\": \"R002\",\n                    \"code\": code,\n                    \"message\": f\"Added modifier 50 to code {code} for bilateral procedure.\"\n                })\n        else:\n            modified_codes = candidate_codes\n        \n        return modified_codes, explanations\n    \n    def analyze_procedure(self, procedure_text: str, candidate_codes: List[str], \n                         code_db) -&gt; Dict[str, Any]:\n        \"\"\"\n        Analyze a procedure description and apply coding rules to suggest the\n        most appropriate CPT codes.\n        \n        Args:\n            procedure_text: Description of the procedure\n            candidate_codes: List of potential CPT codes\n            code_db: Database of CPT codes\n            \n        Returns:\n            Dictionary with analysis results and recommendations\n        \"\"\"\n        logger.info(f\"Analyzing procedure: {procedure_text}\")\n        logger.info(f\"Candidate codes: {candidate_codes}\")\n        \n        if not candidate_codes:\n            return {\n                \"status\": \"error\",\n                \"message\": \"No candidate codes provided for analysis\",\n                \"recommended_codes\": []\n            }\n        \n        recommended_codes = candidate_codes.copy()\n        excluded_codes = []\n        explanations = []\n        modifiers = {}\n        \n        # Apply each rule in priority order\n        for rule in self.rules:\n            logger.info(f\"Applying rule: {rule}\")\n            \n            try:\n                if rule.rule_id == \"R001\":  # Bundled procedures\n                    rec, exc, exp = self.evaluate_bundled_codes(\n                        procedure_text, recommended_codes, code_db)\n                    recommended_codes = rec\n                    excluded_codes.extend(exc)\n                    explanations.extend(exp)\n                \n                elif rule.rule_id == \"R002\":  # Bilateral procedures\n                    rec, exp = self.evaluate_bilateral_procedures(\n                        procedure_text, recommended_codes, code_db)\n                    recommended_codes = rec\n                    explanations.extend(exp)\n                \n                # Additional rule implementations would go here\n                \n            except Exception as e:\n                logger.error(f\"Error applying rule {rule.rule_id}: {e}\")\n        \n        # Prepare the result\n        result = {\n            \"status\": \"success\",\n            \"procedure_text\": procedure_text,\n            \"recommended_codes\": recommended_codes,\n            \"excluded_codes\": excluded_codes,\n            \"explanations\": explanations\n        }\n        \n        logger.info(f\"Analysis complete. Recommended codes: {recommended_codes}\")\n        return result\n    \n    def get_rule_explanations(self) -&gt; Dict[str, str]:\n        \"\"\"\n        Get explanations for all rules.\n        \n        Returns:\n            Dictionary mapping rule IDs to descriptions\n        \"\"\"\n        return {rule.rule_id: rule.description for rule in self.rules}\n    \n    def get_coding_tips(self, code: str, procedure_text: str) -&gt; List[str]:\n        \"\"\"\n        Get coding tips for a specific CPT code based on the procedure description.\n        \n        Args:\n            code: CPT code to get tips for\n            procedure_text: Description of the procedure\n            \n        Returns:\n            List of coding tips\n        \"\"\"\n        tips = []\n        \n        # General tips\n        tips.append(\"Ensure the documentation supports medical necessity.\")\n        tips.append(\"Check that the procedure description matches the code definition exactly.\")\n        \n        # Specific tips based on procedure text\n        if \"consultation\" in procedure_text.lower():\n            tips.append(\"Initial consultations may require different codes than follow-up visits.\")\n        \n        if \"biopsy\" in procedure_text.lower():\n            tips.append(\"Verify if the biopsy was for diagnostic or therapeutic purposes.\")\n        \n        if \"endoscopic\" in procedure_text.lower():\n            tips.append(\"Endoscopic procedures often have specific bundling rules.\")\n        \n        return tips</file>\n  </folder>\n  <folder name=\"src/api\">\n    <file name=\"__init__.py\" />\n    <file name=\"api_interface.py\">from fastapi import FastAPI, HTTPException, Depends, Query, Body\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import List, Dict, Any, Optional\nimport uvicorn\nimport logging\nimport os\nfrom pydantic import BaseModel, Field\nimport json\n\n# Import our agent components\n# Note: These would be actual imports in a real implementation\n# from agent_config import AgentConfig\n# from cpt_database import CPTCodeDatabase\n# from rules_engine import RulesEngine\n# from conversation_manager import ConversationManager, Conversation\n# from ent_cpt_agent import ENTCPTAgent\n\nlogger = logging.getLogger(\"ent_cpt_agent.api\")\n\n# Pydantic models for request/response validation\nclass QueryRequest(BaseModel):\n    \"\"\"Request model for querying the agent.\"\"\"\n    query: str = Field(..., description=\"The query about ENT procedures or CPT codes\")\n    session_id: Optional[str] = Field(None, description=\"Session ID for conversation continuity\")\n\nclass CodeSearchRequest(BaseModel):\n    \"\"\"Request model for searching CPT codes.\"\"\"\n    search_term: str = Field(..., description=\"Term to search for in CPT code descriptions\")\n\nclass CodeValidationRequest(BaseModel):\n    \"\"\"Request model for validating CPT codes.\"\"\"\n    code: str = Field(..., description=\"CPT code to validate\")\n\nclass ProcedureAnalysisRequest(BaseModel):\n    \"\"\"Request model for analyzing a procedure description.\"\"\"\n    procedure_text: str = Field(..., description=\"Description of the ENT procedure\")\n    candidate_codes: Optional[List[str]] = Field(None, description=\"Optional list of candidate CPT codes\")\n\nclass AgentResponse(BaseModel):\n    \"\"\"Generic response model for agent API.\"\"\"\n    status: str = Field(..., description=\"Status of the request (success/error)\")\n    message: Optional[str] = Field(None, description=\"Response message or error details\")\n    data: Optional[Dict[str, Any]] = Field(None, description=\"Response data\")\n    session_id: Optional[str] = Field(None, description=\"Session ID for conversation continuity\")\n\nclass APIInterface:\n    \"\"\"API interface for the ENT CPT Code Agent.\"\"\"\n    \n    def __init__(self, agent, config, host=\"localhost\", port=8000):\n        \"\"\"\n        Initialize the API interface.\n        \n        Args:\n            agent: Instance of ENTCPTAgent\n            config: Instance of AgentConfig\n            host: Host to run the API server on\n            port: Port to run the API server on\n        \"\"\"\n        self.agent = agent\n        self.config = config\n        self.host = host\n        self.port = port\n        self.app = FastAPI(\n            title=\"ENT CPT Code Agent API\",\n            description=\"API for querying ENT CPT codes and analyzing medical procedures\",\n            version=\"1.0.0\"\n        )\n        \n        # Add CORS middleware\n        self.app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],  # In production, restrict this to specific origins\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n        \n        # Register routes\n        self.register_routes()\n    \n    def register_routes(self):\n        \"\"\"Register API routes.\"\"\"\n        \n        @self.app.get(\"/\", tags=[\"General\"])\n        async def root():\n            \"\"\"Root endpoint providing API information.\"\"\"\n            return {\n                \"name\": \"ENT CPT Code Agent API\",\n                \"version\": \"1.0.0\",\n                \"status\": \"running\"\n            }\n        \n        @self.app.post(\"/api/query\", response_model=AgentResponse, tags=[\"Agent\"])\n        async def query_agent(request: QueryRequest):\n            \"\"\"\n            Submit a query to the ENT CPT Code Agent.\n            \n            This endpoint processes natural language queries about ENT procedures\n            and CPT codes, using the agent to determine the most appropriate response.\n            \"\"\"\n            try:\n                # Get or create session\n                session_id = request.session_id\n                conversation_manager = self.agent.conversation_manager\n                \n                if session_id and conversation_manager.get_conversation(session_id):\n                    conversation = conversation_manager.get_conversation(session_id)\n                else:\n                    conversation = conversation_manager.create_conversation()\n                    session_id = conversation.session_id\n                \n                # Add user message to conversation\n                conversation.add_message(\"user\", request.query)\n                \n                # Process the query\n                response = self.agent.process_query(request.query, conversation)\n                \n                # Extract CPT codes from response\n                codes = conversation_manager.extract_cpt_codes(response)\n                \n                # Add assistant message to conversation\n                conversation.add_message(\"assistant\", response, codes)\n                \n                # Save conversation\n                conversation_manager.save_conversation(conversation)\n                \n                return {\n                    \"status\": \"success\",\n                    \"message\": response,\n                    \"data\": {\n                        \"codes\": codes\n                    },\n                    \"session_id\": session_id\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error processing query: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.post(\"/api/search\", response_model=AgentResponse, tags=[\"CPT Codes\"])\n        async def search_codes(request: CodeSearchRequest):\n            \"\"\"\n            Search for CPT codes by description or keywords.\n            \n            This endpoint searches the CPT code database for codes matching\n            the provided search term in their description.\n            \"\"\"\n            try:\n                results = self.agent.cpt_db.search_codes(request.search_term)\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": {\n                        \"codes\": results,\n                        \"count\": len(results)\n                    }\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error searching codes: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.post(\"/api/validate\", response_model=AgentResponse, tags=[\"CPT Codes\"])\n        async def validate_code(request: CodeValidationRequest):\n            \"\"\"\n            Validate a CPT code.\n            \n            This endpoint checks if a CPT code exists and is valid according\n            to the CPT code database.\n            \"\"\"\n            try:\n                result = self.agent.cpt_db.get_code_validation(request.code)\n                \n                return {\n                    \"status\": \"success\" if result.get(\"valid\", False) else \"error\",\n                    \"message\": result.get(\"description\") if result.get(\"valid\", False) else result.get(\"error\"),\n                    \"data\": result\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error validating code: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.post(\"/api/analyze\", response_model=AgentResponse, tags=[\"Analysis\"])\n        async def analyze_procedure(request: ProcedureAnalysisRequest):\n            \"\"\"\n            Analyze an ENT procedure description to determine appropriate CPT codes.\n            \n            This endpoint uses the rules engine to analyze a procedure description\n            and suggest appropriate CPT codes based on coding guidelines.\n            \"\"\"\n            try:\n                # If candidate codes weren't provided, search for them\n                candidate_codes = request.candidate_codes\n                if not candidate_codes:\n                    search_results = self.agent.cpt_db.search_codes(request.procedure_text)\n                    candidate_codes = [result[\"code\"] for result in search_results]\n                \n                # Analyze the procedure using the rules engine\n                analysis = self.agent.rules_engine.analyze_procedure(\n                    request.procedure_text, candidate_codes, self.agent.cpt_db)\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": analysis\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error analyzing procedure: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.get(\"/api/conversations\", response_model=AgentResponse, tags=[\"Conversations\"])\n        async def list_conversations():\n            \"\"\"\n            List all saved conversations.\n            \n            This endpoint returns a list of all saved conversations with their metadata.\n            \"\"\"\n            try:\n                conversations = self.agent.conversation_manager.list_conversations()\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": {\n                        \"conversations\": conversations,\n                        \"count\": len(conversations)\n                    }\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error listing conversations: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.get(\"/api/conversations/{session_id}\", response_model=AgentResponse, tags=[\"Conversations\"])\n        async def get_conversation(session_id: str):\n            \"\"\"\n            Get a specific conversation by session ID.\n            \n            This endpoint returns the details of a specific conversation.\n            \"\"\"\n            try:\n                conversation = self.agent.conversation_manager.get_conversation(session_id)\n                \n                if not conversation:\n                    raise HTTPException(status_code=404, detail=f\"Conversation {session_id} not found\")\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": conversation.to_dict(),\n                    \"session_id\": session_id\n                }\n            \n            except HTTPException:\n                raise\n            except Exception as e:\n                logger.error(f\"Error getting conversation: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.delete(\"/api/conversations/{session_id}\", response_model=AgentResponse, tags=[\"Conversations\"])\n        async def delete_conversation(session_id: str):\n            \"\"\"\n            Delete a specific conversation by session ID.\n            \n            This endpoint deletes a specific conversation and its associated data.\n            \"\"\"\n            try:\n                result = self.agent.conversation_manager.delete_conversation(session_id)\n                \n                if not result:\n                    raise HTTPException(status_code=404, detail=f\"Conversation {session_id} not found\")\n                \n                return {\n                    \"status\": \"success\",\n                    \"message\": f\"Conversation {session_id} deleted successfully\"\n                }\n            \n            except HTTPException:\n                raise\n            except Exception as e:\n                logger.error(f\"Error deleting conversation: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n    \n    def start(self):\n        \"\"\"Start the API server.\"\"\"\n        logger.info(f\"Starting API server on {self.host}:{self.port}\")\n        uvicorn.run(self.app, host=self.host, port=self.port)\n    \n    def get_app(self):\n        \"\"\"Get the FastAPI application instance.\"\"\"\n        return self.app</file>\n  </folder>\n  <folder name=\"src/conversation\">\n    <file name=\"__init__.py\">\"\"\"\nConversation management module for the ENT CPT Code Agent.\nHandles conversation sessions, persistence, and history.\n\"\"\"\n\nfrom .conversation_manager import ConversationManager, Conversation\n\n__all__ = ['ConversationManager', 'Conversation']</file>\n    <file name=\"conversation_manager.py\">import json\nimport os\nimport datetime\nimport uuid\nimport re  # Added missing import for regex pattern matching\nfrom typing import List, Dict, Any, Optional\nimport logging\nimport lmstudio as lms\n\nlogger = logging.getLogger(\"ent_cpt_agent.conversation\")\n\nclass Conversation:\n    \"\"\"\n    Represents a conversation session with the ENT CPT Code Agent.\n    \n    This class handles individual conversations between the user and agent,\n    including message history, metadata, and serialization/deserialization.\n    \"\"\"\n    def __init__(self, session_id: Optional[str] = None):\n        \"\"\"\n        Initialize a new conversation.\n        \n        Args:\n            session_id: Optional session ID (generates a new one if not provided)\n        \"\"\"\n        self.session_id = session_id or str(uuid.uuid4())\n        self.start_time = datetime.datetime.now()\n        self.messages = []\n        self.metadata = {\n            \"session_id\": self.session_id,\n            \"start_time\": self.start_time.isoformat(),\n            \"total_messages\": 0,\n            \"total_codes_identified\": 0\n        }\n    \n    def add_message(self, role: str, content: str, codes: List[str] = None) -&gt; None:\n        \"\"\"\n        Add a message to the conversation.\n        \n        Args:\n            role: Message role (user, assistant, system)\n            content: Message content\n            codes: List of CPT codes mentioned in the message (optional)\n        \"\"\"\n        message = {\n            \"role\": role,\n            \"content\": content,\n            \"timestamp\": datetime.datetime.now().isoformat()\n        }\n        \n        if codes:\n            message[\"codes\"] = codes\n            self.metadata[\"total_codes_identified\"] += len(codes)\n        \n        self.messages.append(message)\n        self.metadata[\"total_messages\"] = len(self.messages)\n    \n    def to_lmstudio_chat(self, system_prompt: str) -&gt; lms.Chat:\n        \"\"\"\n        Convert the conversation to an LM Studio Chat object.\n        \n        This method transforms our internal conversation representation\n        to the format expected by LM Studio's API.\n        \n        Args:\n            system_prompt: System prompt to use for the chat\n            \n        Returns:\n            LM Studio Chat object representing this conversation\n        \"\"\"\n        chat = lms.Chat(system_prompt)\n        \n        for message in self.messages:\n            if message[\"role\"] == \"user\":\n                chat.add_user_message(message[\"content\"])\n            elif message[\"role\"] == \"assistant\":\n                chat.add_assistant_message(message[\"content\"])\n            # System messages are handled by the initial system prompt\n        \n        return chat\n    \n    def to_dict(self) -&gt; Dict[str, Any]:\n        \"\"\"\n        Convert the conversation to a dictionary.\n        \n        Returns:\n            Dictionary representation of the conversation\n        \"\"\"\n        return {\n            \"session_id\": self.session_id,\n            \"metadata\": self.metadata,\n            \"messages\": self.messages\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -&gt; 'Conversation':\n        \"\"\"\n        Create a conversation from a dictionary.\n        \n        This factory method reconstructs a Conversation object\n        from a previously serialized dictionary representation.\n        \n        Args:\n            data: Dictionary representation of a conversation\n            \n        Returns:\n            Conversation object\n        \"\"\"\n        conversation = cls(session_id=data.get(\"session_id\"))\n        conversation.metadata = data.get(\"metadata\", {})\n        conversation.messages = data.get(\"messages\", [])\n        \n        # Parse start_time from metadata if available\n        start_time_str = conversation.metadata.get(\"start_time\")\n        if start_time_str:\n            try:\n                conversation.start_time = datetime.datetime.fromisoformat(start_time_str)\n            except (ValueError, TypeError):\n                logger.warning(f\"Could not parse start_time: {start_time_str}\")\n        \n        return conversation\n\n\nclass ConversationManager:\n    \"\"\"\n    Manages multiple conversations, including loading/saving to disk.\n    \n    This class handles the lifecycle of conversations, including:\n    - Creating new conversations\n    - Loading existing conversations from disk\n    - Saving conversations to disk\n    - Listing available conversations\n    - Extracting CPT codes from conversation text\n    \"\"\"\n    def __init__(self, conversation_dir: str = \"conversations\"):\n        \"\"\"\n        Initialize the conversation manager.\n        \n        Args:\n            conversation_dir: Directory to store conversation files\n        \"\"\"\n        self.conversation_dir = conversation_dir\n        self.current_conversation = None\n        self.conversations = {}\n        \n        # Create conversation directory if it doesn't exist\n        os.makedirs(self.conversation_dir, exist_ok=True)\n        \n        # Load existing conversations\n        self.load_conversations()\n    \n    def load_conversations(self) -&gt; None:\n        \"\"\"\n        Load all saved conversations from the conversation directory.\n        \n        This method scans the conversation directory for JSON files,\n        loads them, and reconstructs Conversation objects.\n        \"\"\"\n        if not os.path.exists(self.conversation_dir):\n            logger.warning(f\"Conversation directory not found: {self.conversation_dir}\")\n            return\n        \n        try:\n            for filename in os.listdir(self.conversation_dir):\n                if not filename.endswith('.json'):\n                    continue\n                \n                file_path = os.path.join(self.conversation_dir, filename)\n                \n                with open(file_path, 'r') as f:\n                    data = json.load(f)\n                \n                conversation = Conversation.from_dict(data)\n                self.conversations[conversation.session_id] = conversation\n                \n            logger.info(f\"Loaded {len(self.conversations)} conversations\")\n        except Exception as e:\n            logger.error(f\"Error loading conversations: {e}\")\n    \n    def save_conversation(self, conversation: Conversation) -&gt; None:\n        \"\"\"\n        Save a conversation to disk.\n        \n        Args:\n            conversation: Conversation to save\n        \"\"\"\n        if not conversation:\n            logger.error(\"Cannot save empty conversation\")\n            return\n        \n        file_path = os.path.join(self.conversation_dir, f\"{conversation.session_id}.json\")\n        \n        try:\n            with open(file_path, 'w') as f:\n                json.dump(conversation.to_dict(), f, indent=2)\n            \n            logger.info(f\"Saved conversation {conversation.session_id}\")\n        except Exception as e:\n            logger.error(f\"Error saving conversation: {e}\")\n    \n    def create_conversation(self) -&gt; Conversation:\n        \"\"\"\n        Create a new conversation.\n        \n        Returns:\n            Newly created conversation\n        \"\"\"\n        conversation = Conversation()\n        self.conversations[conversation.session_id] = conversation\n        self.current_conversation = conversation\n        return conversation\n    \n    def get_conversation(self, session_id: str) -&gt; Optional[Conversation]:\n        \"\"\"\n        Get a conversation by session ID.\n        \n        Args:\n            session_id: Session ID of the conversation to retrieve\n            \n        Returns:\n            Conversation object or None if not found\n        \"\"\"\n        return self.conversations.get(session_id)\n    \n    def list_conversations(self) -&gt; List[Dict[str, Any]]:\n        \"\"\"\n        Get a list of all conversations with their metadata.\n        \n        Returns:\n            List of conversation metadata dictionaries\n        \"\"\"\n        result = []\n        for session_id, conversation in self.conversations.items():\n            result.append({\n                \"session_id\": session_id,\n                \"start_time\": conversation.metadata.get(\"start_time\"),\n                \"total_messages\": conversation.metadata.get(\"total_messages\", 0),\n                \"total_codes_identified\": conversation.metadata.get(\"total_codes_identified\", 0)\n            })\n        \n        # Sort by start time (newest first)\n        result.sort(key=lambda x: x.get(\"start_time\", \"\"), reverse=True)\n        \n        return result\n    \n    def delete_conversation(self, session_id: str) -&gt; bool:\n        \"\"\"\n        Delete a conversation.\n        \n        Args:\n            session_id: Session ID of the conversation to delete\n            \n        Returns:\n            True if deleted successfully, False otherwise\n        \"\"\"\n        if session_id not in self.conversations:\n            logger.warning(f\"Conversation not found: {session_id}\")\n            return False\n        \n        # Remove from memory\n        del self.conversations[session_id]\n        \n        # Remove from disk\n        file_path = os.path.join(self.conversation_dir, f\"{session_id}.json\")\n        if os.path.exists(file_path):\n            try:\n                os.remove(file_path)\n                logger.info(f\"Deleted conversation file: {file_path}\")\n            except Exception as e:\n                logger.error(f\"Error deleting conversation file: {e}\")\n                return False\n        \n        # Reset current conversation if it was deleted\n        if self.current_conversation and self.current_conversation.session_id == session_id:\n            self.current_conversation = None\n        \n        return True\n    \n    def extract_cpt_codes(self, text: str) -&gt; List[str]:\n        \"\"\"\n        Extract CPT codes from text using regex pattern matching.\n        \n        This method identifies potential CPT codes in text by looking\n        for 5-digit numbers that may be followed by modifiers.\n        \n        Args:\n            text: Text to extract CPT codes from\n            \n        Returns:\n            List of extracted CPT codes\n        \"\"\"\n        # CPT codes are typically 5 digits or 5 digits followed by F or T or a two-digit modifier\n        pattern = r'\\b\\d{5}(?:[FT]|\\d{2})?\\b'\n        matches = re.findall(pattern, text)\n        return matches</file>\n  </folder>\n</directory>"
                }
            ]
        },
        {
            "name": "tests",
            "files": [
                {
                    "name": "test_rules_engine.py",
                    "content": "import os\nimport sys\nimport unittest\nfrom unittest.mock import Mock, MagicMock\nimport logging\n\n# Add the src directory to the path so we can import our modules\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Import the classes to test\nfrom src.agent.rules_engine import RulesEngine, CodeRule\n\n# Disable logging output during tests\nlogging.disable(logging.CRITICAL)\n\nclass TestRulesEngine(unittest.TestCase):\n    \"\"\"\n    Unit tests for the RulesEngine class.\n    \n    These tests validate the rule application logic and code recommendations.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        # Create a RulesEngine instance\n        self.rules_engine = RulesEngine()\n        \n        # Create a mock CPT database\n        self.mock_cpt_db = MagicMock()\n        \n        # Set up mock code details responses\n        self.mock_cpt_db.get_code_details.side_effect = self._mock_get_code_details\n    \n    def _mock_get_code_details(self, code):\n        \"\"\"Mock implementation of get_code_details.\"\"\"\n        # Define some test code details\n        code_details = {\n            '31231': {\n                'code': '31231',\n                'description': 'Nasal endoscopy, diagnostic',\n                'related_codes': ['31233', '31235']\n            },\n            '31233': {\n                'code': '31233',\n                'description': 'Nasal endoscopy with biopsy',\n                'related_codes': ['31231']\n            },\n            '69436': {\n                'code': '69436',\n                'description': 'Tympanostomy with tubes, bilateral',\n                'related_codes': ['69433']\n            },\n            '30520': {\n                'code': '30520',\n                'description': 'Septoplasty',\n                'related_codes': ['30930']\n            }\n        }\n        \n        if code in code_details:\n            return code_details[code]\n        else:\n            return {\"error\": f\"CPT code {code} not found\"}\n    \n    def test_initialize_rules(self):\n        \"\"\"Test that default rules are properly initialized.\"\"\"\n        # Check that rules were loaded\n        self.assertGreater(len(self.rules_engine.rules), 0)\n        \n        # Check that rules are sorted by priority\n        priorities = [rule.priority for rule in self.rules_engine.rules]\n        self.assertEqual(priorities, sorted(priorities, reverse=True))\n        \n        # Check that specific rules exist\n        rule_ids = [rule.rule_id for rule in self.rules_engine.rules]\n        self.assertIn(\"R001\", rule_ids)  # Bundled procedures\n        self.assertIn(\"R002\", rule_ids)  # Bilateral procedures\n    \n    def test_add_rule(self):\n        \"\"\"Test adding a custom rule.\"\"\"\n        # Initial rule count\n        initial_count = len(self.rules_engine.rules)\n        \n        # Add a new rule\n        new_rule = CodeRule(\n            rule_id=\"TEST001\",\n            description=\"Test rule\",\n            conditions=[{\"type\": \"test\"}],\n            priority=100\n        )\n        self.rules_engine.add_rule(new_rule)\n        \n        # Check rule was added\n        self.assertEqual(len(self.rules_engine.rules), initial_count + 1)\n        \n        # Check rule is first (highest priority)\n        self.assertEqual(self.rules_engine.rules[0].rule_id, \"TEST001\")\n    \n    def test_evaluate_bundled_codes(self):\n        \"\"\"Test evaluation of bundled codes.\"\"\"\n        # Test case: two potentially bundled codes\n        candidate_codes = ['31231', '31233']\n        procedure_text = \"Diagnostic nasal endoscopy with biopsy\"\n        \n        recommended, excluded, explanations = self.rules_engine.evaluate_bundled_codes(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Either 31231 or 31233 should be recommended, and the other excluded\n        self.assertEqual(len(recommended), 1)\n        self.assertEqual(len(excluded), 1)\n        self.assertEqual(len(explanations), 1)\n        \n        # Check that related code is properly identified\n        self.assertIn(explanations[0][\"rule_id\"], \"R001\")\n    \n    def test_evaluate_bilateral_procedures(self):\n        \"\"\"Test evaluation of bilateral procedures.\"\"\"\n        # Test case: bilateral procedure\n        candidate_codes = ['30520']\n        procedure_text = \"Bilateral septoplasty\"\n        \n        modified_codes, explanations = self.rules_engine.evaluate_bilateral_procedures(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Should add modifier 50 to the code\n        self.assertEqual(len(modified_codes), 1)\n        self.assertEqual(modified_codes[0], \"30520-50\")\n        self.assertEqual(len(explanations), 1)\n        \n        # Test case: non-bilateral procedure\n        candidate_codes = ['30520']\n        procedure_text = \"Septoplasty\"\n        \n        modified_codes, explanations = self.rules_engine.evaluate_bilateral_procedures(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Should not modify the code\n        self.assertEqual(len(modified_codes), 1)\n        self.assertEqual(modified_codes[0], \"30520\")\n        self.assertEqual(len(explanations), 0)\n    \n    def test_analyze_procedure(self):\n        \"\"\"Test the main analyze_procedure method.\"\"\"\n        # Test case: bilateral procedure with potential bundling\n        procedure_text = \"Bilateral nasal endoscopy with biopsy\"\n        candidate_codes = ['31231', '31233']\n        \n        result = self.rules_engine.analyze_procedure(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Check overall result structure\n        self.assertEqual(result[\"status\"], \"success\")\n        self.assertEqual(result[\"procedure_text\"], procedure_text)\n        self.assertIn(\"recommended_codes\", result)\n        self.assertIn(\"excluded_codes\", result)\n        self.assertIn(\"explanations\", result)\n        \n        # Check that at least one recommended code has modifier 50\n        has_bilateral_code = any(\"-50\" in code for code in result[\"recommended_codes\"])\n        self.assertTrue(has_bilateral_code)\n    \n    def test_analyze_procedure_no_candidates(self):\n        \"\"\"Test analyze_procedure with no candidate codes.\"\"\"\n        procedure_text = \"Some procedure description\"\n        candidate_codes = []\n        \n        result = self.rules_engine.analyze_procedure(\n            procedure_text, candidate_codes, self.mock_cpt_db\n        )\n        \n        # Should return an error\n        self.assertEqual(result[\"status\"], \"error\")\n        self.assertIn(\"message\", result)\n        self.assertEqual(result[\"recommended_codes\"], [])\n    \n    def test_get_coding_tips(self):\n        \"\"\"Test retrieving coding tips for a code.\"\"\"\n        # Test case: endoscopic procedure\n        tips = self.rules_engine.get_coding_tips(\n            '31231', 'Nasal endoscopy, diagnostic, endoscopic procedure'\n        )\n        \n        # Should return a list of tips\n        self.assertIsInstance(tips, list)\n        self.assertGreater(len(tips), 0)\n        \n        # Should include endoscopy-specific tips\n        has_endoscopy_tip = any(\"endoscopic\" in tip.lower() for tip in tips)\n        self.assertTrue(has_endoscopy_tip)\n        \n        # All procedures should have general tips\n        has_general_tips = any(\"medical necessity\" in tip.lower() for tip in tips)\n        self.assertTrue(has_general_tips)\n\n\nif __name__ == '__main__':\n    unittest.main()"
                },
                {
                    "name": "__init__.py",
                    "content": "\"\"\"\nTest package for the ENT CPT Code Agent.\n\nThis package contains unit tests for the various components of the agent.\n\"\"\""
                },
                {
                    "name": "test_cpt_database.py",
                    "content": "import os\nimport sys\nimport unittest\nimport tempfile\nimport pandas as pd\nfrom pathlib import Path\nimport logging\n\n# Add the src directory to the path so we can import our modules\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))\n\n# Import the class to test\nfrom src.agent.cpt_database import CPTCodeDatabase\n\n# Disable logging output during tests\nlogging.disable(logging.CRITICAL)\n\nclass TestCPTCodeDatabase(unittest.TestCase):\n    \"\"\"\n    Unit tests for the CPTCodeDatabase class.\n    \n    These tests validate the functionality of loading, searching,\n    and retrieving CPT codes from the database.\n    \"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        # Create a temporary Excel file with test data\n        self.temp_dir = tempfile.TemporaryDirectory()\n        self.test_file = os.path.join(self.temp_dir.name, \"test_cpt_codes.xlsx\")\n        \n        # Create test data\n        data = {\n            'CPT Code': ['31231', '69436', '42820', '30520'],\n            'Description': [\n                'Nasal endoscopy, diagnostic', \n                'Tympanostomy with tubes, bilateral', \n                'Tonsillectomy and adenoidectomy, under age 12', \n                'Septoplasty'\n            ],\n            'Category': ['Nose', 'Ear', 'Throat', 'Nose'],\n            'Related Codes': ['31233, 31235', '69433', '42821, 42825', '30930']\n        }\n        \n        # Create a DataFrame and save to Excel\n        df = pd.DataFrame(data)\n        df.to_excel(self.test_file, index=False)\n        \n        # Initialize the database with test data\n        self.cpt_db = CPTCodeDatabase(self.test_file)\n    \n    def tearDown(self):\n        \"\"\"Tear down test fixtures after each test method.\"\"\"\n        # Clean up the temporary directory\n        self.temp_dir.cleanup()\n    \n    def test_load_data(self):\n        \"\"\"Test that data is loaded correctly from Excel file.\"\"\"\n        # Verify number of codes loaded\n        self.assertEqual(len(self.cpt_db.code_descriptions), 4)\n        \n        # Verify code descriptions\n        self.assertEqual(self.cpt_db.code_descriptions['31231'], 'Nasal endoscopy, diagnostic')\n        self.assertEqual(self.cpt_db.code_descriptions['69436'], 'Tympanostomy with tubes, bilateral')\n        \n        # Verify categories\n        self.assertIn('31231', self.cpt_db.code_categories['Nose'])\n        self.assertIn('69436', self.cpt_db.code_categories['Ear'])\n        \n        # Verify related codes\n        self.assertEqual(self.cpt_db.related_codes['31231'], ['31233', '31235'])\n        self.assertEqual(self.cpt_db.related_codes['69436'], ['69433'])\n    \n    def test_search_codes(self):\n        \"\"\"Test searching for codes by query.\"\"\"\n        # Search by code\n        results = self.cpt_db.search_codes('31231')\n        self.assertEqual(len(results), 1)\n        self.assertEqual(results[0]['code'], '31231')\n        \n        # Search by partial description\n        results = self.cpt_db.search_codes('endoscopy')\n        self.assertEqual(len(results), 1)\n        self.assertEqual(results[0]['code'], '31231')\n        \n        # Search by category (should match multiple)\n        results = self.cpt_db.search_codes('nose')\n        self.assertEqual(len(results), 2)\n        codes = [r['code'] for r in results]\n        self.assertIn('31231', codes)\n        self.assertIn('30520', codes)\n        \n        # Search with no matches\n        results = self.cpt_db.search_codes('xyz123')\n        self.assertEqual(len(results), 0)\n    \n    def test_get_code_details(self):\n        \"\"\"Test retrieving details for a specific code.\"\"\"\n        # Get details for valid code\n        details = self.cpt_db.get_code_details('42820')\n        self.assertEqual(details['code'], '42820')\n        self.assertEqual(details['description'], 'Tonsillectomy and adenoidectomy, under age 12')\n        self.assertEqual(details['related_codes'], ['42821', '42825'])\n        \n        # Get details for invalid code\n        details = self.cpt_db.get_code_details('99999')\n        self.assertIn('error', details)\n        self.assertEqual(details['error'], 'CPT code 99999 not found')\n    \n    def test_get_codes_by_category(self):\n        \"\"\"Test retrieving codes by category.\"\"\"\n        # Get codes for Nose category\n        results = self.cpt_db.get_codes_by_category('Nose')\n        self.assertEqual(len(results), 2)\n        codes = [r['code'] for r in results]\n        self.assertIn('31231', codes)\n        self.assertIn('30520', codes)\n        \n        # Get codes for non-existent category\n        results = self.cpt_db.get_codes_by_category('Unknown')\n        self.assertEqual(len(results), 0)\n    \n    def test_get_code_validation(self):\n        \"\"\"Test code validation functionality.\"\"\"\n        # Validate valid code\n        result = self.cpt_db.get_code_validation('30520')\n        self.assertTrue(result['valid'])\n        self.assertEqual(result['description'], 'Septoplasty')\n        \n        # Validate invalid code\n        result = self.cpt_db.get_code_validation('12345')\n        self.assertFalse(result['valid'])\n        self.assertIn('error', result)\n\nif __name__ == '__main__':\n    unittest.main()"
                }
            ]
        },
        {
            "name": "docs",
            "files": [
                {
                    "name": "PROJECT_SUMMARY.md",
                    "content": "# ENT CPT Code Agent - Project Summary\n\n## Project Overview\n\nThe ENT CPT Code Agent is a comprehensive AI-powered assistant designed to help medical professionals accurately determine the appropriate CPT codes for ENT (Ear, Nose, Throat) procedures according to official coding guidelines. The system leverages LM Studio to provide an intelligent interface that can understand natural language descriptions of procedures and recommend the most appropriate codes based on medical coding rules.\n\n## Key Components\n\n### 1. CPT Code Database\n\nThe `CPTCodeDatabase` class manages the loading, storing, and querying of CPT codes from an Excel file. It provides functionality for:\n- Searching for codes by description or keywords\n- Retrieving code details and validating codes\n- Organizing codes by category\n- Identifying related codes\n\n### 2. Rules Engine\n\nThe `RulesEngine` class implements medical coding rules for CPT code selection, handling:\n- Bundled procedures (codes that should not be reported together)\n- Bilateral procedures (requiring modifier 50)\n- Multiple procedures (requiring modifier 51)\n- Medical necessity validation\n- Custom rule creation and application\n\n### 3. Conversation Manager\n\nThe `ConversationManager` and `Conversation` classes handle user interactions, managing:\n- Conversation history storage and retrieval\n- Message tracking and organization\n- Conversion between internal representation and LM Studio chat format\n- CPT code extraction from conversation text\n\n### 4. Agent Core\n\nThe `ENTCPTAgent` class serves as the central component, integrating:\n- The LM Studio model for natural language understanding\n- Tool functions for CPT code operations\n- Query processing and response generation\n- Interactive session management\n\n### 5. API Interface\n\nThe `APIInterface` class provides a REST API for the agent, offering endpoints for:\n- Submitting queries to the agent\n- Searching for and validating CPT codes\n- Analyzing procedure descriptions\n- Managing conversation sessions\n\n### 6. Web UI\n\nA web-based user interface built with Flask that provides:\n- A chat interface for interacting with the agent\n- Tools for code search, validation, and analysis\n- Conversation history management\n- Detected code tracking and display\n\n## Architecture Design\n\nThe project follows a modular architecture with clear separation of concerns:\n\n1. **Data Layer**: CPT code database and persistence\n2. **Business Logic Layer**: Rules engine and agent core\n3. **Presentation Layer**: API interface and web UI\n4. **Integration Layer**: LM Studio integration\n\nComponents communicate through well-defined interfaces, allowing for:\n- Independent testing and development\n- Easy replacement or enhancement of individual components\n- Flexible deployment options (CLI, API, web)\n\n## Integration with LM Studio\n\nThe system integrates with LM Studio through its Python SDK. Key integration points:\n\n### LLM Initialization\n\n```python\n# Configure and load the model\nself.model = lms.llm(self.model_name, config={\n    \"temperature\": self.model_temperature,\n    \"maxTokens\": self.model_max_tokens\n})\n```\n\n### Tool Function Registration\n\nThe agent provides tool functions that the language model can use:\n- `search_cpt_codes`: Search for CPT codes based on a procedure description\n- `validate_cpt_code`: Validate if a CPT code exists and is correct\n- `get_category_codes`: Get all CPT codes for a specific category\n- `explain_coding_rules`: Explain the rules for using a specific CPT code\n- `analyze_procedure`: Analyze a procedure description to determine appropriate codes\n\n### Query Processing\n\n```python\n# Define the tool functions\ntools = [\n    self.search_cpt_codes,\n    self.validate_cpt_code,\n    self.get_category_codes,\n    self.explain_coding_rules,\n    self.analyze_procedure\n]\n\n# Let the model use tools to process the query\nresult = self.model.act(\n    chat,\n    tools,\n    on_message=lambda msg: conversation.add_message(\"assistant\", msg.content) if conversation else None\n)\n```\n\n## Getting Started\n\n1. Install the requirements: `pip install -r requirements.txt`\n2. Initialize the configuration: `python main.py init`\n3. Place the CPT code database file in the data directory\n4. Run the application in interactive mode: `python main.py interactive`\n\n## Development Workflow\n\nTo further develop and extend the project:\n\n1. **Setup the Development Environment**:\n   ```bash\n   # Clone the repository\n   git clone <repository-url> ent-cpt-agent\n   cd ent-cpt-agent\n   \n   # Create a virtual environment\n   python -m venv venv\n   source venv/bin/activate  # On Windows: venv\\Scripts\\activate\n   \n   # Install development dependencies\n   pip install -r requirements-dev.txt\n   ```\n\n2. **Run Tests**:\n   ```bash\n   # Run all tests\n   python -m unittest discover\n   \n   # Run specific test file\n   python -m unittest tests.test_cpt_database\n   ```\n\n3. **Add New Features**:\n   - Create or modify code in the `src` directory\n   - Add tests in the `tests` directory\n   - Update documentation as needed\n\n4. **Build and Package**:\n   ```bash\n   # Build the package\n   python setup.py sdist bdist_wheel\n   \n   # Install locally for testing\n   pip install -e .\n   ```\n\n## Extending the Project\n\nThe ENT CPT Code Agent is designed to be extensible. Here are some ways to enhance it:\n\n1. **Add New Rules**: Create new `CodeRule` instances in the `RulesEngine` for additional coding guidelines.\n\n2. **Enhance the Database**: Add more fields to the CPT code database to support additional information, such as:\n   - Reimbursement rates\n   - Payer-specific guidelines\n   - Historical coding data\n\n3. **Improve the UI**: Enhance the web interface with additional features:\n   - Visualization of coding relationships\n   - Interactive procedure diagrams\n   - Documentation templates\n\n4. **Extend to Other Specialties**: Adapt the framework to support other medical specialties beyond ENT.\n\n## Deployment Options\n\nThe ENT CPT Code Agent supports multiple deployment scenarios:\n\n1. **Standalone Application**: Run the interactive CLI or web UI locally for individual users.\n\n2. **API Server**: Deploy as a service that other applications can integrate with via REST API.\n\n3. **Embedded Component**: Integrate the core logic into existing electronic medical record (EMR) systems.\n\n## Conclusion\n\nThe ENT CPT Code Agent provides a comprehensive solution for ENT procedure coding assistance. Its modular design, integration with LM Studio, and extensible architecture make it a powerful tool for medical professionals and coding specialists.\n"
                },
                {
                    "name": "integration_flow.mermaid",
                    "content": "flowchart TB\n    subgraph User[\"User Interaction\"]\n        CLI[\"Command Line Interface\"]\n        API[\"API/Web Interface\"]\n    end\n\n    subgraph Config[\"Configuration Layer\"]\n        AG_CONFIG[\"Agent Config\"]\n        AG_CONFIG --> LOGGING[\"Logging System\"]\n    end\n\n    subgraph Core[\"Core Agent Components\"]\n        ENT_AGENT[\"ENT CPT Agent\"]\n        CONV_MGR[\"Conversation Manager\"]\n        CPT_DB[\"CPT Code Database\"]\n        RULES[\"Rules Engine\"]\n    end\n\n    subgraph AI[\"AI Engine\"]\n        LM_STUDIO[\"LM Studio Engine\"]\n        TOOLS[\"Tool Functions\"]\n    end\n\n    subgraph Storage[\"Persistence Layer\"]\n        CONV_STORE[\"Conversation Storage\"]\n        CPT_DATA[\"CPT Code Data (Excel)\"]\n    end\n\n    %% Connections\n    CLI --> ENT_AGENT\n    API --> ENT_AGENT\n    \n    AG_CONFIG --> ENT_AGENT\n    \n    ENT_AGENT --> CONV_MGR\n    ENT_AGENT --> CPT_DB\n    ENT_AGENT --> RULES\n    ENT_AGENT --> LM_STUDIO\n    \n    CONV_MGR <--> CONV_STORE\n    CPT_DB <--> CPT_DATA\n    \n    LM_STUDIO --> TOOLS\n    TOOLS --> CPT_DB\n    TOOLS --> RULES\n    \n    %% Styling\n    classDef primary fill:#e1f5fe,stroke:#01579b,stroke-width:2px\n    classDef secondary fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px\n    classDef tertiary fill:#fff3e0,stroke:#e65100,stroke-width:2px\n    classDef data fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px\n    \n    class ENT_AGENT,CONV_MGR primary\n    class CPT_DB,RULES secondary\n    class LM_STUDIO,TOOLS tertiary\n    class CONV_STORE,CPT_DATA,AG_CONFIG data\n"
                },
                {
                    "name": "api_docs.md",
                    "content": "# 6. API Documentation\n\nWhen running in server mode, the API documentation is available at:\n\n- OpenAPI UI: `http://localhost:8000/docs`\n- ReDoc UI: `http://localhost:8000/redoc`\n\n## 6.1 API Endpoints\n\n- `POST /api/query`: Submit a query to the agent\n- `POST /api/search`: Search for CPT codes\n- `POST /api/validate`: Validate a CPT code\n- `POST /api/analyze`: Analyze a procedure description\n- `GET /api/conversations`: List all conversations\n- `GET /api/conversations/{session_id}`: Get a specific conversation\n- `DELETE /api/conversations/{session_id}`: Delete a specific conversation\n"
                },
                {
                    "name": "usage_examples.md",
                    "content": "# ENT CPT Code Agent - Usage Examples\n\nThis document provides examples of using the ENT CPT Code Agent in different scenarios to help you get started.\n\n## 1. Basic Querying\n\n### Example 1: Finding codes for a specific procedure\n\n**Query:**\n```\nWhat is the CPT code for bilateral myringotomy with tube insertion?\n```\n\n**Response:**\n```\nBased on your description, the appropriate CPT code for bilateral myringotomy with tube insertion is:\n\n69436 - Tympanostomy (requiring insertion of ventilating tube), general anesthesia, bilateral\n\nThis code is used when performing a bilateral myringotomy (making an incision in both eardrums) with the insertion of ventilation tubes under general anesthesia.\n\nIf the procedure was performed under local anesthesia or with conscious sedation rather than general anesthesia, the appropriate code would be:\n\n69433 - Tympanostomy (requiring insertion of ventilating tube), local or topical anesthesia, bilateral\n\nKey coding considerations:\n1. The -50 modifier is not used with codes 69433 and 69436 because these codes already specify bilateral procedures\n2. Documentation should clearly indicate that the procedure was performed on both ears\n3. Ensure that medical necessity is properly documented in the patient's chart\n```\n\n### Example 2: Explaining coding rules\n\n**Query:**\n```\nExplain the coding rules for CPT code 31231\n```\n\n**Response:**\n```\nCoding guidelines for CPT 31231:\n\nDescription: Nasal endoscopy, diagnostic, unilateral or bilateral (separate procedure)\n\nGeneral coding rules:\n1. Code 31231 is used for diagnostic nasal endoscopy, which involves examining the nasal cavity using an endoscope.\n2. This code can be used for either unilateral (one side) or bilateral (both sides) diagnostic nasal endoscopy.\n3. The term \"separate procedure\" means that if this procedure is performed as part of another, more comprehensive procedure, it should not be reported separately.\n4. This code should not be reported with surgical endoscopy codes (31237-31294) when performed on the same side.\n\nDocumentation requirements:\n1. Medical record must document medical necessity for the diagnostic procedure\n2. Documentation should specify which side(s) were examined (right, left, or bilateral)\n3. Findings from the endoscopy must be clearly documented\n\nBundling considerations:\n- Code 31231 is often bundled with surgical nasal/sinus endoscopy procedures\n- It should not be billed separately when a surgical endoscopy is performed during the same encounter on the same side\n- It may be reported with modifier -59 if performed on the contralateral side of a surgical endoscopy\n\nRelated codes to consider: 31233, 31235, 31237, 31575\n\nAlways verify current coding guidelines, as they may change over time.\n```\n\n## 2. Using the Rules Engine\n\n### Example 3: Analyzing a procedure description\n\n**Query:**\n```\nAnalyze this procedure: \"Patient underwent bilateral endoscopic sinus surgery including maxillary antrostomy, anterior ethmoidectomy, and removal of polyps from both maxillary sinuses.\"\n```\n\n**Response:**\n```\nAnalysis of procedure: Patient underwent bilateral endoscopic sinus surgery including maxillary antrostomy, anterior ethmoidectomy, and removal of polyps from both maxillary sinuses.\n\nRecommended CPT codes:\n- 31267-50: Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus (Modifier 50 for bilateral procedure)\n- 31254-50: Nasal/sinus endoscopy, surgical; with ethmoidectomy, partial (anterior) (Modifier 50 for bilateral procedure)\n\nRecommendation details:\n- Added modifier 50 to code 31267 for bilateral procedure.\n- Added modifier 50 to code 31254 for bilateral procedure.\n- Code 31267 includes the maxillary antrostomy with removal of tissue (polyps) from the maxillary sinus\n- Code 31254 addresses the anterior ethmoidectomy component\n\nCoding tips:\n1. Documentation should clearly indicate the extent of each sinus entered and the work performed in each sinus\n2. When coding sinus procedures, it's important to code for each sinus operated on separately\n3. Ensure that the procedural documentation supports bilateral procedures\n4. Verify medical necessity documentation for each sinus procedure\n5. Modifier 50 (bilateral) is appropriate since the procedures were performed on both sides\n\nNote: The order of the codes may affect reimbursement due to multiple procedure payment reduction rules. The highest valued procedure should typically be listed first.\n```\n\n### Example 4: Validating a CPT code\n\n**Query:**\n```\nIs 42820 the correct code for tonsillectomy and adenoidectomy in an adult?\n```\n\n**Response:**\n```\nCPT code 42820 is valid, but it's not the most appropriate code for tonsillectomy and adenoidectomy in an adult.\n\nThe description for 42820 is: \"Tonsillectomy and adenoidectomy; younger than age 12\"\n\nFor an adult patient, the correct code would be:\n42821 - Tonsillectomy and adenoidectomy; age 12 or over\n\nKey points about these codes:\n1. Age is a determining factor in code selection between 42820 and 42821\n2. For adult patients (age 12 or over), 42821 is the appropriate code\n3. The procedure includes both tonsillectomy and adenoidectomy\n4. No modifier is needed to indicate that both procedures were performed since the code description already includes both\n\nIf only one of the procedures was performed, you would use a different code:\n- 42825 or 42826 for tonsillectomy alone (based on age)\n- 42830 or 42831 for adenoidectomy alone (based on age)\n\nAlways ensure your documentation clearly indicates medical necessity for both the tonsillectomy and adenoidectomy components.\n```\n\n## 3. Advanced Queries\n\n### Example 5: Comparing related codes\n\n**Query:**\n```\nWhat's the difference between CPT codes 69421 and 69424 for myringotomy?\n```\n\n**Response:**\n```\nHere's a comparison of CPT codes 69421 and 69424 for myringotomy procedures:\n\nCPT Code 69421:\n- Description: Myringotomy including aspiration and/or eustachian tube inflation; requiring general anesthesia\n- Key elements: Includes incision of the tympanic membrane (eardrum) with aspiration and/or eustachian tube inflation\n- Anesthesia requirement: Must be performed under general anesthesia\n- Typical patients: Often used for younger children who cannot tolerate the procedure while awake\n- Does NOT include insertion of ventilation tubes\n\nCPT Code 69424:\n- Description: Myringotomy including aspiration and/or eustachian tube inflation; requiring local or topical anesthesia\n- Key elements: Includes the same procedure (incision of tympanic membrane with aspiration and/or eustachian tube inflation)\n- Anesthesia requirement: Performed under local or topical anesthesia\n- Typical patients: Generally used for older children or adults who can tolerate the procedure with local anesthesia\n- Does NOT include insertion of ventilation tubes\n\nKey differences:\n1. The primary distinction is the type of anesthesia used\n2. Code selection is based solely on the anesthesia method, not the procedure itself\n3. Neither code includes the insertion of ventilation/PE tubes\n\nIf tubes are inserted, you would use different codes:\n- 69433 (local anesthesia) or 69436 (general anesthesia) for tympanostomy with tube insertion\n\nDocumentation tips:\n- Clearly document the type of anesthesia used\n- Specify whether aspiration was performed\n- Note whether eustachian tube inflation was performed\n- Document medical necessity for the procedure\n```\n\n### Example 6: Complex scenario with multiple procedures\n\n**Query:**\n```\nWhat are the correct CPT codes for: Septoplasty, bilateral inferior turbinate reduction, and bilateral maxillary sinus surgery with tissue removal?\n```\n\n**Response:**\n```\nFor this complex ENT procedure involving septoplasty, bilateral inferior turbinate reduction, and bilateral maxillary sinus surgery with tissue removal, the appropriate CPT codes are:\n\n1. 30520 - Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft\n   - This code represents the septoplasty procedure\n   - No modifiers are needed as septoplasty is inherently a single procedure (not bilateral)\n\n2. 30140-50 - Submucous resection inferior turbinate, partial or complete, any method\n   - The -50 modifier indicates the procedure was performed bilaterally\n   - This code covers the bilateral inferior turbinate reduction\n\n3. 31267-50 - Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus\n   - The -50 modifier indicates the procedure was performed on both maxillary sinuses\n   - This code includes both the antrostomy (creating an opening) and tissue removal\n\nCoding guidelines to consider:\n1. These procedures are typically reported together when performed during the same operative session\n2. There are no specific NCCI edits that would prohibit reporting these codes together when properly documented\n3. Some payers may require modifier -51 (multiple procedures) on the second and third procedures\n4. The order of the codes may affect reimbursement (typically highest RVU procedure first)\n\nDocumentation requirements:\n1. Medical necessity for each procedure must be clearly documented\n2. Separate diagnoses supporting each procedure improve reimbursement likelihood\n3. Detailed operative notes should describe each procedure separately\n4. For the turbinate procedure, documentation should specify \"bilateral\" and the method used\n5. For the sinus procedure, documentation should indicate both sinuses were treated and describe the tissue removed\n\nAlways verify current coding guidelines with your specific payer, as policies may vary.\n```\n\n## 4. Tool Usage Examples\n\n### Example 7: Using the Search Tool\n\n**Query:**\n```\nSearch for CPT codes related to cochlear implants\n```\n\n**Response:**\n```\nI'll search for CPT codes related to cochlear implants.\n\nFound 4 CPT codes matching 'cochlear implants':\n\n1. Code 69930: Cochlear device implantation, with or without mastoidectomy\n   Related codes: 92601, 92602\n\n2. Code 69949: Unlisted procedure, inner ear\n   Related codes: None\n\n3. Code 92601: Diagnostic analysis of cochlear implant, patient younger than 7 years of age; with programming\n   Related codes: 69930, 92602\n\n4. Code 92602: Diagnostic analysis of cochlear implant, patient younger than 7 years of age; subsequent reprogramming\n   Related codes: 69930, 92601\n\nAdditionally, there are related codes for older patients and external components:\n\n5. Code 92603: Diagnostic analysis of cochlear implant, age 7 years or older; with programming\n   Related codes: 92604\n\n6. Code 92604: Diagnostic analysis of cochlear implant, age 7 years or older; subsequent reprogramming\n   Related codes: 92603\n\nThe main surgical code is 69930, which covers the implantation of the cochlear device. The other codes relate to programming and analysis of the implant, with different codes based on patient age.\n\nWould you like more specific information about any of these codes?\n```\n\n### Example 8: Using the Analyze Tool\n\n**Query:**\n```\nCan you analyze this procedure and tell me the correct codes: \"Functional endoscopic sinus surgery with left maxillary antrostomy, left ethmoidectomy, left sphenoidotomy, and septoplasty\"\n```\n\n**Response:**\n```\nAnalysis of procedure: Functional endoscopic sinus surgery with left maxillary antrostomy, left ethmoidectomy, left sphenoidotomy, and septoplasty\n\nRecommended CPT codes:\n- 31267: Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus\n- 31287: Nasal/sinus endoscopy, surgical, with sphenoidotomy\n- 31255: Nasal/sinus endoscopy, surgical; with ethmoidectomy, total (anterior and posterior)\n- 30520: Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft\n\nRecommendation details:\n- Code 31267 represents the left maxillary antrostomy\n- Code 31287 covers the left sphenoidotomy\n- Code 31255 is used for the left ethmoidectomy (assuming total ethmoidectomy from the description)\n- Code 30520 addresses the septoplasty procedure\n- No bilateral modifiers are needed as all sinus procedures are specified as left-sided\n- When reporting multiple endoscopic sinus procedures, each sinus is coded separately\n\nCoding guidelines:\n1. Proper sequencing is important - typically, the most resource-intensive procedure should be listed first\n2. No NCCI (National Correct Coding Initiative) edits prohibit reporting these codes together\n3. Some payers may require modifier -51 (multiple procedures) on the second and subsequent procedures\n4. Documentation must support medical necessity for each individual sinus procedure\n5. For the septoplasty (30520), be sure documentation indicates significant septal deviation requiring correction\n\nNote: If the ethmoidectomy was only partial/anterior rather than total, use code 31254 instead of 31255.\n```\n\n## 5. Web UI Examples\n\nThe Web UI provides a user-friendly interface for interacting with the ENT CPT Code Agent. Here are some key features:\n\n### Main Chat Interface\n\nThe main chat interface allows you to:\n\n- Ask questions about ENT procedures and CPT codes\n- View responses with detected CPT codes highlighted\n- Start new conversation sessions\n- Review conversation history\n\n### Tools Panel\n\nThe Tools panel provides specialized functions:\n\n1. **Search Tab**\n   - Search for CPT codes by keyword or description\n   - View matching codes with descriptions\n   - Add codes to the conversation with one click\n\n2. **Validate Tab**\n   - Validate specific CPT codes\n   - View code descriptions and validity\n   - Learn more about validated codes\n\n3. **Analyze Tab**\n   - Submit detailed procedure descriptions for analysis\n   - Specify candidate codes (optional)\n   - View recommended codes with explanations\n   - Discuss analysis results in the main chat\n\n### Detected Codes Panel\n\nThis panel displays all CPT codes detected in the conversation, allowing you to:\n\n- See a list of all codes mentioned in the conversation\n- Click on any code to validate it\n- Keep track of relevant codes for the current discussion\n\n## 6. API Integration Examples\n\n### Python Example\n\n```python\nimport requests\nimport json\n\nAPI_URL = \"http://localhost:8000/api\"\n\n# Query the agent\ndef query_agent(question, session_id=None):\n    response = requests.post(\n        f\"{API_URL}/query\",\n        json={\n            \"query\": question,\n            \"session_id\": session_id\n        }\n    )\n    return response.json()\n\n# Search for CPT codes\ndef search_codes(search_term):\n    response = requests.post(\n        f\"{API_URL}/search\",\n        json={\"search_term\": search_term}\n    )\n    return response.json()\n\n# Validate a CPT code\ndef validate_code(code):\n    response = requests.post(\n        f\"{API_URL}/validate\",\n        json={\"code\": code}\n    )\n    return response.json()\n\n# Analyze a procedure\ndef analyze_procedure(procedure_text, candidate_codes=None):\n    data = {\n        \"procedure_text\": procedure_text\n    }\n    if candidate_codes:\n        data[\"candidate_codes\"] = candidate_codes\n    \n    response = requests.post(\n        f\"{API_URL}/analyze\",\n        json=data\n    )\n    return response.json()\n\n# Example usage\nif __name__ == \"__main__\":\n    # Query about a procedure\n    result = query_agent(\"What is the CPT code for myringotomy with tube insertion?\")\n    print(json.dumps(result, indent=2))\n    \n    # Use the returned session ID for follow-up questions\n    session_id = result.get(\"session_id\")\n    result = query_agent(\"What if it's bilateral?\", session_id)\n    print(json.dumps(result, indent=2))\n    \n    # Search for related codes\n    search_result = search_codes(\"tympanoplasty\")\n    print(json.dumps(search_result, indent=2))\n```\n\n### JavaScript (Node.js) Example\n\n```javascript\nconst axios = require('axios');\n\nconst API_URL = 'http://localhost:8000/api';\n\n// Query the agent\nasync function queryAgent(question, sessionId = null) {\n  try {\n    const response = await axios.post(`${API_URL}/query`, {\n      query: question,\n      session_id: sessionId\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error querying agent:', error.message);\n    return null;\n  }\n}\n\n// Search for CPT codes\nasync function searchCodes(searchTerm) {\n  try {\n    const response = await axios.post(`${API_URL}/search`, {\n      search_term: searchTerm\n    });\n    return response.data;\n  } catch (error) {\n    console.error('Error searching codes:', error.message);\n    return null;\n  }\n}\n\n// Example usage\nasync function main() {\n  // Query about a procedure\n  const result = await queryAgent('What is the CPT code for balloon sinuplasty?');\n  console.log(JSON.stringify(result, null, 2));\n  \n  // Use the returned session ID for follow-up questions\n  const sessionId = result.session_id;\n  const followUpResult = await queryAgent('What documentation is required?', sessionId);\n  console.log(JSON.stringify(followUpResult, null, 2));\n  \n  // Search for related codes\n  const searchResult = await searchCodes('sinuplasty');\n  console.log(JSON.stringify(searchResult, null, 2));\n}\n\nmain();\n```\n\n### cURL Examples\n\n**Query the Agent:**\n```bash\ncurl -X POST http://localhost:8000/api/query \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"query\": \"What is the CPT code for nasal endoscopy?\",\n    \"session_id\": null\n  }'\n```\n\n**Search for CPT Codes:**\n```bash\ncurl -X POST http://localhost:8000/api/search \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"search_term\": \"endoscopy\"\n  }'\n```\n\n**Validate a CPT Code:**\n```bash\ncurl -X POST http://localhost:8000/api/validate \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"code\": \"31231\"\n  }'\n```\n\n**Analyze a Procedure:**\n```bash\ncurl -X POST http://localhost:8000/api/analyze \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"procedure_text\": \"Bilateral myringotomy with tube placement under general anesthesia\",\n    \"candidate_codes\": [\"69433\", \"69436\"]\n  }'\n```\n\n## 7. Workflow Examples\n\n### Typical Coding Workflow\n\n#### Example A: New Patient with Sinusitis\n\n1. **Initial Assessment**:\n   - Query: \"What CPT codes are used for a new patient comprehensive ENT evaluation?\"\n   - Agent suggests E&M codes (99202-99205) based on complexity\n\n2. **Diagnostic Procedures**:\n   - Query: \"The physician performed a nasal endoscopy. What code should I use?\"\n   - Agent suggests 31231 (Nasal endoscopy, diagnostic) with guidance on documentation requirements\n\n3. **Treatment Planning**:\n   - Query: \"The patient needs functional endoscopic sinus surgery for chronic sinusitis affecting the maxillary and ethmoid sinuses bilaterally. What codes apply?\"\n   - Agent analyzes the case and suggests appropriate surgical codes with modifiers\n\n4. **Code Validation**:\n   - Use the validation tool to verify all selected codes\n   - Review any bundling issues or modifier requirements\n\n#### Example B: Follow-up Visit After Surgery\n\n1. **Post-op Visit Coding**:\n   - Query: \"How do I code a follow-up visit 2 weeks after FESS surgery?\"\n   - Agent explains post-op period bundling rules and when separate E&M codes can be used\n\n2. **Additional Procedures**:\n   - Query: \"The surgeon performed nasal debridement during the follow-up. Is this billable?\"\n   - Agent provides guidance on 31237 (Nasal/sinus endoscopy, surgical with debridement) and appropriate modifiers\n\n3. **Rule Clarification**:\n   - Query: \"Can you explain the global period for CPT 31255?\"\n   - Agent explains the standard global period and documentation requirements for separately billable services\n\n### Audit Preparation Workflow\n\n1. **Documentation Review**:\n   - Query: \"What documentation is required to support billing CPT 69436?\"\n   - Agent provides comprehensive documentation requirements\n\n2. **Code Selection Verification**:\n   - Query: \"Analyze this operative note: 'Patient underwent bilateral myringotomy with insertion of ventilation tubes under general anesthesia. Procedure performed due to recurrent otitis media with effusion refractory to medical management.'\"\n   - Agent analyzes the note and confirms correct code selection\n\n3. **Modifier Usage Review**:\n   - Query: \"When should modifier 59 be used with endoscopic sinus procedures?\"\n   - Agent explains appropriate use of modifier 59 for separate and distinct procedures\n\n## 8. Educational Examples\n\n### Learning About Coding Principles\n\n**Query:**\n```\nExplain the concept of bundling in ENT CPT coding\n```\n\n**Response:**\n```\nBundling in ENT CPT Coding:\n\nBundling refers to the practice of including multiple components of a procedure under a single CPT code rather than reporting them separately. This concept is fundamental to proper ENT coding and helps prevent inappropriate unbundling (reporting separate codes for procedures that should be reported together).\n\nKey principles of bundling in ENT coding:\n\n1. Comprehensive Codes: Many ENT CPT codes describe comprehensive procedures that include multiple steps or components. For example, code 69436 (bilateral tympanostomy tube insertion) includes the myringotomy (incision of the eardrum), aspiration of middle ear fluid, and placement of the tubes.\n\n2. \"Separate Procedure\" Designation: Some CPT codes are designated as \"separate procedures.\" This means that when the procedure is performed as part of a more comprehensive service, it should not be reported separately. For example, 31231 (diagnostic nasal endoscopy) is labeled as a separate procedure and should not be reported when a surgical nasal endoscopy is performed.\n\n3. NCCI Edits: The National Correct Coding Initiative (NCCI) maintains a database of procedure code pairs that should not be reported together. For ENT procedures, many diagnostic endoscopies are bundled with surgical endoscopies of the same anatomical site.\n\n4. Global Surgical Packages: Surgical procedures include a \"global period\" during which certain services are bundled with the procedure. For ENT surgeries, this typically includes:\n   - Preoperative evaluation on the day of surgery\n   - The surgical procedure itself\n   - Uncomplicated postoperative care for 10 or 90 days (depending on the procedure)\n   - Treatment of complications that don't require a return to the operating room\n\nCommon bundling scenarios in ENT coding:\n\n1. Endoscopic Sinus Surgery: When multiple sinuses are operated on during the same session, each sinus has its own CPT code, but diagnostic nasal endoscopy (31231) would be bundled.\n\n2. Ear Procedures: Microscopic examination of the ear is bundled into procedures like tympanostomy tube placement or tympanoplasty.\n\n3. Septoplasty with Turbinate Reduction: These are separate procedures with different CPT codes (30520 and 30140) that can be reported together when performed during the same operative session.\n\nTo avoid improper unbundling:\n- Thoroughly understand CPT code descriptions and included services\n- Regularly review NCCI edits for ENT procedures\n- Document each procedure component separately and clearly\n- Use appropriate modifiers only when truly separate, distinct services are performed\n\nRemember that improper unbundling can be considered fraudulent billing and may result in denied claims, audits, or compliance issues.\n```\n\n### Understanding Complex Coding Scenarios\n\n**Query:**\n```\nExplain how to code for a patient who had a septoplasty and then returned a week later with complications requiring surgical intervention\n```\n\n**Response:**\n```\nCoding for Septoplasty with Subsequent Complication Requiring Surgery:\n\nThis scenario involves two parts: the initial septoplasty and then the separate return to surgery for a complication. Here's how to approach coding for this situation:\n\nInitial Septoplasty:\n- CPT Code: 30520 (Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft)\n- This code has a 90-day global period, meaning postoperative care is bundled into the payment for 90 days after surgery\n\nReturn for Surgical Treatment of Complication:\n\nThe key coding principle here is whether the complication required a return to the operating room (OR). Complications treated in the OR during the global period are typically coded with:\n\n1. The appropriate CPT code for the procedure performed\n2. Modifier -78 (Unplanned Return to the Operating/Procedure Room by the Same Physician or Other Qualified Health Care Professional Following Initial Procedure for a Related Procedure During the Postoperative Period)\n\nFor example, if the patient developed a septal hematoma requiring drainage:\n- CPT Code: 30020-78 (Drainage of nasal septal abscess or hematoma, with modifier -78)\n\nIf the patient required revision septoplasty:\n- CPT Code: 30520-78 (Septoplasty with modifier -78)\n\nImportant coding guidelines:\n\n1. Documentation Requirements:\n   - The medical record must clearly establish that the complication is related to the initial procedure\n   - Documentation should specify the nature of the complication and why a return to the OR was necessary\n   - The operative report for the second procedure should reference the initial procedure\n\n2. Modifier -78:\n   - This modifier indicates an unplanned return to the OR for a related procedure\n   - It bypasses the global period restrictions\n   - The second procedure is typically reimbursed at a reduced rate (usually about 70% of the fee schedule)\n   - No additional E/M service should be reported for the decision to perform the second surgery\n\n3. Other Possible Modifiers:\n   - If the complication is treated without returning to the OR, no additional procedure coding is warranted (it's included in the global package)\n   - If the patient requires hospitalization for the complication, inpatient E/M services may be reported with modifier -24 (Unrelated E/M Service)\n\n4. Diagnosis Coding:\n   - The ICD-10 code for the second procedure should reflect the complication\n   - Consider using appropriate complication codes (T81.XXX series) that specify postprocedural complications\n   - Link the complication diagnosis to both the initial procedure and the complication\n\nExample scenario:\nA patient undergoes septoplasty (30520) on March 1st. On March 8th, the patient returns with a septal hematoma requiring drainage in the OR. The correct coding would be:\n- 30020-78 (Drainage of nasal septal hematoma with return to OR modifier)\n- Diagnosis: T81.0XXA (Hemorrhage and hematoma complicating a procedure, initial encounter)\n\nRemember that proper documentation is crucial for supporting the medical necessity of the second procedure and establishing its relationship to the initial surgery.\n```\n\n## 9. Continuous Learning and Improvement\n\nThe ENT CPT Code Agent continuously learns from interactions and improves its responses. Here are ways to help enhance the system:\n\n1. **Provide Feedback**: When the agent provides incorrect or incomplete information, inform it directly in the conversation.\n\n2. **Ask for Clarification**: If a response is unclear, ask follow-up questions to get more specific information.\n\n3. **Request Updates**: When coding rules change, inform the agent so it can provide the most current guidance.\n\n4. **Suggest New Features**: If you find yourself repeatedly performing certain tasks manually, suggest new tools or capabilities.\n\n5. **Share Complex Cases**: Challenging coding scenarios help the system improve its reasoning capabilities.\n\nBy actively engaging with the ENT CPT Code Agent and providing constructive feedback, you contribute to making it a more valuable coding resource for everyone."
                },
                {
                    "name": "installation_guide.md",
                    "content": "# ENT CPT Code Agent - Installation & Setup Guide\n\nThis guide will walk you through the installation and setup process for the ENT CPT Code Agent system.\n\n## 1. Prerequisites\n\nBefore starting, ensure you have the following installed:\n\n- **Python 3.8+**: Required for running the application\n- **pip**: Python package manager\n- **LM Studio**: Required for running the language models locally\n- **Excel**: For viewing/editing the CPT codes database\n\n## 2. Installation\n\n### 2.1 Clone the Repository\n\n```bash\ngit clone https://github.com/your-organization/ent-cpt-agent.git\ncd ent-cpt-agent\n```\n\n### 2.2 Create a Virtual Environment\n\n```bash\n# Create a virtual environment\npython -m venv venv\n\n# Activate the virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n```\n\n### 2.3 Install Dependencies\n\n```bash\npip install -r requirements.txt\n```\n\nThe `requirements.txt` file should include:\n\n```\nlmstudio\npandas\nopenpyxl\nflask\nfastapi\nuvicorn\nrequests\npython-dotenv\nlogging\nargparse\n```\n\n## 3. Configuration\n\n### 3.1 Initialize Default Configuration\n\n```bash\npython main-app.py init\n```\n\nThis will create a default `config.json` file with the following structure:\n\n```json\n{\n  \"model\": {\n    \"name\": \"qwen2.5-7b-instruct\",\n    \"temperature\": 0.2,\n    \"max_tokens\": 1024,\n    \"context_length\": 8192\n  },\n  \"cpt_database\": {\n    \"file_path\": \"CPT codes for ENT.xlsx\",\n    \"sheet_name\": \"Sheet1\"\n  },\n  \"agent\": {\n    \"log_level\": \"INFO\",\n    \"save_conversations\": true,\n    \"conversation_dir\": \"conversations\"\n  },\n  \"server\": {\n    \"host\": \"localhost\",\n    \"port\": 8000,\n    \"enable_api\": false\n  }\n}\n```\n\n### 3.2 Prepare the CPT Codes Database\n\n1. Ensure that the `CPT codes for ENT.xlsx` file is in the root directory\n2. The Excel file should have the following columns:\n   - CPT Code\n   - Description\n   - Category\n   - Related Codes (comma-separated)\n\n### 3.3 Set Up LM Studio\n\n1. Install and launch LM Studio\n2. Download the recommended model (default: qwen2.5-7b-instruct)\n3. Ensure LM Studio's Python SDK is properly installed:\n   \n   ```bash\n   pip install lmstudio\n   ```\n\n4. Set up LM Studio to run in server mode:\n   \n   ```bash\n   lms server start\n   ```\n\n## 4. Running the Application\n\n### 4.1 Interactive Mode\n\nRun the application in interactive command-line mode:\n\n```bash\npython main-app.py interactive\n```\n\nThis will start an interactive session where you can ask questions about ENT procedures and CPT codes.\n\n### 4.2 API Server Mode\n\nRun the application as an API server:\n\n```bash\npython main-app.py server --host localhost --port 8000\n```\n\nThis will start the API server on the specified host and port.\n\n### 4.3 Web UI Mode\n\nRun the web UI application:\n\n```bash\n# Set environment variables for API connection\nexport API_HOST=localhost\nexport API_PORT=8000\nexport WEB_PORT=5000\nexport DEBUG=False\n\n# Run the web UI\npython web_ui.py\n```\n\nThen open your web browser and navigate to `http://localhost:5000` to access the web UI.\n\n### 4.4 Single Query Mode\n\nProcess a single query and exit:\n\n```bash\npython main.py query \"What is the CPT code for tympanostomy tube insertion?\"\n```\n\n## 5. Advanced Configuration\n\n### 5.1 Changing the Language Model\n\nYou can change the LM Studio model used by the agent in the `config.json` file:\n\n```json\n{\n  \"model\": {\n    \"name\": \"llama-3.1-8b-instruct\",\n    \"temperature\": 0.2,\n    \"max_tokens\": 1024\n  }\n}\n```\n\nEnsure that the model is downloaded and available in LM Studio.\n\n### 5.2 Logging Configuration\n\nYou can adjust the logging level in the `config.json` file:\n\n```json\n{\n  \"agent\": {\n    \"log_level\": \"DEBUG\"\n  }\n}\n```\n\nAvailable logging levels: DEBUG, INFO, WARNING, ERROR, CRITICAL\n\n### 5.3 Conversation Storage\n\nBy default, conversations are stored in the `conversations` directory. You can change this in the `config.json` file:\n\n```json\n{\n  \"agent\": {\n    \"save_conversations\": true,\n    \"conversation_dir\": \"custom_conversations_dir\"\n  }\n}\n```\n\n## 6. API Documentation\n\nWhen running in server mode, the API documentation is available at:\n\n- OpenAPI UI: `http://localhost:8000/docs`\n- ReDoc UI: `http://localhost:8000/redoc`\n\n### 6.1 API Endpoints\n\n- `POST /api/query`: Submit a query to the agent\n- `POST /api/search`: Search for CPT codes\n- `POST /api/validate`: Validate a CPT code\n- `POST /api/analyze`: Analyze a procedure description\n- `GET /api/conversations`: List all conversations\n- `GET /api/conversations/{session_id}`: Get a specific conversation\n- `DELETE /api/conversations/{session_id}`: Delete a specific conversation\n\n## 7. Troubleshooting\n\n### 7.1 Common Issues\n\n#### LM Studio Connection Issues\n\nIf you encounter issues connecting to LM Studio:\n\n1. Ensure LM Studio is running in server mode: `lms server start`\n2. Check the logs for any error messages: `lms log stream`\n3. Verify the model is properly loaded in LM Studio\n\n#### CPT Database Issues\n\nIf you encounter issues with the CPT database:\n\n1. Ensure the `CPT codes for ENT.xlsx` file is in the correct location\n2. Verify the Excel file has the required columns\n3. Check for any error messages in the logs\n\n#### API Connection Issues\n\nIf the web UI cannot connect to the API:\n\n1. Ensure the API server is running: `python main.py server`\n2. Verify the API host and port settings are correct\n3. Check for any firewall issues that might block the connection\n\n### 7.2 Logs\n\nLogs are saved to `ent_cpt_agent.log` by default. You can check this file for detailed error messages and debugging information.\n\n## 8. Contributing\n\nWe welcome contributions to improve the ENT CPT Code Agent. Please follow these steps:\n\n1. Fork the repository\n2. Create a feature branch\n3. Make your changes\n4. Submit a pull request\n\n## 9. License\n\nThis project is licensed under the MIT License - see the LICENSE file for details.\n"
                }
            ]
        },
        {
            "name": "conversations",
            "files": []
        },
        {
            "name": "scripts",
            "files": [
                {
                    "name": "install.sh",
                    "content": "#!/bin/bash\n# Installation script for ENT CPT Code Agent\n\n# Exit on error\nset -e\n\necho \"Installing ENT CPT Code Agent...\"\n\n# Create virtual environment if it doesn't exist\nif [ ! -d \"venv\" ]; then\n    echo \"Creating virtual environment...\"\n    python -m venv venv\nfi\n\n# Activate virtual environment\nif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"win32\" ]]; then\n    # Windows\n    source venv/Scripts/activate\nelse\n    # Unix-like\n    source venv/bin/activate\nfi\n\n# Install dependencies\necho \"Installing dependencies...\"\npip install -r requirements.txt\n\n# Initialize default configuration if it doesn't exist\nif [ ! -f \"config.json\" ]; then\n    echo \"Initializing default configuration...\"\n    python main.py init\nfi\n\n# Create required directories\necho \"Creating required directories...\"\nmkdir -p data conversations\n\n# Check if CPT codes database exists\nif [ ! -f \"data/CPT codes for ENT.xlsx\" ]; then\n    echo \"WARNING: CPT codes database file not found at 'data/CPT codes for ENT.xlsx'\"\n    echo \"Please add the database file before running the application.\"\nfi\n\n# Install package in development mode\necho \"Installing package in development mode...\"\npip install -e .\n\necho \"Installation complete!\"\necho \"\"\necho \"To start the interactive mode, run: python main.py interactive\"\necho \"To start the API server, run: python main.py server\"\necho \"To start the web UI, run: python web_ui.py\""
                },
                {
                    "name": "run_server.sh",
                    "content": "#!/bin/bash\n# Script to run the ENT CPT Code Agent API and Web UI servers\n\n# Exit on error\nset -e\n\n# Default ports\nAPI_PORT=8000\nWEB_PORT=5000\nHOST=\"localhost\"\nDEBUG=false\n\n# Process command line arguments\nwhile [[ $# -gt 0 ]]; do\n    key=\"$1\"\n    case $key in\n        --api-port)\n        API_PORT=\"$2\"\n        shift\n        shift\n        ;;\n        --web-port)\n        WEB_PORT=\"$2\"\n        shift\n        shift\n        ;;\n        --host)\n        HOST=\"$2\"\n        shift\n        shift\n        ;;\n        --debug)\n        DEBUG=true\n        shift\n        ;;\n        *)\n        echo \"Unknown option: $key\"\n        echo \"Usage: $0 [--api-port PORT] [--web-port PORT] [--host HOST] [--debug]\"\n        exit 1\n        ;;\n    esac\ndone\n\n# Activate virtual environment\nif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"win32\" ]]; then\n    # Windows\n    source venv/Scripts/activate\nelse\n    # Unix-like\n    source venv/bin/activate\nfi\n\n# Start API server in the background\necho \"Starting API server on $HOST:$API_PORT...\"\npython main.py server --host $HOST --port $API_PORT &\nAPI_PID=$!\n\n# Wait for API server to start\necho \"Waiting for API server to start...\"\nsleep 3\n\n# Start Web UI server\necho \"Starting Web UI on $HOST:$WEB_PORT...\"\nexport API_HOST=$HOST\nexport API_PORT=$API_PORT\nexport WEB_PORT=$WEB_PORT\nexport DEBUG=$DEBUG\npython web_ui.py\n\n# Clean up when Web UI is terminated\nkill $API_PID"
                }
            ]
        },
        {
            "name": "data",
            "files": [
                {
                    "name": "CPT codes for ENT.xlsx",
                    "content": "Error reading file: 'utf-8' codec can't decode bytes in position 15-16: invalid continuation byte"
                }
            ]
        },
        {
            "name": "src",
            "files": [
                {
                    "name": "__init__.py",
                    "content": "\"\"\"\nENT CPT Code Agent package.\nAn AI-powered assistant for ENT CPT code selection and validation.\n\"\"\"\n\n__version__ = '1.0.0'"
                },
                {
                    "name": "main.py",
                    "content": "\"\"\"\nMain module for the ENT CPT Code Agent.\nContains the main functionality for the CLI application.\n\"\"\"\n\nimport argparse\nimport logging\nimport os\nimport sys\nfrom typing import Dict, Any\n\nfrom .config.agent_config import AgentConfig, setup_logging\nfrom .conversation.conversation_manager import ConversationManager\nfrom .agent.ent_cpt_agent import ENTCPTAgent\nfrom .api.api_interface import APIInterface\n\ndef parse_arguments():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"ENT CPT Code Agent - An AI assistant for ENT procedure coding\"\n    )\n    \n    # General arguments\n    parser.add_argument(\n        \"--config\", \n        type=str, \n        default=\"config.json\",\n        help=\"Path to configuration file\"\n    )\n    parser.add_argument(\n        \"--log-level\", \n        type=str, \n        choices=[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"],\n        default=None,\n        help=\"Logging level (overrides config file)\"\n    )\n    \n    # Subcommands\n    subparsers = parser.add_subparsers(dest=\"command\", help=\"Command to run\")\n    \n    # Interactive mode\n    interactive_parser = subparsers.add_parser(\n        \"interactive\", \n        help=\"Run in interactive command-line mode\"\n    )\n    \n    # Server mode\n    server_parser = subparsers.add_parser(\n        \"server\", \n        help=\"Run as an API server\"\n    )\n    server_parser.add_argument(\n        \"--host\", \n        type=str, \n        default=None,\n        help=\"Host to run the server on (overrides config file)\"\n    )\n    server_parser.add_argument(\n        \"--port\", \n        type=int, \n        default=None,\n        help=\"Port to run the server on (overrides config file)\"\n    )\n    \n    # Single query mode\n    query_parser = subparsers.add_parser(\n        \"query\", \n        help=\"Process a single query and exit\"\n    )\n    query_parser.add_argument(\n        \"text\", \n        type=str,\n        help=\"Query text to process\"\n    )\n    \n    # Initialize config\n    init_parser = subparsers.add_parser(\n        \"init\", \n        help=\"Initialize default configuration file\"\n    )\n    \n    return parser.parse_args()\n\ndef run_interactive_mode(agent: ENTCPTAgent):\n    \"\"\"Run the agent in interactive CLI mode.\"\"\"\n    agent.run_interactive_session()\n\ndef run_server_mode(agent: ENTCPTAgent, config: AgentConfig, host: str = None, port: int = None):\n    \"\"\"Run the agent as an API server.\"\"\"\n    # Use provided host/port or get from config\n    host = host or config.get(\"server\", \"host\")\n    port = port or config.get(\"server\", \"port\")\n    \n    # Create and start API server\n    api = APIInterface(agent, config, host, port)\n    api.start()\n\ndef run_single_query(agent: ENTCPTAgent, query: str):\n    \"\"\"Process a single query and print the result.\"\"\"\n    response = agent.process_query(query)\n    print(response)\n\ndef main():\n    \"\"\"Main entry point for the application.\"\"\"\n    # Parse command line arguments\n    args = parse_arguments()\n    \n    # Initialize configuration\n    config = AgentConfig(args.config)\n    \n    # Handle 'init' command first\n    if args.command == \"init\":\n        config.create_default_config()\n        print(f\"Initialized default configuration at {args.config}\")\n        return\n    \n    # Override config with command line arguments if provided\n    if args.log_level:\n        config.set(\"agent\", \"log_level\", args.log_level)\n    \n    # Setup logging\n    setup_logging(config)\n    logger = logging.getLogger(\"ent_cpt_agent.main\")\n    \n    try:\n        # Initialize conversation manager\n        conversation_manager = ConversationManager(\n            config.get(\"agent\", \"conversation_dir\")\n        )\n        \n        # Initialize the agent\n        logger.info(\"Initializing ENT CPT Agent\")\n        agent = ENTCPTAgent(config, conversation_manager)\n        \n        # Run the appropriate command\n        if args.command == \"interactive\":\n            logger.info(\"Starting interactive session\")\n            run_interactive_mode(agent)\n        \n        elif args.command == \"server\":\n            logger.info(\"Starting API server\")\n            # Override config with command line arguments if provided\n            host = args.host or config.get(\"server\", \"host\")\n            port = args.port or config.get(\"server\", \"port\")\n            run_server_mode(agent, config, host, port)\n        \n        elif args.command == \"query\":\n            logger.info(f\"Processing single query: {args.text}\")\n            run_single_query(agent, args.text)\n        \n        else:\n            # No command specified, default to interactive mode\n            logger.info(\"No command specified, starting interactive session\")\n            run_interactive_mode(agent)\n    \n    except KeyboardInterrupt:\n        logger.info(\"Application terminated by user\")\n    except Exception as e:\n        logger.error(f\"Error running application: {e}\", exc_info=True)\n        return 1\n    \n    return 0\n"
                }
            ]
        },
        {
            "name": "src/config",
            "files": [
                {
                    "name": "__init__.py",
                    "content": "\"\"\"\nConfiguration module for the ENT CPT Code Agent.\nHandles loading, saving, and accessing configuration settings.\n\"\"\"\n\nfrom .agent_config import AgentConfig, setup_logging\n\n__all__ = ['AgentConfig', 'setup_logging']"
                },
                {
                    "name": "agent_config.py",
                    "content": "import json\nimport os\nfrom typing import Dict, Any, Optional\nimport logging\n\nlogger = logging.getLogger(\"ent_cpt_agent.config\")\n\nclass AgentConfig:\n    \"\"\"\n    Configuration manager for the ENT CPT Code Agent.\n    Handles loading, saving, and accessing configuration settings.\n    \"\"\"\n    \n    DEFAULT_CONFIG = {\n        \"model\": {\n            \"name\": \"qwen2.5-7b-instruct\",\n            \"temperature\": 0.2,\n            \"max_tokens\": 1024,\n            \"context_length\": 8192\n        },\n        \"cpt_database\": {\n            \"file_path\": \"CPT codes for ENT.xlsx\",\n            \"sheet_name\": \"Sheet1\"\n        },\n        \"agent\": {\n            \"log_level\": \"INFO\",\n            \"save_conversations\": True,\n            \"conversation_dir\": \"conversations\"\n        },\n        \"server\": {\n            \"host\": \"localhost\",\n            \"port\": 8000,\n            \"enable_api\": False\n        }\n    }\n    \n    def __init__(self, config_path: Optional[str] = \"config.json\"):\n        \"\"\"\n        Initialize the configuration manager.\n        \n        Args:\n            config_path: Path to the configuration file (default: \"config.json\")\n        \"\"\"\n        self.config_path = config_path\n        self.config = self.DEFAULT_CONFIG.copy()\n        self.load_config()\n    \n    def load_config(self) -> None:\n        \"\"\"Load configuration from file if it exists.\"\"\"\n        if not self.config_path or not os.path.exists(self.config_path):\n            logger.info(f\"Config file not found at {self.config_path}, using defaults\")\n            return\n        \n        try:\n            with open(self.config_path, 'r') as f:\n                loaded_config = json.load(f)\n                \n            # Update the default config with loaded values\n            self._update_nested_dict(self.config, loaded_config)\n            logger.info(f\"Loaded configuration from {self.config_path}\")\n        except Exception as e:\n            logger.error(f\"Error loading config file: {e}\")\n    \n    def _update_nested_dict(self, d: Dict[str, Any], u: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Update a nested dictionary with values from another dictionary.\n        \n        Args:\n            d: Target dictionary to update\n            u: Source dictionary with new values\n            \n        Returns:\n            Updated dictionary\n        \"\"\"\n        for k, v in u.items():\n            if isinstance(v, dict) and k in d and isinstance(d[k], dict):\n                self._update_nested_dict(d[k], v)\n            else:\n                d[k] = v\n        return d\n    \n    def save_config(self) -> None:\n        \"\"\"Save the current configuration to file.\"\"\"\n        if not self.config_path:\n            logger.warning(\"No config path specified, cannot save configuration\")\n            return\n        \n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(self.config_path)), exist_ok=True)\n            \n            with open(self.config_path, 'w') as f:\n                json.dump(self.config, f, indent=2)\n            \n            logger.info(f\"Saved configuration to {self.config_path}\")\n        except Exception as e:\n            logger.error(f\"Error saving config file: {e}\")\n    \n    def get(self, section: str, key: Optional[str] = None) -> Any:\n        \"\"\"\n        Get a configuration value.\n        \n        Args:\n            section: Configuration section (e.g., \"model\", \"agent\")\n            key: Specific key within the section (optional)\n            \n        Returns:\n            Configuration value or section dictionary\n        \"\"\"\n        if section not in self.config:\n            return None\n        \n        if key is None:\n            return self.config[section]\n        \n        return self.config[section].get(key)\n    \n    def set(self, section: str, key: str, value: Any) -> None:\n        \"\"\"\n        Set a configuration value.\n        \n        Args:\n            section: Configuration section (e.g., \"model\", \"agent\")\n            key: Specific key within the section\n            value: Value to set\n        \"\"\"\n        if section not in self.config:\n            self.config[section] = {}\n        \n        self.config[section][key] = value\n    \n    def create_default_config(self) -> None:\n        \"\"\"Create a default configuration file if it doesn't exist.\"\"\"\n        if not self.config_path:\n            logger.warning(\"No config path specified, cannot create default configuration\")\n            return\n        \n        if os.path.exists(self.config_path):\n            logger.info(f\"Config file already exists at {self.config_path}\")\n            return\n        \n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(os.path.abspath(self.config_path)), exist_ok=True)\n            \n            with open(self.config_path, 'w') as f:\n                json.dump(self.DEFAULT_CONFIG, f, indent=2)\n            \n            logger.info(f\"Created default configuration at {self.config_path}\")\n        except Exception as e:\n            logger.error(f\"Error creating default config file: {e}\")\n\n\ndef setup_logging(config: AgentConfig) -> None:\n    \"\"\"\n    Set up logging based on configuration.\n    \n    Args:\n        config: Agent configuration object\n    \"\"\"\n    log_level_name = config.get(\"agent\", \"log_level\")\n    log_level = getattr(logging, log_level_name, logging.INFO)\n    \n    logging.basicConfig(\n        level=log_level,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n        handlers=[\n            logging.StreamHandler(),\n            logging.FileHandler(\"ent_cpt_agent.log\")\n        ]\n    )"
                }
            ]
        },
        {
            "name": "src/web",
            "files": [
                {
                    "name": "__init__.py",
                    "content": "\"\"\"\nWeb module for the ENT CPT Code Agent.\nProvides a web-based user interface for interacting with the agent.\n\"\"\"\n__all__ = []"
                },
                {
                    "name": "web_ui.py",
                    "content": "#!/usr/bin/env python3\n\"\"\"\nWeb UI server for the ENT CPT Code Agent.\nThis script starts the web interface server for the ENT CPT Code Agent.\n\"\"\"\n\nimport os\nimport logging\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(\"ent_cpt_agent_web_ui\")\n\nif __name__ == \"__main__\":\n    try:\n        # Get port from environment variable or use default\n        port = int(os.environ.get(\"WEB_PORT\", \"5000\"))\n        host = os.environ.get(\"WEB_HOST\", \"0.0.0.0\")\n        debug = os.environ.get(\"DEBUG\", \"False\").lower() == \"true\"\n        \n        logger.info(f\"Starting web UI server on {host}:{port} (debug={debug})\")\n        \n        # Start the Flask application\n        app.run(host=host, port=port, debug=debug)\n    except Exception as e:\n        logger.error(f\"Error starting web UI server: {e}\")\n        exit(1)"
                }
            ]
        },
        {
            "name": "src/web/templates",
            "files": [
                {
                    "name": "index.html",
                    "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>ENT CPT Code Assistant</title>\n    <!-- Bootstrap CSS -->\n    <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    <!-- Font Awesome -->\n    <link href=\"https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css\" rel=\"stylesheet\">\n    <style>\n        body {\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\n            background-color: #f8f9fa;\n            padding-top: 20px;\n        }\n        .chat-container {\n            height: 500px;\n            overflow-y: auto;\n            border: 1px solid #dee2e6;\n            border-radius: 0.375rem;\n            background-color: white;\n            padding: 1rem;\n            margin-bottom: 1rem;\n        }\n        .user-message {\n            background-color: #f0f7ff;\n            border-radius: 15px 15px 0 15px;\n            padding: 10px 15px;\n            margin-bottom: 10px;\n            max-width: 80%;\n            align-self: flex-end;\n            margin-left: auto;\n        }\n        .assistant-message {\n            background-color: #f1f3f4;\n            border-radius: 15px 15px 15px 0;\n            padding: 10px 15px;\n            margin-bottom: 10px;\n            max-width: 80%;\n        }\n        .code-pill {\n            background-color: #e7f2fa;\n            color: #1a73e8;\n            border: 1px solid #c2e0f4;\n            border-radius: 16px;\n            padding: 4px 12px;\n            font-size: 0.8rem;\n            font-weight: 500;\n            margin-right: 5px;\n            margin-bottom: 5px;\n            display: inline-block;\n            cursor: pointer;\n        }\n        .code-pill:hover {\n            background-color: #d3e7f8;\n        }\n        .message-time {\n            font-size: 0.7rem;\n            color: #6c757d;\n            margin-top: 5px;\n            text-align: right;\n        }\n        .message-container {\n            display: flex;\n            flex-direction: column;\n            margin-bottom: 15px;\n        }\n        .spinner-border {\n            width: 1.5rem;\n            height: 1.5rem;\n        }\n        .tools-container {\n            background-color: #fff;\n            border: 1px solid #dee2e6;\n            border-radius: 0.375rem;\n            padding: 1rem;\n            margin-bottom: 1rem;\n        }\n        .session-info {\n            font-size: 0.8rem;\n            color: #6c757d;\n            margin-bottom: 10px;\n        }\n        .loading-message {\n            display: flex;\n            align-items: center;\n            font-style: italic;\n            color: #6c757d;\n        }\n        .nav-tabs .nav-link {\n            color: #495057;\n        }\n        .nav-tabs .nav-link.active {\n            font-weight: 500;\n        }\n        .tooltip-inner {\n            max-width: 300px;\n        }\n        #codesList {\n            margin-top: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"container\">\n        <div class=\"row mb-4\">\n            <div class=\"col-12\">\n                <h1 class=\"text-center mb-3\">ENT CPT Code Assistant</h1>\n                <p class=\"text-center text-muted\">Intelligent coding assistance for ENT procedures</p>\n            </div>\n        </div>\n\n        <div class=\"row\">\n            <!-- Main Chat Area -->\n            <div class=\"col-lg-8\">\n                <div class=\"session-info\">\n                    Session ID: <span id=\"sessionId\">{{ session_id }}</span>\n                    <button id=\"newSessionBtn\" class=\"btn btn-sm btn-outline-secondary ms-2\">\n                        <i class=\"fas fa-plus-circle\"></i> New Session\n                    </button>\n                </div>\n                \n                <div class=\"chat-container\" id=\"chatContainer\">\n                    <!-- Messages will appear here -->\n                    <div class=\"message-container\">\n                        <div class=\"assistant-message\">\n                            Hello! I'm your ENT CPT Code Assistant. I can help you find the right CPT codes for ENT procedures. How can I help you today?\n                        </div>\n                        <div class=\"message-time\">\n                            Today, <span id=\"currentTime\"></span>\n                        </div>\n                    </div>\n                </div>\n                \n                <form id=\"queryForm\" class=\"mb-4\">\n                    <div class=\"input-group\">\n                        <input type=\"text\" id=\"queryInput\" class=\"form-control\" placeholder=\"Describe the ENT procedure or ask a question...\" required>\n                        <button class=\"btn btn-primary\" type=\"submit\">\n                            <i class=\"fas fa-paper-plane\"></i> Send\n                        </button>\n                    </div>\n                </form>\n            </div>\n            \n            <!-- Tools Panel -->\n            <div class=\"col-lg-4\">\n                <div class=\"tools-container\">\n                    <ul class=\"nav nav-tabs\" id=\"toolsTabs\" role=\"tablist\">\n                        <li class=\"nav-item\" role=\"presentation\">\n                            <button class=\"nav-link active\" id=\"search-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#search\" type=\"button\" role=\"tab\" aria-controls=\"search\" aria-selected=\"true\">Search</button>\n                        </li>\n                        <li class=\"nav-item\" role=\"presentation\">\n                            <button class=\"nav-link\" id=\"validate-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#validate\" type=\"button\" role=\"tab\" aria-controls=\"validate\" aria-selected=\"false\">Validate</button>\n                        </li>\n                        <li class=\"nav-item\" role=\"presentation\">\n                            <button class=\"nav-link\" id=\"analyze-tab\" data-bs-toggle=\"tab\" data-bs-target=\"#analyze\" type=\"button\" role=\"tab\" aria-controls=\"analyze\" aria-selected=\"false\">Analyze</button>\n                        </li>\n                    </ul>\n                    \n                    <div class=\"tab-content p-3\" id=\"toolsTabContent\">\n                        <!-- Search Tab -->\n                        <div class=\"tab-pane fade show active\" id=\"search\" role=\"tabpanel\" aria-labelledby=\"search-tab\">\n                            <form id=\"searchForm\">\n                                <div class=\"mb-3\">\n                                    <label for=\"searchTerm\" class=\"form-label\">Search CPT Codes</label>\n                                    <div class=\"input-group\">\n                                        <input type=\"text\" class=\"form-control\" id=\"searchTerm\" placeholder=\"Enter keywords...\" required>\n                                        <button class=\"btn btn-outline-primary\" type=\"submit\">\n                                            <i class=\"fas fa-search\"></i> Search\n                                        </button>\n                                    </div>\n                                    <div class=\"form-text\">Search for CPT codes by keyword or description</div>\n                                </div>\n                            </form>\n                            <div id=\"searchResults\" class=\"mt-3\"></div>\n                        </div>\n                        \n                        <!-- Validate Tab -->\n                        <div class=\"tab-pane fade\" id=\"validate\" role=\"tabpanel\" aria-labelledby=\"validate-tab\">\n                            <form id=\"validateForm\">\n                                <div class=\"mb-3\">\n                                    <label for=\"codeToValidate\" class=\"form-label\">Validate CPT Code</label>\n                                    <div class=\"input-group\">\n                                        <input type=\"text\" class=\"form-control\" id=\"codeToValidate\" placeholder=\"Enter CPT code...\" pattern=\"\\d{5}\" required>\n                                        <button class=\"btn btn-outline-primary\" type=\"submit\">\n                                            <i class=\"fas fa-check-circle\"></i> Validate\n                                        </button>\n                                    </div>\n                                    <div class=\"form-text\">Enter a 5-digit CPT code to validate</div>\n                                </div>\n                            </form>\n                            <div id=\"validateResults\" class=\"mt-3\"></div>\n                        </div>\n                        \n                        <!-- Analyze Tab -->\n                        <div class=\"tab-pane fade\" id=\"analyze\" role=\"tabpanel\" aria-labelledby=\"analyze-tab\">\n                            <form id=\"analyzeForm\">\n                                <div class=\"mb-3\">\n                                    <label for=\"procedureText\" class=\"form-label\">Analyze Procedure</label>\n                                    <textarea class=\"form-control\" id=\"procedureText\" rows=\"3\" placeholder=\"Describe the ENT procedure in detail...\" required></textarea>\n                                </div>\n                                <div class=\"mb-3\">\n                                    <label for=\"candidateCodes\" class=\"form-label\">Candidate Codes (Optional)</label>\n                                    <input type=\"text\" class=\"form-control\" id=\"candidateCodes\" placeholder=\"Comma-separated CPT codes, e.g., 69436,69450\">\n                                    <div class=\"form-text\">If you have specific codes in mind, enter them here</div>\n                                </div>\n                                <button type=\"submit\" class=\"btn btn-outline-primary\">\n                                    <i class=\"fas fa-microscope\"></i> Analyze Procedure\n                                </button>\n                            </form>\n                            <div id=\"analyzeResults\" class=\"mt-3\"></div>\n                        </div>\n                    </div>\n                </div>\n                \n                <!-- Detected Codes Panel -->\n                <div class=\"tools-container\">\n                    <h5><i class=\"fas fa-tags\"></i> Detected CPT Codes</h5>\n                    <p class=\"small text-muted\">Codes detected in the conversation</p>\n                    <div id=\"codesList\">\n                        <p class=\"text-muted fst-italic\">No codes detected yet</p>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n    \n    <!-- Bootstrap Bundle with Popper -->\n    <script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js\"></script>\n    <!-- jQuery -->\n    <script src=\"https://code.jquery.com/jquery-3.6.0.min.js\"></script>\n    \n    <script>\n        $(document).ready(function() {\n            // Initialize tooltips\n            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'))\n            var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {\n                return new bootstrap.Tooltip(tooltipTriggerEl)\n            });\n            \n            // Set current time\n            const now = new Date();\n            $('#currentTime').text(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));\n            \n            // Scroll to bottom of chat\n            function scrollToBottom() {\n                const chatContainer = document.getElementById('chatContainer');\n                chatContainer.scrollTop = chatContainer.scrollHeight;\n            }\n            \n            // Format timestamp\n            function formatTime(timestamp) {\n                const date = new Date(timestamp);\n                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\n            }\n            \n            // Add message to chat\n            function addMessage(content, role, timestamp = new Date().toISOString(), codes = []) {\n                const messageClass = role === 'user' ? 'user-message' : 'assistant-message';\n                const messageContainer = $('<div class=\"message-container\"></div>');\n                const messageElement = $(`<div class=\"${messageClass}\"></div>`).text(content);\n                const timeElement = $('<div class=\"message-time\"></div>').text(`Today, ${formatTime(timestamp)}`);\n                \n                messageContainer.append(messageElement).append(timeElement);\n                $('#chatContainer').append(messageContainer);\n                \n                // If there are codes in the message, extract and display them\n                if (codes && codes.length > 0) {\n                    updateDetectedCodes(codes);\n                }\n                \n                scrollToBottom();\n            }\n            \n            // Add loading message\n            function addLoadingMessage() {\n                const loadingContainer = $('<div class=\"message-container\" id=\"loadingMessage\"></div>');\n                const loadingMessage = $('<div class=\"assistant-message loading-message\"></div>')\n                    .append('<div class=\"spinner-border text-primary me-2\" role=\"status\"><span class=\"visually-hidden\">Loading...</span></div>')\n                    .append('<span>Thinking...</span>');\n                \n                loadingContainer.append(loadingMessage);\n                $('#chatContainer').append(loadingContainer);\n                scrollToBottom();\n            }\n            \n            // Remove loading message\n            function removeLoadingMessage() {\n                $('#loadingMessage').remove();\n            }\n            \n            // Update detected codes list\n            function updateDetectedCodes(newCodes) {\n                const codesListElement = $('#codesList');\n                \n                // Clear \"no codes\" message if present\n                if (codesListElement.find('.text-muted.fst-italic').length > 0) {\n                    codesListElement.empty();\n                }\n                \n                // Add new codes\n                newCodes.forEach(code => {\n                    // Only add if not already present\n                    if (codesListElement.find(`[data-code=\"${code}\"]`).length === 0) {\n                        const codePill = $(`<div class=\"code-pill\" data-code=\"${code}\" data-bs-toggle=\"tooltip\" title=\"Click to validate this code\">${code}</div>`);\n                        codesListElement.append(codePill);\n                        \n                        // Initialize tooltip\n                        new bootstrap.Tooltip(codePill[0]);\n                        \n                        // Add click handler to validate code\n                        codePill.on('click', function() {\n                            // Set the code in the validate tab and switch to it\n                            $('#codeToValidate').val(code);\n                            $('#validate-tab').tab('show');\n                            $('#validateForm').submit();\n                        });\n                    }\n                });\n            }\n            \n            // Extract CPT codes from text\n            function extractCPTCodes(text) {\n                const pattern = /\\b\\d{5}\\b/g;\n                return text.match(pattern) || [];\n            }\n            \n            // Process query submission\n            $('#queryForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const queryInput = $('#queryInput');\n                const query = queryInput.val().trim();\n                \n                if (!query) return;\n                \n                // Add user message to chat\n                addMessage(query, 'user');\n                \n                // Clear input\n                queryInput.val('');\n                \n                // Show loading message\n                addLoadingMessage();\n                \n                // Send query to API\n                $.ajax({\n                    url: '/api/query',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        query: query,\n                        session_id: $('#sessionId').text()\n                    }),\n                    success: function(response) {\n                        // Remove loading message\n                        removeLoadingMessage();\n                        \n                        if (response.status === 'success') {\n                            // Add assistant message to chat\n                            addMessage(response.message, 'assistant', new Date().toISOString(), \n                                       response.data && response.data.codes ? response.data.codes : []);\n                            \n                            // Update session ID if provided\n                            if (response.session_id) {\n                                $('#sessionId').text(response.session_id);\n                            }\n                        } else {\n                            // Add error message\n                            addMessage(`Error: ${response.message}`, 'assistant');\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        // Remove loading message\n                        removeLoadingMessage();\n                        \n                        // Add error message\n                        addMessage(`Sorry, there was an error processing your request: ${error}`, 'assistant');\n                    }\n                });\n            });\n            \n            // Process search form submission\n            $('#searchForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const searchTerm = $('#searchTerm').val().trim();\n                \n                if (!searchTerm) return;\n                \n                const searchResults = $('#searchResults');\n                searchResults.html('<div class=\"d-flex align-items-center\"><div class=\"spinner-border text-primary me-2\" role=\"status\"></div><span>Searching...</span></div>');\n                \n                // Send search request to API\n                $.ajax({\n                    url: '/api/search',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        search_term: searchTerm\n                    }),\n                    success: function(response) {\n                        if (response.status === 'success' && response.data) {\n                            const codes = response.data.codes;\n                            if (codes && codes.length > 0) {\n                                let resultsHtml = `<div class=\"alert alert-success\">Found ${codes.length} matching CPT codes</div>`;\n                                resultsHtml += '<div class=\"list-group\">';\n                                \n                                codes.forEach(code => {\n                                    resultsHtml += `\n                                        <div class=\"list-group-item list-group-item-action\">\n                                            <div class=\"d-flex w-100 justify-content-between\">\n                                                <h6 class=\"mb-1\">Code ${code.code}</h6>\n                                                <button class=\"btn btn-sm btn-outline-primary add-to-chat\" data-code=\"${code.code}\">\n                                                    <i class=\"fas fa-plus\"></i> Add to Chat\n                                                </button>\n                                            </div>\n                                            <p class=\"mb-1\">${code.description}</p>\n                                            ${code.related_codes && code.related_codes.length > 0 ? \n                                              `<small class=\"text-muted\">Related codes: ${code.related_codes.join(', ')}</small>` : ''}\n                                        </div>\n                                    `;\n                                });\n                                \n                                resultsHtml += '</div>';\n                                searchResults.html(resultsHtml);\n                                \n                                // Add event handler for \"Add to Chat\" buttons\n                                $('.add-to-chat').on('click', function() {\n                                    const code = $(this).data('code');\n                                    $('#queryInput').val(`Tell me about CPT code ${code}`);\n                                    $('#queryForm').submit();\n                                });\n                            } else {\n                                searchResults.html('<div class=\"alert alert-warning\">No CPT codes found matching your search term.</div>');\n                            }\n                        } else {\n                            searchResults.html(`<div class=\"alert alert-danger\">Error: ${response.message || 'Unknown error'}</div>`);\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        searchResults.html(`<div class=\"alert alert-danger\">Error: ${error}</div>`);\n                    }\n                });\n            });\n            \n            // Process validate form submission\n            $('#validateForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const code = $('#codeToValidate').val().trim();\n                \n                if (!code) return;\n                \n                const validateResults = $('#validateResults');\n                validateResults.html('<div class=\"d-flex align-items-center\"><div class=\"spinner-border text-primary me-2\" role=\"status\"></div><span>Validating...</span></div>');\n                \n                // Send validate request to API\n                $.ajax({\n                    url: '/api/validate',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        code: code\n                    }),\n                    success: function(response) {\n                        if (response.status === 'success') {\n                            validateResults.html(`\n                                <div class=\"alert alert-success\">\n                                    <h6>CPT Code ${code} is valid</h6>\n                                    <p>${response.message || 'Valid CPT code'}</p>\n                                    <button class=\"btn btn-sm btn-outline-primary learn-more\" data-code=\"${code}\">\n                                        <i class=\"fas fa-info-circle\"></i> Learn More\n                                    </button>\n                                </div>\n                            `);\n                            \n                            // Add event handler for \"Learn More\" button\n                            $('.learn-more').on('click', function() {\n                                const code = $(this).data('code');\n                                $('#queryInput').val(`Explain the coding rules for CPT code ${code}`);\n                                $('#queryForm').submit();\n                            });\n                        } else {\n                            validateResults.html(`<div class=\"alert alert-danger\">Error: ${response.message || 'Invalid CPT code'}</div>`);\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        validateResults.html(`<div class=\"alert alert-danger\">Error: ${error}</div>`);\n                    }\n                });\n            });\n            \n            // Process analyze form submission\n            $('#analyzeForm').on('submit', function(e) {\n                e.preventDefault();\n                \n                const procedureText = $('#procedureText').val().trim();\n                const candidateCodesText = $('#candidateCodes').val().trim();\n                const candidateCodes = candidateCodesText ? candidateCodesText.split(',').map(code => code.trim()) : [];\n                \n                if (!procedureText) return;\n                \n                const analyzeResults = $('#analyzeResults');\n                analyzeResults.html('<div class=\"d-flex align-items-center\"><div class=\"spinner-border text-primary me-2\" role=\"status\"></div><span>Analyzing...</span></div>');\n                \n                // Send analyze request to API\n                $.ajax({\n                    url: '/api/analyze',\n                    type: 'POST',\n                    contentType: 'application/json',\n                    data: JSON.stringify({\n                        procedure_text: procedureText,\n                        candidate_codes: candidateCodes\n                    }),\n                    success: function(response) {\n                        if (response.status === 'success' && response.data) {\n                            const analysis = response.data;\n                            \n                            let resultsHtml = `<div class=\"alert alert-info\">\n                                <h6>Procedure Analysis</h6>\n                                <p class=\"small\">${analysis.procedure_text}</p>\n                            </div>`;\n                            \n                            if (analysis.recommended_codes && analysis.recommended_codes.length > 0) {\n                                resultsHtml += `<h6 class=\"mt-3\">Recommended Codes:</h6>\n                                <ul class=\"list-group mb-3\">`;\n                                \n                                analysis.recommended_codes.forEach(code => {\n                                    resultsHtml += `<li class=\"list-group-item d-flex justify-content-between align-items-center\">\n                                        ${code}\n                                        <button class=\"btn btn-sm btn-outline-primary add-to-chat\" data-code=\"${code.split('-')[0]}\">\n                                            <i class=\"fas fa-plus\"></i>\n                                        </button>\n                                    </li>`;\n                                });\n                                \n                                resultsHtml += `</ul>`;\n                                \n                                // Add explanations if available\n                                if (analysis.explanations && analysis.explanations.length > 0) {\n                                    resultsHtml += `<h6>Explanation:</h6>\n                                    <ul class=\"list-group\">`;\n                                    \n                                    analysis.explanations.forEach(explanation => {\n                                        resultsHtml += `<li class=\"list-group-item\">${explanation.message}</li>`;\n                                    });\n                                    \n                                    resultsHtml += `</ul>`;\n                                }\n                                \n                                // Add \"Add to Chat\" button for the analysis\n                                resultsHtml += `<div class=\"mt-3\">\n                                    <button class=\"btn btn-primary add-analysis-to-chat\">\n                                        <i class=\"fas fa-comment\"></i> Discuss in Chat\n                                    </button>\n                                </div>`;\n                            } else {\n                                resultsHtml += `<div class=\"alert alert-warning\">No recommended codes found for this procedure.</div>`;\n                            }\n                            \n                            analyzeResults.html(resultsHtml);\n                            \n                            // Add event handler for \"Add to Chat\" buttons\n                            $('.add-to-chat').on('click', function() {\n                                const code = $(this).data('code');\n                                $('#queryInput').val(`Tell me about CPT code ${code}`);\n                                $('#queryForm').submit();\n                            });\n                            \n                            // Add event handler for \"Discuss in Chat\" button\n                            $('.add-analysis-to-chat').on('click', function() {\n                                $('#queryInput').val(`Can you explain why you recommended ${analysis.recommended_codes.join(', ')} for this procedure: \"${procedureText}\"`);\n                                $('#queryForm').submit();\n                            });\n                        } else {\n                            analyzeResults.html(`<div class=\"alert alert-danger\">Error: ${response.message || 'Unknown error'}</div>`);\n                        }\n                    },\n                    error: function(xhr, status, error) {\n                        analyzeResults.html(`<div class=\"alert alert-danger\">Error: ${error}</div>`);\n                    }\n                });\n            });\n            \n            // New session button\n            $('#newSessionBtn').on('click', function() {\n                // Confirm before starting new session\n                if (confirm('Start a new session? This will clear the current conversation.')) {\n                    // Request new session from server\n                    $.ajax({\n                        url: '/api/new_session',\n                        type: 'POST',\n                        contentType: 'application/json',\n                        data: JSON.stringify({}),\n                        success: function(response) {\n                            if (response.status === 'success') {\n                                // Update session ID\n                                $('#sessionId').text(response.session_id);\n                                \n                                // Clear chat\n                                $('#chatContainer').empty();\n                                \n                                // Add welcome message\n                                addMessage(\"Hello! I'm your ENT CPT Code Assistant. I can help you find the right CPT codes for ENT procedures. How can I help you today?\", 'assistant');\n                                \n                                // Clear codes list\n                                $('#codesList').html('<p class=\"text-muted fst-italic\">No codes detected yet</p>');\n                            } else {\n                                alert(`Error starting new session: ${response.message}`);\n                            }\n                        },\n                        error: function(xhr, status, error) {\n                            alert(`Error starting new session: ${error}`);\n                        }\n                    });\n                }\n            });\n            \n            // Health check on page load\n            $.ajax({\n                url: '/api/health',\n                type: 'GET',\n                success: function(response) {\n                    if (response.status !== 'success') {\n                        alert(`Warning: ${response.message}`);\n                    }\n                },\n                error: function(xhr, status, error) {\n                    alert(`Error: Cannot connect to the backend API (${error}). Some features may not work.`);\n                }\n            });\n        });\n    </script>\n</body>\n</html>"
                }
            ]
        },
        {
            "name": "src/agent",
            "files": [
                {
                    "name": "ent_cpt_agent.py",
                    "content": "import os\nimport pandas as pd\nimport re\nimport lmstudio as lms\nfrom typing import List, Dict, Any, Optional, Tuple\nimport argparse\nimport logging\nimport json\nfrom pathlib import Path\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    handlers=[logging.StreamHandler()]\n)\nlogger = logging.getLogger(\"ent_cpt_agent\")\n\nclass CPTCodeDatabase:\n    \"\"\"\n    Handles loading, processing, and querying of CPT codes for ENT procedures.\n    \"\"\"\n    def __init__(self, file_path: str):\n        \"\"\"\n        Initialize the CPT code database from the provided Excel file.\n        \n        Args:\n            file_path: Path to the Excel file containing CPT codes\n        \"\"\"\n        self.file_path = file_path\n        self.df = None\n        self.code_descriptions = {}\n        self.code_categories = {}\n        self.related_codes = {}\n        self.load_data()\n    \n    def load_data(self) -> None:\n        \"\"\"Load CPT code data from Excel file and process it.\"\"\"\n        logger.info(f\"Loading CPT codes from {self.file_path}\")\n        try:\n            self.df = pd.read_excel(self.file_path)\n            \n            # Process the dataframe to create lookup dictionaries\n            for _, row in self.df.iterrows():\n                code = str(row.get('CPT Code', '')).strip()\n                if code and not pd.isna(code):\n                    # Store description\n                    self.code_descriptions[code] = row.get('Description', '')\n                    \n                    # Store category\n                    category = row.get('Category', '')\n                    if category and not pd.isna(category):\n                        if category not in self.code_categories:\n                            self.code_categories[category] = []\n                        self.code_categories[category].append(code)\n                    \n                    # Store related codes\n                    related = row.get('Related Codes', '')\n                    if related and not pd.isna(related):\n                        related_codes = [r.strip() for r in str(related).split(',')]\n                        self.related_codes[code] = related_codes\n            \n            logger.info(f\"Loaded {len(self.code_descriptions)} CPT codes\")\n        except Exception as e:\n            logger.error(f\"Error loading CPT codes: {e}\")\n            raise\n    \n    def search_codes(self, query: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Search for CPT codes based on a text query.\n        \n        Args:\n            query: Search terms for finding relevant CPT codes\n            \n        Returns:\n            List of matching CPT codes with descriptions\n        \"\"\"\n        query = query.lower()\n        results = []\n        \n        for code, description in self.code_descriptions.items():\n            if query in description.lower() or query in code:\n                results.append({\n                    \"code\": code,\n                    \"description\": description,\n                    \"related_codes\": self.related_codes.get(code, [])\n                })\n        \n        return results\n    \n    def get_code_details(self, code: str) -> Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific CPT code.\n        \n        Args:\n            code: The CPT code to look up\n            \n        Returns:\n            Dictionary containing detailed information about the code\n        \"\"\"\n        if code not in self.code_descriptions:\n            return {\"error\": f\"CPT code {code} not found\"}\n        \n        return {\n            \"code\": code,\n            \"description\": self.code_descriptions.get(code, \"\"),\n            \"related_codes\": self.related_codes.get(code, [])\n        }\n    \n    def get_codes_by_category(self, category: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get all CPT codes belonging to a specific category.\n        \n        Args:\n            category: The category to look up codes for\n            \n        Returns:\n            List of CPT codes in the specified category\n        \"\"\"\n        if category not in self.code_categories:\n            return []\n        \n        results = []\n        for code in self.code_categories[category]:\n            results.append({\n                \"code\": code,\n                \"description\": self.code_descriptions.get(code, \"\"),\n                \"related_codes\": self.related_codes.get(code, [])\n            })\n        \n        return results\n    \n    def get_code_validation(self, code: str) -> Dict[str, Any]:\n        \"\"\"\n        Validate if a CPT code exists and is valid.\n        \n        Args:\n            code: The CPT code to validate\n            \n        Returns:\n            Dictionary with validation results\n        \"\"\"\n        if code in self.code_descriptions:\n            return {\"valid\": True, \"description\": self.code_descriptions[code]}\n        else:\n            return {\"valid\": False, \"error\": f\"Invalid CPT code: {code}\"}\n\n\nclass ENTCPTAgent:\n    \"\"\"\n    Agent for processing ENT procedure queries and determining appropriate CPT codes.\n    \"\"\"\n    def __init__(self, config, conversation_manager=None):\n        \"\"\"\n        Initialize the ENT CPT Agent.\n        \n        Args:\n            config: AgentConfig object with configuration settings\n            conversation_manager: Optional ConversationManager instance\n        \"\"\"\n        self.config = config\n        \n        # Get configuration values\n        self.model_name = config.get(\"model\", \"name\")\n        self.model_temperature = config.get(\"model\", \"temperature\")\n        self.model_max_tokens = config.get(\"model\", \"max_tokens\")\n        self.cpt_db_path = config.get(\"cpt_database\", \"file_path\")\n        \n        # Initialize components\n        self.cpt_db = CPTCodeDatabase(self.cpt_db_path)\n        self.rules_engine = RulesEngine()\n        self.conversation_manager = conversation_manager or ConversationManager(\n            config.get(\"agent\", \"conversation_dir\")\n        )\n        \n        # Initialize LM Studio model\n        self.model = None\n        self.system_prompt = self._create_system_prompt()\n        self.initialize_model()\n    \n    def _create_system_prompt(self) -> str:\n        \"\"\"\n        Create the system prompt for the agent.\n        \n        Returns:\n            System prompt string\n        \"\"\"\n        return \"\"\"\n        You are an expert ENT (Ear, Nose, Throat) medical coding assistant specialized in CPT codes. \n        Your goal is to help medical professionals find the correct CPT codes for ENT procedures.\n        \n        You have access to the following tools:\n        1. search_cpt_codes: Search for CPT codes based on a procedure description\n        2. validate_cpt_code: Validate if a CPT code exists and is correct\n        3. get_category_codes: Get all CPT codes for a specific ENT category\n        4. explain_coding_rules: Explain the rules for using a specific CPT code\n        5. analyze_procedure: Analyze a procedure description to determine appropriate CPT codes\n        \n        When recommending CPT codes:\n        - Always verify that the procedure description matches the code exactly\n        - Check for any modifiers that may be needed (e.g., bilateral procedures)\n        - Explain why you're recommending specific codes\n        - Consider bundling rules and related codes\n        - Format CPT codes clearly using the format: XXXXX (description)\n        \n        Always provide educational explanations of your reasoning process so\n        medical professionals can learn the correct coding principles.\n        \"\"\"\n    \n    def initialize_model(self) -> None:\n        \"\"\"Initialize the LM Studio model.\"\"\"\n        logger.info(f\"Initializing LM Studio model: {self.model_name}\")\n        try:\n            # Configure model with parameters from config\n            self.model = lms.llm(self.model_name, config={\n                \"temperature\": self.model_temperature,\n                \"maxTokens\": self.model_max_tokens\n            })\n            logger.info(\"Model initialized successfully\")\n        except Exception as e:\n            logger.error(f\"Error initializing model: {e}\")\n            raise\n    \n    def search_cpt_codes(self, query: str) -> str:\n        \"\"\"\n        Tool function: Search for CPT codes based on a procedure description.\n        \n        Args:\n            query: The procedure or keywords to search for\n            \n        Returns:\n            Formatted search results as a string\n        \"\"\"\n        results = self.cpt_db.search_codes(query)\n        if not results:\n            return f\"No CPT codes found matching '{query}'\"\n        \n        response = f\"Found {len(results)} CPT codes matching '{query}':\\n\\n\"\n        for idx, result in enumerate(results, 1):\n            response += f\"{idx}. Code {result['code']}: {result['description']}\\n\"\n            if result['related_codes']:\n                response += f\"   Related codes: {', '.join(result['related_codes'])}\\n\"\n        \n        return response\n    \n    def validate_cpt_code(self, code: str) -> str:\n        \"\"\"\n        Tool function: Validate if a CPT code exists and is correct.\n        \n        Args:\n            code: The CPT code to validate\n            \n        Returns:\n            Validation result as a string\n        \"\"\"\n        result = self.cpt_db.get_code_validation(code)\n        if result[\"valid\"]:\n            return f\"CPT code {code} is valid: {result['description']}\"\n        else:\n            return result[\"error\"]\n    \n    def get_category_codes(self, category: str) -> str:\n        \"\"\"\n        Tool function: Get all CPT codes for a specific ENT category.\n        \n        Args:\n            category: The ENT category to get codes for\n            \n        Returns:\n            List of codes in the category as a formatted string\n        \"\"\"\n        results = self.cpt_db.get_codes_by_category(category)\n        if not results:\n            return f\"No CPT codes found for category '{category}'\"\n        \n        response = f\"CPT codes for category '{category}':\\n\\n\"\n        for idx, result in enumerate(results, 1):\n            response += f\"{idx}. Code {result['code']}: {result['description']}\\n\"\n        \n        return response\n    \n    def explain_coding_rules(self, code: str) -> str:\n        \"\"\"\n        Tool function: Explain the rules for using a specific CPT code.\n        \n        Args:\n            code: The CPT code to explain rules for\n            \n        Returns:\n            Explanation of coding rules as a string\n        \"\"\"\n        # First get the code details\n        result = self.cpt_db.get_code_details(code)\n        if \"error\" in result:\n            return result[\"error\"]\n        \n        # Basic code information\n        response = f\"Coding guidelines for CPT {code}:\\n\\n\"\n        response += f\"Description: {result['description']}\\n\\n\"\n        \n        # Get coding tips from rules engine\n        tips = self.rules_engine.get_coding_tips(code, result['description'])\n        \n        response += \"Coding guidelines:\\n\"\n        for idx, tip in enumerate(tips, 1):\n            response += f\"{idx}. {tip}\\n\"\n        \n        # Add information about related codes\n        if result['related_codes']:\n            response += f\"\\nRelated codes to consider: {', '.join(result['related_codes'])}\\n\"\n            response += \"\\nAlways check if one of these related codes may be more appropriate based on specific procedure details.\"\n        \n        return response\n    \n    def analyze_procedure(self, procedure_text: str) -> str:\n        \"\"\"\n        Tool function: Analyze a procedure description to determine appropriate CPT codes.\n        \n        Args:\n            procedure_text: Description of the ENT procedure\n            \n        Returns:\n            Analysis results as a formatted string\n        \"\"\"\n        # Search for potential codes\n        search_results = self.cpt_db.search_codes(procedure_text)\n        candidate_codes = [result[\"code\"] for result in search_results]\n        \n        if not candidate_codes:\n            return f\"No potential CPT codes found for this procedure description. Please provide more details about the procedure.\"\n        \n        # Analyze with rules engine\n        analysis = self.rules_engine.analyze_procedure(\n            procedure_text, candidate_codes, self.cpt_db)\n        \n        if analysis[\"status\"] != \"success\":\n            return f\"Error analyzing procedure: {analysis.get('message', 'Unknown error')}\"\n        \n        # Format the response\n        response = f\"Analysis of procedure: {procedure_text}\\n\\n\"\n        \n        # Add recommended codes\n        response += \"Recommended CPT codes:\\n\"\n        for code in analysis[\"recommended_codes\"]:\n            # Get description for the code\n            code_info = self.cpt_db.get_code_details(code.split('-')[0])  # Handle codes with modifiers\n            description = code_info.get(\"description\", \"Unknown\") if \"error\" not in code_info else \"Unknown\"\n            response += f\"- {code}: {description}\\n\"\n        \n        # Add explanations\n        if analysis[\"explanations\"]:\n            response += \"\\nRecommendation details:\\n\"\n            for explanation in analysis[\"explanations\"]:\n                response += f\"- {explanation['message']}\\n\"\n        \n        # Add excluded codes if any\n        if analysis[\"excluded_codes\"]:\n            response += \"\\nExcluded codes (may be bundled or inappropriate):\\n\"\n            for code in analysis[\"excluded_codes\"]:\n                code_info = self.cpt_db.get_code_details(code)\n                description = code_info.get(\"description\", \"Unknown\") if \"error\" not in code_info else \"Unknown\"\n                response += f\"- {code}: {description}\\n\"\n        \n        return response\n    \n    def process_query(self, query: str, conversation=None) -> str:\n        \"\"\"\n        Process a user query about ENT procedures and CPT codes.\n        \n        Args:\n            query: The user's question or procedure description\n            conversation: Optional Conversation object to use\n            \n        Returns:\n            Agent's response with CPT code recommendations\n        \"\"\"\n        logger.info(f\"Processing query: {query}\")\n        \n        # Use provided conversation or create a temporary one\n        if conversation is None:\n            chat = lms.Chat(self.system_prompt)\n            chat.add_user_message(query)\n        else:\n            # Convert existing conversation to LM Studio chat\n            chat = conversation.to_lmstudio_chat(self.system_prompt)\n        \n        # Define the tool functions\n        tools = [\n            self.search_cpt_codes,\n            self.validate_cpt_code,\n            self.get_category_codes,\n            self.explain_coding_rules,\n            self.analyze_procedure\n        ]\n        \n        # Let the model use tools to process the query\n        result = self.model.act(\n            chat,\n            tools,\n            on_message=lambda msg: conversation.add_message(\"assistant\", msg.content) if conversation else None\n        )\n        \n        return result.content\n    \n    def run_interactive_session(self) -> None:\n        \"\"\"Run an interactive session where the user can ask questions about CPT codes.\"\"\"\n        print(\"\\nENT CPT Code Assistant\")\n        print(\"=\" * 50)\n        print(\"Ask questions about ENT procedures and CPT codes.\")\n        print(\"Type 'quit' or 'exit' to end the session.\")\n        print(\"Type 'new' to start a new conversation.\")\n        print(\"=\" * 50)\n        \n        # Create initial conversation\n        conversation = self.conversation_manager.create_conversation()\n        print(f\"\\nSession ID: {conversation.session_id}\\n\")\n        \n        while True:\n            query = input(\"\\nQuestion: \")\n            \n            # Handle special commands\n            if query.lower() in ['quit', 'exit']:\n                # Save conversation before exiting\n                self.conversation_manager.save_conversation(conversation)\n                print(\"Conversation saved. Goodbye!\")\n                break\n            \n            elif query.lower() == 'new':\n                # Save current conversation and create a new one\n                self.conversation_manager.save_conversation(conversation)\n                conversation = self.conversation_manager.create_conversation()\n                print(f\"\\nStarted new conversation. Session ID: {conversation.session_id}\\n\")\n                continue\n            \n            # Add user message to conversation\n            conversation.add_message(\"user\", query)\n            \n            # Process query\n            response = self.process_query(query, conversation)\n            \n            # Extract CPT codes from response\n            codes = self.conversation_manager.extract_cpt_codes(response)\n            if codes:\n                # Update the last assistant message with found codes\n                if conversation.messages and conversation.messages[-1][\"role\"] == \"assistant\":\n                    conversation.messages[-1][\"codes\"] = codes\n            \n            # Save conversation after each interaction\n            self.conversation_manager.save_conversation(conversation)\n            \n            # Display response\n            print(\"\\nResponse:\")\n            print(response)\n            \n            # Display found CPT codes separately\n            if codes:\n                print(\"\\nCPT Codes found:\")\n                for code in codes:\n                    description = \"\"\n                    code_info = self.cpt_db.get_code_details(code)\n                    if \"error\" not in code_info:\n                        description = code_info.get(\"description\", \"\")\n                    print(f\"- {code}: {description}\")\n            \n            print(\"-\" * 50)\n\n\ndef main():\n    \"\"\"Main entry point for the ENT CPT Code Agent.\"\"\"\n    parser = argparse.ArgumentParser(description=\"ENT CPT Code Agent\")\n    parser.add_argument(\n        \"--cpt_db\", \n        type=str, \n        default=\"CPT codes for ENT.xlsx\",\n        help=\"Path to the CPT code database Excel file\"\n    )\n    parser.add_argument(\n        \"--model\", \n        type=str, \n        default=\"qwen2.5-7b-instruct\",\n        help=\"Name of the LM Studio model to use\"\n    )\n    args = parser.parse_args()\n    \n    try:\n        agent = ENTCPTAgent(args.cpt_db, args.model)\n        agent.run_interactive_session()\n    except KeyboardInterrupt:\n        print(\"\\nSession terminated by user.\")\n    except Exception as e:\n        logger.error(f\"Error running ENT CPT Agent: {e}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"
                },
                {
                    "name": "__init__.py",
                    "content": "\"\"\"\nAgent module for the ENT CPT Code Agent.\nContains the core agent components for CPT code assistance.\n\"\"\"\n\nfrom .ent_cpt_agent import ENTCPTAgent\nfrom .cpt_database import CPTCodeDatabase\nfrom .rules_engine import RulesEngine\n\n__all__ = ['ENTCPTAgent', 'CPTCodeDatabase', 'RulesEngine']"
                },
                {
                    "name": "cpt_database.py",
                    "content": "import pandas as pd\nimport logging\nfrom typing import List, Dict, Any\n\nlogger = logging.getLogger(\"ent_cpt_agent.cpt_database\")\n\nclass CPTCodeDatabase:\n    \"\"\"\n    Handles loading, processing, and querying of CPT codes for ENT procedures.\n    \n    The CPTCodeDatabase class is responsible for:\n    - Loading CPT code data from an Excel file\n    - Providing search functionality for codes\n    - Retrieving code details and validating codes\n    - Organizing codes by category\n    \n    This serves as the data layer for the ENT CPT Code Agent.\n    \"\"\"\n    def __init__(self, file_path: str):\n        \"\"\"\n        Initialize the CPT code database from the provided Excel file.\n        \n        Args:\n            file_path: Path to the Excel file containing CPT codes\n        \"\"\"\n        self.file_path = file_path\n        self.df = None\n        # Dictionary of code to description mappings\n        self.code_descriptions = {}\n        # Dictionary of category to list of codes mappings\n        self.code_categories = {}\n        # Dictionary of code to related codes mappings\n        self.related_codes = {}\n        self.load_data()\n    \n    def load_data(self) -> None:\n        \"\"\"\n        Load CPT code data from Excel file and process it.\n        \n        This method reads the Excel file and populates the internal\n        data structures for efficient code lookup and search.\n        \"\"\"\n        logger.info(f\"Loading CPT codes from {self.file_path}\")\n        try:\n            # Load the Excel file into a pandas DataFrame\n            self.df = pd.read_excel(self.file_path)\n            \n            # Process the dataframe to create lookup dictionaries\n            for _, row in self.df.iterrows():\n                code = str(row.get('CPT Code', '')).strip()\n                if code and not pd.isna(code):\n                    # Store description\n                    self.code_descriptions[code] = row.get('Description', '')\n                    \n                    # Store category\n                    category = row.get('Category', '')\n                    if category and not pd.isna(category):\n                        if category not in self.code_categories:\n                            self.code_categories[category] = []\n                        self.code_categories[category].append(code)\n                    \n                    # Store related codes\n                    related = row.get('Related Codes', '')\n                    if related and not pd.isna(related):\n                        related_codes = [r.strip() for r in str(related).split(',')]\n                        self.related_codes[code] = related_codes\n            \n            logger.info(f\"Loaded {len(self.code_descriptions)} CPT codes\")\n        except Exception as e:\n            logger.error(f\"Error loading CPT codes: {e}\")\n            raise\n    \n    def search_codes(self, query: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Search for CPT codes based on a text query.\n        \n        This method searches for codes whose descriptions or code numbers\n        contain the search query.\n        \n        Args:\n            query: Search terms for finding relevant CPT codes\n            \n        Returns:\n            List of matching CPT codes with descriptions\n        \"\"\"\n        query = query.lower()\n        results = []\n        \n        # Search in both code numbers and descriptions\n        for code, description in self.code_descriptions.items():\n            if query in description.lower() or query in code:\n                results.append({\n                    \"code\": code,\n                    \"description\": description,\n                    \"related_codes\": self.related_codes.get(code, [])\n                })\n        \n        return results\n    \n    def get_code_details(self, code: str) -> Dict[str, Any]:\n        \"\"\"\n        Get detailed information about a specific CPT code.\n        \n        This method retrieves all available information about a\n        specific CPT code, including its description and related codes.\n        \n        Args:\n            code: The CPT code to look up\n            \n        Returns:\n            Dictionary containing detailed information about the code\n        \"\"\"\n        if code not in self.code_descriptions:\n            return {\"error\": f\"CPT code {code} not found\"}\n        \n        return {\n            \"code\": code,\n            \"description\": self.code_descriptions.get(code, \"\"),\n            \"related_codes\": self.related_codes.get(code, [])\n        }\n    \n    def get_codes_by_category(self, category: str) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get all CPT codes belonging to a specific category.\n        \n        This method retrieves all codes that are classified under\n        a particular category (e.g., \"Ear\", \"Nose\", \"Throat\").\n        \n        Args:\n            category: The category to look up codes for\n            \n        Returns:\n            List of CPT codes in the specified category\n        \"\"\"\n        if category not in self.code_categories:\n            return []\n        \n        results = []\n        for code in self.code_categories[category]:\n            results.append({\n                \"code\": code,\n                \"description\": self.code_descriptions.get(code, \"\"),\n                \"related_codes\": self.related_codes.get(code, [])\n            })\n        \n        return results\n    \n    def get_code_validation(self, code: str) -> Dict[str, Any]:\n        \"\"\"\n        Validate if a CPT code exists and is valid.\n        \n        This method checks if a given CPT code exists in the database\n        and returns its validation status.\n        \n        Args:\n            code: The CPT code to validate\n            \n        Returns:\n            Dictionary with validation results\n        \"\"\"\n        if code in self.code_descriptions:\n            return {\"valid\": True, \"description\": self.code_descriptions[code]}\n        else:\n            return {\"valid\": False, \"error\": f\"Invalid CPT code: {code}\"}"
                },
                {
                    "name": "rules_engine.py",
                    "content": "from typing import List, Dict, Any, Optional, Tuple\nimport re\nimport logging\nfrom dataclasses import dataclass\n\nlogger = logging.getLogger(\"ent_cpt_agent.rules_engine\")\n\n@dataclass\nclass CodeRule:\n    \"\"\"Represents a rule for CPT code selection.\"\"\"\n    rule_id: str\n    description: str\n    conditions: List[Dict[str, Any]]\n    priority: int = 0\n    \n    def __str__(self) -> str:\n        return f\"Rule {self.rule_id}: {self.description} (Priority: {self.priority})\"\n\n\nclass RulesEngine:\n    \"\"\"\n    Implements a rules engine for CPT code selection based on medical coding guidelines.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initialize the rules engine with ENT-specific CPT coding rules.\"\"\"\n        self.rules = []\n        self.initialize_rules()\n    \n    def initialize_rules(self) -> None:\n        \"\"\"Load default rules for ENT CPT coding.\"\"\"\n        # Rule: Bundled procedures\n        self.rules.append(CodeRule(\n            rule_id=\"R001\",\n            description=\"Check for bundled procedures\",\n            conditions=[\n                {\"type\": \"bundled_codes\", \"codes\": []}\n            ],\n            priority=10\n        ))\n        \n        # Rule: Bilateral procedures\n        self.rules.append(CodeRule(\n            rule_id=\"R002\",\n            description=\"Check for bilateral procedures (use modifier 50)\",\n            conditions=[\n                {\"type\": \"procedure_bilateral\", \"keywords\": [\"bilateral\", \"both sides\", \"both ears\"]}\n            ],\n            priority=8\n        ))\n        \n        # Rule: Follow-up visits\n        self.rules.append(CodeRule(\n            rule_id=\"R003\",\n            description=\"Check for post-operative visits (usually included in surgical package)\",\n            conditions=[\n                {\"type\": \"post_op\", \"keywords\": [\"follow-up\", \"post-op\", \"postoperative\"]}\n            ],\n            priority=9\n        ))\n        \n        # Rule: Check for multiple procedures\n        self.rules.append(CodeRule(\n            rule_id=\"R004\",\n            description=\"Check for multiple procedures (additional procedures may require modifier 51)\",\n            conditions=[\n                {\"type\": \"multiple_procedures\", \"patterns\": [\n                    r\"\\bmultiple\\s+procedures\\b\",\n                    r\"\\bseveral\\s+procedures\\b\"\n                ]}\n            ],\n            priority=7\n        ))\n        \n        # Rule: Check for medical necessity\n        self.rules.append(CodeRule(\n            rule_id=\"R005\",\n            description=\"Verify medical necessity documentation\",\n            conditions=[\n                {\"type\": \"medical_necessity\", \"required\": True}\n            ],\n            priority=6\n        ))\n        \n        logger.info(f\"Initialized {len(self.rules)} CPT coding rules\")\n    \n    def add_rule(self, rule: CodeRule) -> None:\n        \"\"\"\n        Add a new rule to the engine.\n        \n        Args:\n            rule: The rule to add\n        \"\"\"\n        self.rules.append(rule)\n        # Sort rules by priority (higher priority first)\n        self.rules.sort(key=lambda r: r.priority, reverse=True)\n        logger.info(f\"Added rule: {rule}\")\n    \n    def evaluate_bundled_codes(self, procedure_text: str, candidate_codes: List[str], \n                               code_db) -> Tuple[List[str], List[str], List[Dict[str, Any]]]:\n        \"\"\"\n        Check for bundled procedure codes.\n        \n        Args:\n            procedure_text: Description of the procedure\n            candidate_codes: List of potential CPT codes\n            code_db: Database of CPT codes\n            \n        Returns:\n            Tuple of (recommended_codes, excluded_codes, explanations)\n        \"\"\"\n        recommended = []\n        excluded = []\n        explanations = []\n        \n        # Check each candidate code\n        for code in candidate_codes:\n            details = code_db.get_code_details(code)\n            \n            # Skip if code not found\n            if \"error\" in details:\n                continue\n            \n            # Check related codes for potential bundling\n            related_codes = details.get(\"related_codes\", [])\n            bundled_with = []\n            \n            for related in related_codes:\n                if related in candidate_codes:\n                    bundled_with.append(related)\n            \n            if bundled_with:\n                # This code might be bundled with others\n                # In a real implementation, we would check a bundling database\n                explanations.append({\n                    \"rule_id\": \"R001\",\n                    \"code\": code,\n                    \"message\": f\"Code {code} may be bundled with {', '.join(bundled_with)}. \"\n                               f\"Check coding guidelines to determine which code to use.\"\n                })\n                \n                # For demonstration, we'll add the main code and exclude related codes\n                # (This logic should be updated based on actual bundling rules)\n                if code not in excluded:\n                    recommended.append(code)\n                    excluded.extend(bundled_with)\n            elif code not in excluded:\n                recommended.append(code)\n        \n        return recommended, excluded, explanations\n    \n    def evaluate_bilateral_procedures(self, procedure_text: str, candidate_codes: List[str],\n                                     code_db) -> Tuple[List[str], List[Dict[str, Any]]]:\n        \"\"\"\n        Check for bilateral procedures that require modifier 50.\n        \n        Args:\n            procedure_text: Description of the procedure\n            candidate_codes: List of potential CPT codes\n            code_db: Database of CPT codes\n            \n        Returns:\n            Tuple of (modified_codes, explanations)\n        \"\"\"\n        modified_codes = []\n        explanations = []\n        \n        # Check if the procedure description indicates a bilateral procedure\n        bilateral_keywords = [\"bilateral\", \"both sides\", \"both ears\", \"right and left\"]\n        is_bilateral = any(keyword in procedure_text.lower() for keyword in bilateral_keywords)\n        \n        if is_bilateral:\n            for code in candidate_codes:\n                # In a real implementation, we would check if the code is eligible for modifier 50\n                modified_codes.append(f\"{code}-50\")\n                explanations.append({\n                    \"rule_id\": \"R002\",\n                    \"code\": code,\n                    \"message\": f\"Added modifier 50 to code {code} for bilateral procedure.\"\n                })\n        else:\n            modified_codes = candidate_codes\n        \n        return modified_codes, explanations\n    \n    def analyze_procedure(self, procedure_text: str, candidate_codes: List[str], \n                         code_db) -> Dict[str, Any]:\n        \"\"\"\n        Analyze a procedure description and apply coding rules to suggest the\n        most appropriate CPT codes.\n        \n        Args:\n            procedure_text: Description of the procedure\n            candidate_codes: List of potential CPT codes\n            code_db: Database of CPT codes\n            \n        Returns:\n            Dictionary with analysis results and recommendations\n        \"\"\"\n        logger.info(f\"Analyzing procedure: {procedure_text}\")\n        logger.info(f\"Candidate codes: {candidate_codes}\")\n        \n        if not candidate_codes:\n            return {\n                \"status\": \"error\",\n                \"message\": \"No candidate codes provided for analysis\",\n                \"recommended_codes\": []\n            }\n        \n        recommended_codes = candidate_codes.copy()\n        excluded_codes = []\n        explanations = []\n        modifiers = {}\n        \n        # Apply each rule in priority order\n        for rule in self.rules:\n            logger.info(f\"Applying rule: {rule}\")\n            \n            try:\n                if rule.rule_id == \"R001\":  # Bundled procedures\n                    rec, exc, exp = self.evaluate_bundled_codes(\n                        procedure_text, recommended_codes, code_db)\n                    recommended_codes = rec\n                    excluded_codes.extend(exc)\n                    explanations.extend(exp)\n                \n                elif rule.rule_id == \"R002\":  # Bilateral procedures\n                    rec, exp = self.evaluate_bilateral_procedures(\n                        procedure_text, recommended_codes, code_db)\n                    recommended_codes = rec\n                    explanations.extend(exp)\n                \n                # Additional rule implementations would go here\n                \n            except Exception as e:\n                logger.error(f\"Error applying rule {rule.rule_id}: {e}\")\n        \n        # Prepare the result\n        result = {\n            \"status\": \"success\",\n            \"procedure_text\": procedure_text,\n            \"recommended_codes\": recommended_codes,\n            \"excluded_codes\": excluded_codes,\n            \"explanations\": explanations\n        }\n        \n        logger.info(f\"Analysis complete. Recommended codes: {recommended_codes}\")\n        return result\n    \n    def get_rule_explanations(self) -> Dict[str, str]:\n        \"\"\"\n        Get explanations for all rules.\n        \n        Returns:\n            Dictionary mapping rule IDs to descriptions\n        \"\"\"\n        return {rule.rule_id: rule.description for rule in self.rules}\n    \n    def get_coding_tips(self, code: str, procedure_text: str) -> List[str]:\n        \"\"\"\n        Get coding tips for a specific CPT code based on the procedure description.\n        \n        Args:\n            code: CPT code to get tips for\n            procedure_text: Description of the procedure\n            \n        Returns:\n            List of coding tips\n        \"\"\"\n        tips = []\n        \n        # General tips\n        tips.append(\"Ensure the documentation supports medical necessity.\")\n        tips.append(\"Check that the procedure description matches the code definition exactly.\")\n        \n        # Specific tips based on procedure text\n        if \"consultation\" in procedure_text.lower():\n            tips.append(\"Initial consultations may require different codes than follow-up visits.\")\n        \n        if \"biopsy\" in procedure_text.lower():\n            tips.append(\"Verify if the biopsy was for diagnostic or therapeutic purposes.\")\n        \n        if \"endoscopic\" in procedure_text.lower():\n            tips.append(\"Endoscopic procedures often have specific bundling rules.\")\n        \n        return tips"
                }
            ]
        },
        {
            "name": "src/api",
            "files": [
                {
                    "name": "__init__.py",
                    "content": ""
                },
                {
                    "name": "api_interface.py",
                    "content": "from fastapi import FastAPI, HTTPException, Depends, Query, Body\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom typing import List, Dict, Any, Optional\nimport uvicorn\nimport logging\nimport os\nfrom pydantic import BaseModel, Field\nimport json\n\n# Import our agent components\n# Note: These would be actual imports in a real implementation\n# from agent_config import AgentConfig\n# from cpt_database import CPTCodeDatabase\n# from rules_engine import RulesEngine\n# from conversation_manager import ConversationManager, Conversation\n# from ent_cpt_agent import ENTCPTAgent\n\nlogger = logging.getLogger(\"ent_cpt_agent.api\")\n\n# Pydantic models for request/response validation\nclass QueryRequest(BaseModel):\n    \"\"\"Request model for querying the agent.\"\"\"\n    query: str = Field(..., description=\"The query about ENT procedures or CPT codes\")\n    session_id: Optional[str] = Field(None, description=\"Session ID for conversation continuity\")\n\nclass CodeSearchRequest(BaseModel):\n    \"\"\"Request model for searching CPT codes.\"\"\"\n    search_term: str = Field(..., description=\"Term to search for in CPT code descriptions\")\n\nclass CodeValidationRequest(BaseModel):\n    \"\"\"Request model for validating CPT codes.\"\"\"\n    code: str = Field(..., description=\"CPT code to validate\")\n\nclass ProcedureAnalysisRequest(BaseModel):\n    \"\"\"Request model for analyzing a procedure description.\"\"\"\n    procedure_text: str = Field(..., description=\"Description of the ENT procedure\")\n    candidate_codes: Optional[List[str]] = Field(None, description=\"Optional list of candidate CPT codes\")\n\nclass AgentResponse(BaseModel):\n    \"\"\"Generic response model for agent API.\"\"\"\n    status: str = Field(..., description=\"Status of the request (success/error)\")\n    message: Optional[str] = Field(None, description=\"Response message or error details\")\n    data: Optional[Dict[str, Any]] = Field(None, description=\"Response data\")\n    session_id: Optional[str] = Field(None, description=\"Session ID for conversation continuity\")\n\nclass APIInterface:\n    \"\"\"API interface for the ENT CPT Code Agent.\"\"\"\n    \n    def __init__(self, agent, config, host=\"localhost\", port=8000):\n        \"\"\"\n        Initialize the API interface.\n        \n        Args:\n            agent: Instance of ENTCPTAgent\n            config: Instance of AgentConfig\n            host: Host to run the API server on\n            port: Port to run the API server on\n        \"\"\"\n        self.agent = agent\n        self.config = config\n        self.host = host\n        self.port = port\n        self.app = FastAPI(\n            title=\"ENT CPT Code Agent API\",\n            description=\"API for querying ENT CPT codes and analyzing medical procedures\",\n            version=\"1.0.0\"\n        )\n        \n        # Add CORS middleware\n        self.app.add_middleware(\n            CORSMiddleware,\n            allow_origins=[\"*\"],  # In production, restrict this to specific origins\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n        )\n        \n        # Register routes\n        self.register_routes()\n    \n    def register_routes(self):\n        \"\"\"Register API routes.\"\"\"\n        \n        @self.app.get(\"/\", tags=[\"General\"])\n        async def root():\n            \"\"\"Root endpoint providing API information.\"\"\"\n            return {\n                \"name\": \"ENT CPT Code Agent API\",\n                \"version\": \"1.0.0\",\n                \"status\": \"running\"\n            }\n        \n        @self.app.post(\"/api/query\", response_model=AgentResponse, tags=[\"Agent\"])\n        async def query_agent(request: QueryRequest):\n            \"\"\"\n            Submit a query to the ENT CPT Code Agent.\n            \n            This endpoint processes natural language queries about ENT procedures\n            and CPT codes, using the agent to determine the most appropriate response.\n            \"\"\"\n            try:\n                # Get or create session\n                session_id = request.session_id\n                conversation_manager = self.agent.conversation_manager\n                \n                if session_id and conversation_manager.get_conversation(session_id):\n                    conversation = conversation_manager.get_conversation(session_id)\n                else:\n                    conversation = conversation_manager.create_conversation()\n                    session_id = conversation.session_id\n                \n                # Add user message to conversation\n                conversation.add_message(\"user\", request.query)\n                \n                # Process the query\n                response = self.agent.process_query(request.query, conversation)\n                \n                # Extract CPT codes from response\n                codes = conversation_manager.extract_cpt_codes(response)\n                \n                # Add assistant message to conversation\n                conversation.add_message(\"assistant\", response, codes)\n                \n                # Save conversation\n                conversation_manager.save_conversation(conversation)\n                \n                return {\n                    \"status\": \"success\",\n                    \"message\": response,\n                    \"data\": {\n                        \"codes\": codes\n                    },\n                    \"session_id\": session_id\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error processing query: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.post(\"/api/search\", response_model=AgentResponse, tags=[\"CPT Codes\"])\n        async def search_codes(request: CodeSearchRequest):\n            \"\"\"\n            Search for CPT codes by description or keywords.\n            \n            This endpoint searches the CPT code database for codes matching\n            the provided search term in their description.\n            \"\"\"\n            try:\n                results = self.agent.cpt_db.search_codes(request.search_term)\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": {\n                        \"codes\": results,\n                        \"count\": len(results)\n                    }\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error searching codes: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.post(\"/api/validate\", response_model=AgentResponse, tags=[\"CPT Codes\"])\n        async def validate_code(request: CodeValidationRequest):\n            \"\"\"\n            Validate a CPT code.\n            \n            This endpoint checks if a CPT code exists and is valid according\n            to the CPT code database.\n            \"\"\"\n            try:\n                result = self.agent.cpt_db.get_code_validation(request.code)\n                \n                return {\n                    \"status\": \"success\" if result.get(\"valid\", False) else \"error\",\n                    \"message\": result.get(\"description\") if result.get(\"valid\", False) else result.get(\"error\"),\n                    \"data\": result\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error validating code: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.post(\"/api/analyze\", response_model=AgentResponse, tags=[\"Analysis\"])\n        async def analyze_procedure(request: ProcedureAnalysisRequest):\n            \"\"\"\n            Analyze an ENT procedure description to determine appropriate CPT codes.\n            \n            This endpoint uses the rules engine to analyze a procedure description\n            and suggest appropriate CPT codes based on coding guidelines.\n            \"\"\"\n            try:\n                # If candidate codes weren't provided, search for them\n                candidate_codes = request.candidate_codes\n                if not candidate_codes:\n                    search_results = self.agent.cpt_db.search_codes(request.procedure_text)\n                    candidate_codes = [result[\"code\"] for result in search_results]\n                \n                # Analyze the procedure using the rules engine\n                analysis = self.agent.rules_engine.analyze_procedure(\n                    request.procedure_text, candidate_codes, self.agent.cpt_db)\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": analysis\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error analyzing procedure: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.get(\"/api/conversations\", response_model=AgentResponse, tags=[\"Conversations\"])\n        async def list_conversations():\n            \"\"\"\n            List all saved conversations.\n            \n            This endpoint returns a list of all saved conversations with their metadata.\n            \"\"\"\n            try:\n                conversations = self.agent.conversation_manager.list_conversations()\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": {\n                        \"conversations\": conversations,\n                        \"count\": len(conversations)\n                    }\n                }\n            \n            except Exception as e:\n                logger.error(f\"Error listing conversations: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.get(\"/api/conversations/{session_id}\", response_model=AgentResponse, tags=[\"Conversations\"])\n        async def get_conversation(session_id: str):\n            \"\"\"\n            Get a specific conversation by session ID.\n            \n            This endpoint returns the details of a specific conversation.\n            \"\"\"\n            try:\n                conversation = self.agent.conversation_manager.get_conversation(session_id)\n                \n                if not conversation:\n                    raise HTTPException(status_code=404, detail=f\"Conversation {session_id} not found\")\n                \n                return {\n                    \"status\": \"success\",\n                    \"data\": conversation.to_dict(),\n                    \"session_id\": session_id\n                }\n            \n            except HTTPException:\n                raise\n            except Exception as e:\n                logger.error(f\"Error getting conversation: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n        \n        @self.app.delete(\"/api/conversations/{session_id}\", response_model=AgentResponse, tags=[\"Conversations\"])\n        async def delete_conversation(session_id: str):\n            \"\"\"\n            Delete a specific conversation by session ID.\n            \n            This endpoint deletes a specific conversation and its associated data.\n            \"\"\"\n            try:\n                result = self.agent.conversation_manager.delete_conversation(session_id)\n                \n                if not result:\n                    raise HTTPException(status_code=404, detail=f\"Conversation {session_id} not found\")\n                \n                return {\n                    \"status\": \"success\",\n                    \"message\": f\"Conversation {session_id} deleted successfully\"\n                }\n            \n            except HTTPException:\n                raise\n            except Exception as e:\n                logger.error(f\"Error deleting conversation: {e}\")\n                raise HTTPException(status_code=500, detail=str(e))\n    \n    def start(self):\n        \"\"\"Start the API server.\"\"\"\n        logger.info(f\"Starting API server on {self.host}:{self.port}\")\n        uvicorn.run(self.app, host=self.host, port=self.port)\n    \n    def get_app(self):\n        \"\"\"Get the FastAPI application instance.\"\"\"\n        return self.app"
                }
            ]
        },
        {
            "name": "src/conversation",
            "files": [
                {
                    "name": "__init__.py",
                    "content": "\"\"\"\nConversation management module for the ENT CPT Code Agent.\nHandles conversation sessions, persistence, and history.\n\"\"\"\n\nfrom .conversation_manager import ConversationManager, Conversation\n\n__all__ = ['ConversationManager', 'Conversation']"
                },
                {
                    "name": "conversation_manager.py",
                    "content": "import json\nimport os\nimport datetime\nimport uuid\nimport re  # Added missing import for regex pattern matching\nfrom typing import List, Dict, Any, Optional\nimport logging\nimport lmstudio as lms\n\nlogger = logging.getLogger(\"ent_cpt_agent.conversation\")\n\nclass Conversation:\n    \"\"\"\n    Represents a conversation session with the ENT CPT Code Agent.\n    \n    This class handles individual conversations between the user and agent,\n    including message history, metadata, and serialization/deserialization.\n    \"\"\"\n    def __init__(self, session_id: Optional[str] = None):\n        \"\"\"\n        Initialize a new conversation.\n        \n        Args:\n            session_id: Optional session ID (generates a new one if not provided)\n        \"\"\"\n        self.session_id = session_id or str(uuid.uuid4())\n        self.start_time = datetime.datetime.now()\n        self.messages = []\n        self.metadata = {\n            \"session_id\": self.session_id,\n            \"start_time\": self.start_time.isoformat(),\n            \"total_messages\": 0,\n            \"total_codes_identified\": 0\n        }\n    \n    def add_message(self, role: str, content: str, codes: List[str] = None) -> None:\n        \"\"\"\n        Add a message to the conversation.\n        \n        Args:\n            role: Message role (user, assistant, system)\n            content: Message content\n            codes: List of CPT codes mentioned in the message (optional)\n        \"\"\"\n        message = {\n            \"role\": role,\n            \"content\": content,\n            \"timestamp\": datetime.datetime.now().isoformat()\n        }\n        \n        if codes:\n            message[\"codes\"] = codes\n            self.metadata[\"total_codes_identified\"] += len(codes)\n        \n        self.messages.append(message)\n        self.metadata[\"total_messages\"] = len(self.messages)\n    \n    def to_lmstudio_chat(self, system_prompt: str) -> lms.Chat:\n        \"\"\"\n        Convert the conversation to an LM Studio Chat object.\n        \n        This method transforms our internal conversation representation\n        to the format expected by LM Studio's API.\n        \n        Args:\n            system_prompt: System prompt to use for the chat\n            \n        Returns:\n            LM Studio Chat object representing this conversation\n        \"\"\"\n        chat = lms.Chat(system_prompt)\n        \n        for message in self.messages:\n            if message[\"role\"] == \"user\":\n                chat.add_user_message(message[\"content\"])\n            elif message[\"role\"] == \"assistant\":\n                chat.add_assistant_message(message[\"content\"])\n            # System messages are handled by the initial system prompt\n        \n        return chat\n    \n    def to_dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Convert the conversation to a dictionary.\n        \n        Returns:\n            Dictionary representation of the conversation\n        \"\"\"\n        return {\n            \"session_id\": self.session_id,\n            \"metadata\": self.metadata,\n            \"messages\": self.messages\n        }\n    \n    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> 'Conversation':\n        \"\"\"\n        Create a conversation from a dictionary.\n        \n        This factory method reconstructs a Conversation object\n        from a previously serialized dictionary representation.\n        \n        Args:\n            data: Dictionary representation of a conversation\n            \n        Returns:\n            Conversation object\n        \"\"\"\n        conversation = cls(session_id=data.get(\"session_id\"))\n        conversation.metadata = data.get(\"metadata\", {})\n        conversation.messages = data.get(\"messages\", [])\n        \n        # Parse start_time from metadata if available\n        start_time_str = conversation.metadata.get(\"start_time\")\n        if start_time_str:\n            try:\n                conversation.start_time = datetime.datetime.fromisoformat(start_time_str)\n            except (ValueError, TypeError):\n                logger.warning(f\"Could not parse start_time: {start_time_str}\")\n        \n        return conversation\n\n\nclass ConversationManager:\n    \"\"\"\n    Manages multiple conversations, including loading/saving to disk.\n    \n    This class handles the lifecycle of conversations, including:\n    - Creating new conversations\n    - Loading existing conversations from disk\n    - Saving conversations to disk\n    - Listing available conversations\n    - Extracting CPT codes from conversation text\n    \"\"\"\n    def __init__(self, conversation_dir: str = \"conversations\"):\n        \"\"\"\n        Initialize the conversation manager.\n        \n        Args:\n            conversation_dir: Directory to store conversation files\n        \"\"\"\n        self.conversation_dir = conversation_dir\n        self.current_conversation = None\n        self.conversations = {}\n        \n        # Create conversation directory if it doesn't exist\n        os.makedirs(self.conversation_dir, exist_ok=True)\n        \n        # Load existing conversations\n        self.load_conversations()\n    \n    def load_conversations(self) -> None:\n        \"\"\"\n        Load all saved conversations from the conversation directory.\n        \n        This method scans the conversation directory for JSON files,\n        loads them, and reconstructs Conversation objects.\n        \"\"\"\n        if not os.path.exists(self.conversation_dir):\n            logger.warning(f\"Conversation directory not found: {self.conversation_dir}\")\n            return\n        \n        try:\n            for filename in os.listdir(self.conversation_dir):\n                if not filename.endswith('.json'):\n                    continue\n                \n                file_path = os.path.join(self.conversation_dir, filename)\n                \n                with open(file_path, 'r') as f:\n                    data = json.load(f)\n                \n                conversation = Conversation.from_dict(data)\n                self.conversations[conversation.session_id] = conversation\n                \n            logger.info(f\"Loaded {len(self.conversations)} conversations\")\n        except Exception as e:\n            logger.error(f\"Error loading conversations: {e}\")\n    \n    def save_conversation(self, conversation: Conversation) -> None:\n        \"\"\"\n        Save a conversation to disk.\n        \n        Args:\n            conversation: Conversation to save\n        \"\"\"\n        if not conversation:\n            logger.error(\"Cannot save empty conversation\")\n            return\n        \n        file_path = os.path.join(self.conversation_dir, f\"{conversation.session_id}.json\")\n        \n        try:\n            with open(file_path, 'w') as f:\n                json.dump(conversation.to_dict(), f, indent=2)\n            \n            logger.info(f\"Saved conversation {conversation.session_id}\")\n        except Exception as e:\n            logger.error(f\"Error saving conversation: {e}\")\n    \n    def create_conversation(self) -> Conversation:\n        \"\"\"\n        Create a new conversation.\n        \n        Returns:\n            Newly created conversation\n        \"\"\"\n        conversation = Conversation()\n        self.conversations[conversation.session_id] = conversation\n        self.current_conversation = conversation\n        return conversation\n    \n    def get_conversation(self, session_id: str) -> Optional[Conversation]:\n        \"\"\"\n        Get a conversation by session ID.\n        \n        Args:\n            session_id: Session ID of the conversation to retrieve\n            \n        Returns:\n            Conversation object or None if not found\n        \"\"\"\n        return self.conversations.get(session_id)\n    \n    def list_conversations(self) -> List[Dict[str, Any]]:\n        \"\"\"\n        Get a list of all conversations with their metadata.\n        \n        Returns:\n            List of conversation metadata dictionaries\n        \"\"\"\n        result = []\n        for session_id, conversation in self.conversations.items():\n            result.append({\n                \"session_id\": session_id,\n                \"start_time\": conversation.metadata.get(\"start_time\"),\n                \"total_messages\": conversation.metadata.get(\"total_messages\", 0),\n                \"total_codes_identified\": conversation.metadata.get(\"total_codes_identified\", 0)\n            })\n        \n        # Sort by start time (newest first)\n        result.sort(key=lambda x: x.get(\"start_time\", \"\"), reverse=True)\n        \n        return result\n    \n    def delete_conversation(self, session_id: str) -> bool:\n        \"\"\"\n        Delete a conversation.\n        \n        Args:\n            session_id: Session ID of the conversation to delete\n            \n        Returns:\n            True if deleted successfully, False otherwise\n        \"\"\"\n        if session_id not in self.conversations:\n            logger.warning(f\"Conversation not found: {session_id}\")\n            return False\n        \n        # Remove from memory\n        del self.conversations[session_id]\n        \n        # Remove from disk\n        file_path = os.path.join(self.conversation_dir, f\"{session_id}.json\")\n        if os.path.exists(file_path):\n            try:\n                os.remove(file_path)\n                logger.info(f\"Deleted conversation file: {file_path}\")\n            except Exception as e:\n                logger.error(f\"Error deleting conversation file: {e}\")\n                return False\n        \n        # Reset current conversation if it was deleted\n        if self.current_conversation and self.current_conversation.session_id == session_id:\n            self.current_conversation = None\n        \n        return True\n    \n    def extract_cpt_codes(self, text: str) -> List[str]:\n        \"\"\"\n        Extract CPT codes from text using regex pattern matching.\n        \n        This method identifies potential CPT codes in text by looking\n        for 5-digit numbers that may be followed by modifiers.\n        \n        Args:\n            text: Text to extract CPT codes from\n            \n        Returns:\n            List of extracted CPT codes\n        \"\"\"\n        # CPT codes are typically 5 digits or 5 digits followed by F or T or a two-digit modifier\n        pattern = r'\\b\\d{5}(?:[FT]|\\d{2})?\\b'\n        matches = re.findall(pattern, text)\n        return matches"
                }
            ]
        }
    ]
}