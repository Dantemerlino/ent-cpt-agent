<?xml version='1.0' encoding='utf-8'?>
<directory name="ent-cpt-agent">
  <folder name=".">
    <file name="project-summary.md"># ENT CPT Code Agent - Project Summary

## Project Overview

The ENT CPT Code Agent is a comprehensive AI-powered assistant designed to help medical professionals accurately determine the appropriate CPT codes for ENT (Ear, Nose, Throat) procedures according to official coding guidelines. The system leverages LM Studio to provide an intelligent interface that can understand natural language descriptions of procedures and recommend the most appropriate codes based on medical coding rules.

## Key Components

### 1. CPT Code Database

The `CPTCodeDatabase` class manages the loading, storing, and querying of CPT codes from an Excel file. It provides functionality for:
- Searching for codes by description or keywords
- Retrieving code details and validating codes
- Organizing codes by category
- Identifying related codes

### 2. Rules Engine

The `RulesEngine` class implements medical coding rules for CPT code selection, handling:
- Bundled procedures (codes that should not be reported together)
- Bilateral procedures (requiring modifier 50)
- Multiple procedures (requiring modifier 51)
- Medical necessity validation
- Custom rule creation and application

### 3. Conversation Manager

The `ConversationManager` and `Conversation` classes handle user interactions, managing:
- Conversation history storage and retrieval
- Message tracking and organization
- Conversion between internal representation and LM Studio chat format
- CPT code extraction from conversation text

### 4. Agent Core

The `ENTCPTAgent` class serves as the central component, integrating:
- The LM Studio model for natural language understanding
- Tool functions for CPT code operations
- Query processing and response generation
- Interactive session management

### 5. API Interface

The `APIInterface` class provides a REST API for the agent, offering endpoints for:
- Submitting queries to the agent
- Searching for and validating CPT codes
- Analyzing procedure descriptions
- Managing conversation sessions

### 6. Web UI

A web-based user interface built with Flask that provides:
- A chat interface for interacting with the agent
- Tools for code search, validation, and analysis
- Conversation history management
- Detected code tracking and display

## Architecture Design

The project follows a modular architecture with clear separation of concerns:

1. **Data Layer**: CPT code database and persistence
2. **Business Logic Layer**: Rules engine and agent core
3. **Presentation Layer**: API interface and web UI
4. **Integration Layer**: LM Studio integration

Components communicate through well-defined interfaces, allowing for:
- Independent testing and development
- Easy replacement or enhancement of individual components
- Flexible deployment options (CLI, API, web)

## Integration with LM Studio

The system integrates with LM Studio through its Python SDK. Key integration points:

### LLM Initialization

```python
# Configure and load the model
self.model = lms.llm(self.model_name, config={
    "temperature": self.model_temperature,
    "maxTokens": self.model_max_tokens
})
```

### Tool Function Registration

The agent provides tool functions that the language model can use:
- `search_cpt_codes`: Search for CPT codes based on a procedure description
- `validate_cpt_code`: Validate if a CPT code exists and is correct
- `get_category_codes`: Get all CPT codes for a specific category
- `explain_coding_rules`: Explain the rules for using a specific CPT code
- `analyze_procedure`: Analyze a procedure description to determine appropriate codes

### Query Processing

```python
# Define the tool functions
tools = [
    self.search_cpt_codes,
    self.validate_cpt_code,
    self.get_category_codes,
    self.explain_coding_rules,
    self.analyze_procedure
]

# Let the model use tools to process the query
result = self.model.act(
    chat,
    tools,
    on_message=lambda msg: conversation.add_message("assistant", msg.content) if conversation else None
)
```

## Getting Started

1. Install the requirements: `pip install -r requirements.txt`
2. Initialize the configuration: `python main.py init`
3. Place the CPT code database file in the data directory
4. Run the application in interactive mode: `python main.py interactive`

## Development Workflow

To further develop and extend the project:

1. **Setup the Development Environment**:
   ```bash
   # Clone the repository
   git clone &lt;repository-url&gt; ent-cpt-agent
   cd ent-cpt-agent
   
   # Create a virtual environment
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   
   # Install development dependencies
   pip install -r requirements-dev.txt
   ```

2. **Run Tests**:
   ```bash
   # Run all tests
   python -m unittest discover
   
   # Run specific test file
   python -m unittest tests.test_cpt_database
   ```

3. **Add New Features**:
   - Create or modify code in the `src` directory
   - Add tests in the `tests` directory
   - Update documentation as needed

4. **Build and Package**:
   ```bash
   # Build the package
   python setup.py sdist bdist_wheel
   
   # Install locally for testing
   pip install -e .
   ```

## Extending the Project

The ENT CPT Code Agent is designed to be extensible. Here are some ways to enhance it:

1. **Add New Rules**: Create new `CodeRule` instances in the `RulesEngine` for additional coding guidelines.

2. **Enhance the Database**: Add more fields to the CPT code database to support additional information, such as:
   - Reimbursement rates
   - Payer-specific guidelines
   - Historical coding data

3. **Improve the UI**: Enhance the web interface with additional features:
   - Visualization of coding relationships
   - Interactive procedure diagrams
   - Documentation templates

4. **Extend to Other Specialties**: Adapt the framework to support other medical specialties beyond ENT.

## Deployment Options

The ENT CPT Code Agent supports multiple deployment scenarios:

1. **Standalone Application**: Run the interactive CLI or web UI locally for individual users.

2. **API Server**: Deploy as a service that other applications can integrate with via REST API.

3. **Embedded Component**: Integrate the core logic into existing electronic medical record (EMR) systems.

## Conclusion

The ENT CPT Code Agent provides a comprehensive solution for ENT procedure coding assistance. Its modular design, integration with LM Studio, and extensible architecture make it a powerful tool for medical professionals and coding specialists.
</file>
    <file name="requirements.txt">lmstudio
pandas
openpyxl
fastapi
uvicorn
flask
requests
python-dotenv
pytest
argparse
logging
openai


</file>
    <file name="run_web_ui.py">#!/usr/bin/env python3
#file: run_web_ui.py
"""
Script to run the web UI for ENT CPT Code Agent.
"""

from src.web.web_ui import app

if __name__ == "__main__":
    # Get port from environment variable or use default
    import os
    port = int(os.environ.get("WEB_PORT", "5000"))
    host = os.environ.get("WEB_HOST", "0.0.0.0")
    debug = os.environ.get("DEBUG", "False").lower() == "true"
    
    print(f"Starting web UI server on {host}:{port} (debug={debug})")
    app.run(host=host, port=port, debug=debug)</file>
    <file name="config.json">{
    "model": {
      "name": "qwen2.5-7b-instruct",
      "temperature": 0.2,
      "max_tokens": 1024,
      "context_length": 8192
    },
    "cpt_database": {
      "file_path": "CPT codes for ENT.xlsx",
      "sheet_name": "Sheet1"
    },
    "agent": {
      "log_level": "INFO",
      "save_conversations": true,
      "conversation_dir": "conversations"
    },
    "server": {
      "host": "localhost",
      "port": 8000,
      "enable_api": false
    }
  }</file>
    <file name="system-architecture.svg">&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 800 500"&gt;
  &lt;!-- Background --&gt;
  &lt;rect width="800" height="500" fill="#f8f9fa" rx="10" ry="10" /&gt;
  
  &lt;!-- Title --&gt;
  &lt;text x="400" y="40" font-family="Arial" font-size="24" font-weight="bold" text-anchor="middle" fill="#333"&gt;ENT CPT Code Agent Architecture&lt;/text&gt;
  
  &lt;!-- User Interface --&gt;
  &lt;rect x="50" y="80" width="200" height="100" rx="5" ry="5" fill="#e3f2fd" stroke="#2196f3" stroke-width="2" /&gt;
  &lt;text x="150" y="110" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#0d47a1"&gt;User Interface&lt;/text&gt;
  &lt;text x="150" y="135" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Command Line / Web UI&lt;/text&gt;
  &lt;text x="150" y="155" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Query Input / Results Display&lt;/text&gt;
  
  &lt;!-- LM Studio Engine --&gt;
  &lt;rect x="300" y="80" width="200" height="100" rx="5" ry="5" fill="#e8f5e9" stroke="#4caf50" stroke-width="2" /&gt;
  &lt;text x="400" y="110" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#1b5e20"&gt;LM Studio Engine&lt;/text&gt;
  &lt;text x="400" y="135" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Language Model (Qwen/Llama)&lt;/text&gt;
  &lt;text x="400" y="155" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Reasoning &amp; Tool Use&lt;/text&gt;
  
  &lt;!-- CPT Code Database --&gt;
  &lt;rect x="550" y="80" width="200" height="100" rx="5" ry="5" fill="#fff3e0" stroke="#ff9800" stroke-width="2" /&gt;
  &lt;text x="650" y="110" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#e65100"&gt;CPT Code Database&lt;/text&gt;
  &lt;text x="650" y="135" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- ENT CPT Codes&lt;/text&gt;
  &lt;text x="650" y="155" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Code Descriptions &amp; Rules&lt;/text&gt;
  
  &lt;!-- Agent Core --&gt;
  &lt;rect x="300" y="230" width="200" height="120" rx="5" ry="5" fill="#e8eaf6" stroke="#3f51b5" stroke-width="2" /&gt;
  &lt;text x="400" y="260" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#1a237e"&gt;Agent Core&lt;/text&gt;
  &lt;text x="400" y="285" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Query Processing&lt;/text&gt;
  &lt;text x="400" y="305" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Tool Selection &amp; Execution&lt;/text&gt;
  &lt;text x="400" y="325" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;- Response Generation&lt;/text&gt;
  
  &lt;!-- Tool Functions --&gt;
  &lt;rect x="100" y="350" width="600" height="100" rx="5" ry="5" fill="#f3e5f5" stroke="#9c27b0" stroke-width="2" /&gt;
  &lt;text x="400" y="380" font-family="Arial" font-size="16" font-weight="bold" text-anchor="middle" fill="#4a148c"&gt;Tool Functions&lt;/text&gt;
  
  &lt;!-- Tools --&gt;
  &lt;rect x="120" y="400" width="120" height="30" rx="5" ry="5" fill="#e1bee7" stroke="#9c27b0" stroke-width="1" /&gt;
  &lt;text x="180" y="420" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;Code Search&lt;/text&gt;
  
  &lt;rect x="260" y="400" width="120" height="30" rx="5" ry="5" fill="#e1bee7" stroke="#9c27b0" stroke-width="1" /&gt;
  &lt;text x="320" y="420" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;Code Validation&lt;/text&gt;
  
  &lt;rect x="400" y="400" width="120" height="30" rx="5" ry="5" fill="#e1bee7" stroke="#9c27b0" stroke-width="1" /&gt;
  &lt;text x="460" y="420" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;Rule Application&lt;/text&gt;
  
  &lt;rect x="540" y="400" width="140" height="30" rx="5" ry="5" fill="#e1bee7" stroke="#9c27b0" stroke-width="1" /&gt;
  &lt;text x="610" y="420" font-family="Arial" font-size="12" text-anchor="middle" fill="#333"&gt;Explanation Generator&lt;/text&gt;
  
  &lt;!-- Connecting Lines --&gt;
  &lt;!-- UI to Agent --&gt;
  &lt;line x1="150" y1="180" x2="300" y2="230" stroke="#333" stroke-width="2" stroke-dasharray="5,5" /&gt;
  
  &lt;!-- LM Studio to Agent --&gt;
  &lt;line x1="400" y1="180" x2="400" y2="230" stroke="#333" stroke-width="2" /&gt;
  
  &lt;!-- CPT Database to Agent --&gt;
  &lt;line x1="650" y1="180" x2="500" y2="230" stroke="#333" stroke-width="2" stroke-dasharray="5,5" /&gt;
  
  &lt;!-- Agent to Tools --&gt;
  &lt;line x1="400" y1="350" x2="400" y2="380" stroke="#333" stroke-width="2" /&gt;
&lt;/svg&gt;
</file>
    <file name="readme.md"># ENT CPT Code Agent

An AI-powered assistant for ENT (Ear, Nose, Throat) CPT code selection and validation.

## Overview

The ENT CPT Code Agent is a comprehensive tool designed to help medical professionals accurately determine the appropriate CPT codes for ENT procedures according to official coding rules. It uses LM Studio to power an intelligent assistant that can understand natural language descriptions of procedures and recommend the most appropriate codes.

## Features

- **Natural Language Understanding**: Describe procedures in plain English and get accurate code recommendations
- **CPT Code Search**: Search for codes based on keywords or descriptions
- **Code Validation**: Verify if a CPT code is valid and appropriate for a given procedure
- **Procedure Analysis**: Analyze detailed procedure descriptions to determine the correct codes
- **Educational Guidance**: Learn about coding rules, modifiers, and best practices
- **Multiple Interfaces**: Command-line, Web UI, and API options for different usage scenarios
- **Conversation History**: Save and review past conversations for reference

## Installation

### Prerequisites

- Python 3.8+
- LM Studio desktop application
- CPT codes database (Excel format)

### Quick Install

```bash
# Clone the repository
git clone https://github.com/Dantemerlino/ent-cpt-agent.git
cd ent-cpt-agent

# Create a virtual environment
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate

# Install dependencies
pip install -r requirements.txt

# Initialize default configuration
python -m src.main init
```

For detailed installation instructions, see the [Installation Guide](docs/installation_guide.md).

## Usage

### Interactive Mode

```bash
python -m src.main interactive
```

This starts an interactive session where you can ask questions about ENT procedures and CPT codes.

### API Server Mode

```bash
python -m src.main server --host localhost --port 8000
```

This starts the API server, allowing you to integrate the agent with other applications.

### Web UI

```bash
python run_web_ui.py
```

This starts the web interface server. Navigate to http://localhost:5000 to access the web UI.

### Single Query Mode

```bash
python -m src.main query "What is the CPT code for bilateral myringotomy with tube insertion?"
```

This processes a single query and exits, useful for scripts and automation.

## Documentation

- [Installation Guide](docs/installation_guide.md): Detailed installation instructions
- [Usage Examples](docs/usage_examples.md): Examples of how to use the agent
- [API Documentation](docs/api_docs.md): Documentation for the REST API
- [Project summary](docs/PROJECT_SUMMARY.md): Project summary

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Acknowledgments

- This project uses LM Studio for AI language model processing
- Special thanks to the medical coding community for guidance
</file>
    <file name="setup.py">from setuptools import setup, find_packages

with open("README.md", "r", encoding="utf-8") as fh:
    long_description = fh.read()

with open("requirements.txt", "r", encoding="utf-8") as fh:
    requirements = fh.read().splitlines()

setup(
    name="ent-cpt-agent",
    version="1.0.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="An AI-powered assistant for ENT CPT code selection and validation",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/your-organization/ent-cpt-agent",
    packages=find_packages(),
    include_package_data=True,
    classifiers=[
        "Programming Language :: Python :: 3",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
        "Development Status :: 4 - Beta",
        "Intended Audience :: Healthcare Industry",
        "Topic :: Scientific/Engineering :: Medical Science Apps.",
    ],
    python_requires="&gt;=3.8",
    install_requires=requirements,
    entry_points={
        "console_scripts": [
            "ent-cpt-agent=main:main",
        ],
    },
)
</file>
    <file name="directory_contents.txt" />
  </folder>
  <folder name="tests">
    <file name="test_rules_engine.py">import os
import sys
import unittest
from unittest.mock import Mock, MagicMock
import logging

# Add the src directory to the path so we can import our modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import the classes to test
from src.agent.rules_engine import RulesEngine, CodeRule

# Disable logging output during tests
logging.disable(logging.CRITICAL)

class TestRulesEngine(unittest.TestCase):
    """
    Unit tests for the RulesEngine class.
    
    These tests validate the rule application logic and code recommendations.
    """
    
    def setUp(self):
        """Set up test fixtures before each test method."""
        # Create a RulesEngine instance
        self.rules_engine = RulesEngine()
        
        # Create a mock CPT database
        self.mock_cpt_db = MagicMock()
        
        # Set up mock code details responses
        self.mock_cpt_db.get_code_details.side_effect = self._mock_get_code_details
    
    def _mock_get_code_details(self, code):
        """Mock implementation of get_code_details."""
        # Define some test code details
        code_details = {
            '31231': {
                'code': '31231',
                'description': 'Nasal endoscopy, diagnostic',
                'related_codes': ['31233', '31235']
            },
            '31233': {
                'code': '31233',
                'description': 'Nasal endoscopy with biopsy',
                'related_codes': ['31231']
            },
            '69436': {
                'code': '69436',
                'description': 'Tympanostomy with tubes, bilateral',
                'related_codes': ['69433']
            },
            '30520': {
                'code': '30520',
                'description': 'Septoplasty',
                'related_codes': ['30930']
            }
        }
        
        if code in code_details:
            return code_details[code]
        else:
            return {"error": f"CPT code {code} not found"}
    
    def test_initialize_rules(self):
        """Test that default rules are properly initialized."""
        # Check that rules were loaded
        self.assertGreater(len(self.rules_engine.rules), 0)
        
        # Check that rules are sorted by priority
        priorities = [rule.priority for rule in self.rules_engine.rules]
        self.assertEqual(priorities, sorted(priorities, reverse=True))
        
        # Check that specific rules exist
        rule_ids = [rule.rule_id for rule in self.rules_engine.rules]
        self.assertIn("R001", rule_ids)  # Bundled procedures
        self.assertIn("R002", rule_ids)  # Bilateral procedures
    
    def test_add_rule(self):
        """Test adding a custom rule."""
        # Initial rule count
        initial_count = len(self.rules_engine.rules)
        
        # Add a new rule
        new_rule = CodeRule(
            rule_id="TEST001",
            description="Test rule",
            conditions=[{"type": "test"}],
            priority=100
        )
        self.rules_engine.add_rule(new_rule)
        
        # Check rule was added
        self.assertEqual(len(self.rules_engine.rules), initial_count + 1)
        
        # Check rule is first (highest priority)
        self.assertEqual(self.rules_engine.rules[0].rule_id, "TEST001")
    
    def test_evaluate_bundled_codes(self):
        """Test evaluation of bundled codes."""
        # Test case: two potentially bundled codes
        candidate_codes = ['31231', '31233']
        procedure_text = "Diagnostic nasal endoscopy with biopsy"
        
        recommended, excluded, explanations = self.rules_engine.evaluate_bundled_codes(
            procedure_text, candidate_codes, self.mock_cpt_db
        )
        
        # Either 31231 or 31233 should be recommended, and the other excluded
        self.assertEqual(len(recommended), 1)
        self.assertEqual(len(excluded), 1)
        self.assertEqual(len(explanations), 1)
        
        # Check that related code is properly identified
        self.assertIn(explanations[0]["rule_id"], "R001")
    
    def test_evaluate_bilateral_procedures(self):
        """Test evaluation of bilateral procedures."""
        # Test case: bilateral procedure
        candidate_codes = ['30520']
        procedure_text = "Bilateral septoplasty"
        
        modified_codes, explanations = self.rules_engine.evaluate_bilateral_procedures(
            procedure_text, candidate_codes, self.mock_cpt_db
        )
        
        # Should add modifier 50 to the code
        self.assertEqual(len(modified_codes), 1)
        self.assertEqual(modified_codes[0], "30520-50")
        self.assertEqual(len(explanations), 1)
        
        # Test case: non-bilateral procedure
        candidate_codes = ['30520']
        procedure_text = "Septoplasty"
        
        modified_codes, explanations = self.rules_engine.evaluate_bilateral_procedures(
            procedure_text, candidate_codes, self.mock_cpt_db
        )
        
        # Should not modify the code
        self.assertEqual(len(modified_codes), 1)
        self.assertEqual(modified_codes[0], "30520")
        self.assertEqual(len(explanations), 0)
    
    def test_analyze_procedure(self):
        """Test the main analyze_procedure method."""
        # Test case: bilateral procedure with potential bundling
        procedure_text = "Bilateral nasal endoscopy with biopsy"
        candidate_codes = ['31231', '31233']
        
        result = self.rules_engine.analyze_procedure(
            procedure_text, candidate_codes, self.mock_cpt_db
        )
        
        # Check overall result structure
        self.assertEqual(result["status"], "success")
        self.assertEqual(result["procedure_text"], procedure_text)
        self.assertIn("recommended_codes", result)
        self.assertIn("excluded_codes", result)
        self.assertIn("explanations", result)
        
        # Check that at least one recommended code has modifier 50
        has_bilateral_code = any("-50" in code for code in result["recommended_codes"])
        self.assertTrue(has_bilateral_code)
    
    def test_analyze_procedure_no_candidates(self):
        """Test analyze_procedure with no candidate codes."""
        procedure_text = "Some procedure description"
        candidate_codes = []
        
        result = self.rules_engine.analyze_procedure(
            procedure_text, candidate_codes, self.mock_cpt_db
        )
        
        # Should return an error
        self.assertEqual(result["status"], "error")
        self.assertIn("message", result)
        self.assertEqual(result["recommended_codes"], [])
    
    def test_get_coding_tips(self):
        """Test retrieving coding tips for a code."""
        # Test case: endoscopic procedure
        tips = self.rules_engine.get_coding_tips(
            '31231', 'Nasal endoscopy, diagnostic, endoscopic procedure'
        )
        
        # Should return a list of tips
        self.assertIsInstance(tips, list)
        self.assertGreater(len(tips), 0)
        
        # Should include endoscopy-specific tips
        has_endoscopy_tip = any("endoscopic" in tip.lower() for tip in tips)
        self.assertTrue(has_endoscopy_tip)
        
        # All procedures should have general tips
        has_general_tips = any("medical necessity" in tip.lower() for tip in tips)
        self.assertTrue(has_general_tips)


if __name__ == '__main__':
    unittest.main()</file>
    <file name="__init__.py">"""
Test package for the ENT CPT Code Agent.

This package contains unit tests for the various components of the agent.
"""</file>
    <file name="test_cpt_database.py">import os
import sys
import unittest
import tempfile
import pandas as pd
from pathlib import Path
import logging

# Add the src directory to the path so we can import our modules
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

# Import the class to test
from src.agent.cpt_database import CPTCodeDatabase

# Disable logging output during tests
logging.disable(logging.CRITICAL)

class TestCPTCodeDatabase(unittest.TestCase):
    """
    Unit tests for the CPTCodeDatabase class.
    
    These tests validate the functionality of loading, searching,
    and retrieving CPT codes from the database.
    """
    
    def setUp(self):
        """Set up test fixtures before each test method."""
        # Create a temporary Excel file with test data
        self.temp_dir = tempfile.TemporaryDirectory()
        self.test_file = os.path.join(self.temp_dir.name, "test_cpt_codes.xlsx")
        
        # Create test data
        data = {
            'CPT Code': ['31231', '69436', '42820', '30520'],
            'Description': [
                'Nasal endoscopy, diagnostic', 
                'Tympanostomy with tubes, bilateral', 
                'Tonsillectomy and adenoidectomy, under age 12', 
                'Septoplasty'
            ],
            'Category': ['Nose', 'Ear', 'Throat', 'Nose'],
            'Related Codes': ['31233, 31235', '69433', '42821, 42825', '30930']
        }
        
        # Create a DataFrame and save to Excel
        df = pd.DataFrame(data)
        df.to_excel(self.test_file, index=False)
        
        # Initialize the database with test data
        self.cpt_db = CPTCodeDatabase(self.test_file)
    
    def tearDown(self):
        """Tear down test fixtures after each test method."""
        # Clean up the temporary directory
        self.temp_dir.cleanup()
    
    def test_load_data(self):
        """Test that data is loaded correctly from Excel file."""
        # Verify number of codes loaded
        self.assertEqual(len(self.cpt_db.code_descriptions), 4)
        
        # Verify code descriptions
        self.assertEqual(self.cpt_db.code_descriptions['31231'], 'Nasal endoscopy, diagnostic')
        self.assertEqual(self.cpt_db.code_descriptions['69436'], 'Tympanostomy with tubes, bilateral')
        
        # Verify categories
        self.assertIn('31231', self.cpt_db.code_categories['Nose'])
        self.assertIn('69436', self.cpt_db.code_categories['Ear'])
        
        # Verify related codes
        self.assertEqual(self.cpt_db.related_codes['31231'], ['31233', '31235'])
        self.assertEqual(self.cpt_db.related_codes['69436'], ['69433'])
    
    def test_search_codes(self):
        """Test searching for codes by query."""
        # Search by code
        results = self.cpt_db.search_codes('31231')
        self.assertEqual(len(results), 1)
        self.assertEqual(results[0]['code'], '31231')
        
        # Search by partial description
        results = self.cpt_db.search_codes('endoscopy')
        self.assertEqual(len(results), 1)
        self.assertEqual(results[0]['code'], '31231')
        
        # Search by category (should match multiple)
        results = self.cpt_db.search_codes('nose')
        self.assertEqual(len(results), 2)
        codes = [r['code'] for r in results]
        self.assertIn('31231', codes)
        self.assertIn('30520', codes)
        
        # Search with no matches
        results = self.cpt_db.search_codes('xyz123')
        self.assertEqual(len(results), 0)
    
    def test_get_code_details(self):
        """Test retrieving details for a specific code."""
        # Get details for valid code
        details = self.cpt_db.get_code_details('42820')
        self.assertEqual(details['code'], '42820')
        self.assertEqual(details['description'], 'Tonsillectomy and adenoidectomy, under age 12')
        self.assertEqual(details['related_codes'], ['42821', '42825'])
        
        # Get details for invalid code
        details = self.cpt_db.get_code_details('99999')
        self.assertIn('error', details)
        self.assertEqual(details['error'], 'CPT code 99999 not found')
    
    def test_get_codes_by_category(self):
        """Test retrieving codes by category."""
        # Get codes for Nose category
        results = self.cpt_db.get_codes_by_category('Nose')
        self.assertEqual(len(results), 2)
        codes = [r['code'] for r in results]
        self.assertIn('31231', codes)
        self.assertIn('30520', codes)
        
        # Get codes for non-existent category
        results = self.cpt_db.get_codes_by_category('Unknown')
        self.assertEqual(len(results), 0)
    
    def test_get_code_validation(self):
        """Test code validation functionality."""
        # Validate valid code
        result = self.cpt_db.get_code_validation('30520')
        self.assertTrue(result['valid'])
        self.assertEqual(result['description'], 'Septoplasty')
        
        # Validate invalid code
        result = self.cpt_db.get_code_validation('12345')
        self.assertFalse(result['valid'])
        self.assertIn('error', result)

if __name__ == '__main__':
    unittest.main()</file>
  </folder>
  <folder name="docs">
    <file name="PROJECT_SUMMARY.md"># ENT CPT Code Agent - Project Summary

## Project Overview

The ENT CPT Code Agent is a comprehensive AI-powered assistant designed to help medical professionals accurately determine the appropriate CPT codes for ENT (Ear, Nose, Throat) procedures according to official coding guidelines. The system leverages LM Studio to provide an intelligent interface that can understand natural language descriptions of procedures and recommend the most appropriate codes based on medical coding rules.

## Key Components

### 1. CPT Code Database

The `CPTCodeDatabase` class manages the loading, storing, and querying of CPT codes from an Excel file. It provides functionality for:
- Searching for codes by description or keywords
- Retrieving code details and validating codes
- Organizing codes by category
- Identifying related codes

### 2. Rules Engine

The `RulesEngine` class implements medical coding rules for CPT code selection, handling:
- Bundled procedures (codes that should not be reported together)
- Bilateral procedures (requiring modifier 50)
- Multiple procedures (requiring modifier 51)
- Medical necessity validation
- Custom rule creation and application

### 3. Conversation Manager

The `ConversationManager` and `Conversation` classes handle user interactions, managing:
- Conversation history storage and retrieval
- Message tracking and organization
- Conversion between internal representation and LM Studio chat format
- CPT code extraction from conversation text

### 4. Agent Core

The `ENTCPTAgent` class serves as the central component, integrating:
- The LM Studio model for natural language understanding
- Tool functions for CPT code operations
- Query processing and response generation
- Interactive session management

### 5. API Interface

The `APIInterface` class provides a REST API for the agent, offering endpoints for:
- Submitting queries to the agent
- Searching for and validating CPT codes
- Analyzing procedure descriptions
- Managing conversation sessions

### 6. Web UI

A web-based user interface built with Flask that provides:
- A chat interface for interacting with the agent
- Tools for code search, validation, and analysis
- Conversation history management
- Detected code tracking and display

## Architecture Design

The project follows a modular architecture with clear separation of concerns:

1. **Data Layer**: CPT code database and persistence
2. **Business Logic Layer**: Rules engine and agent core
3. **Presentation Layer**: API interface and web UI
4. **Integration Layer**: LM Studio integration

Components communicate through well-defined interfaces, allowing for:
- Independent testing and development
- Easy replacement or enhancement of individual components
- Flexible deployment options (CLI, API, web)

## Integration with LM Studio

The system integrates with LM Studio through its Python SDK. Key integration points:

### LLM Initialization

```python
# Configure and load the model
self.model = lms.llm(self.model_name, config={
    "temperature": self.model_temperature,
    "maxTokens": self.model_max_tokens
})
```

### Tool Function Registration

The agent provides tool functions that the language model can use:
- `search_cpt_codes`: Search for CPT codes based on a procedure description
- `validate_cpt_code`: Validate if a CPT code exists and is correct
- `get_category_codes`: Get all CPT codes for a specific category
- `explain_coding_rules`: Explain the rules for using a specific CPT code
- `analyze_procedure`: Analyze a procedure description to determine appropriate codes

### Query Processing

```python
# Define the tool functions
tools = [
    self.search_cpt_codes,
    self.validate_cpt_code,
    self.get_category_codes,
    self.explain_coding_rules,
    self.analyze_procedure
]

# Let the model use tools to process the query
result = self.model.act(
    chat,
    tools,
    on_message=lambda msg: conversation.add_message("assistant", msg.content) if conversation else None
)
```

## Getting Started

1. Install the requirements: `pip install -r requirements.txt`
2. Initialize the configuration: `python main.py init`
3. Place the CPT code database file in the data directory
4. Run the application in interactive mode: `python main.py interactive`

## Development Workflow

To further develop and extend the project:

1. **Setup the Development Environment**:
   ```bash
   # Clone the repository
   git clone &lt;repository-url&gt; ent-cpt-agent
   cd ent-cpt-agent
   
   # Create a virtual environment
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   
   # Install development dependencies
   pip install -r requirements-dev.txt
   ```

2. **Run Tests**:
   ```bash
   # Run all tests
   python -m unittest discover
   
   # Run specific test file
   python -m unittest tests.test_cpt_database
   ```

3. **Add New Features**:
   - Create or modify code in the `src` directory
   - Add tests in the `tests` directory
   - Update documentation as needed

4. **Build and Package**:
   ```bash
   # Build the package
   python setup.py sdist bdist_wheel
   
   # Install locally for testing
   pip install -e .
   ```

## Extending the Project

The ENT CPT Code Agent is designed to be extensible. Here are some ways to enhance it:

1. **Add New Rules**: Create new `CodeRule` instances in the `RulesEngine` for additional coding guidelines.

2. **Enhance the Database**: Add more fields to the CPT code database to support additional information, such as:
   - Reimbursement rates
   - Payer-specific guidelines
   - Historical coding data

3. **Improve the UI**: Enhance the web interface with additional features:
   - Visualization of coding relationships
   - Interactive procedure diagrams
   - Documentation templates

4. **Extend to Other Specialties**: Adapt the framework to support other medical specialties beyond ENT.

## Deployment Options

The ENT CPT Code Agent supports multiple deployment scenarios:

1. **Standalone Application**: Run the interactive CLI or web UI locally for individual users.

2. **API Server**: Deploy as a service that other applications can integrate with via REST API.

3. **Embedded Component**: Integrate the core logic into existing electronic medical record (EMR) systems.

## Conclusion

The ENT CPT Code Agent provides a comprehensive solution for ENT procedure coding assistance. Its modular design, integration with LM Studio, and extensible architecture make it a powerful tool for medical professionals and coding specialists.
</file>
    <file name="integration_flow.mermaid">flowchart TB
    subgraph User["User Interaction"]
        CLI["Command Line Interface"]
        API["API/Web Interface"]
    end

    subgraph Config["Configuration Layer"]
        AG_CONFIG["Agent Config"]
        AG_CONFIG --&gt; LOGGING["Logging System"]
    end

    subgraph Core["Core Agent Components"]
        ENT_AGENT["ENT CPT Agent"]
        CONV_MGR["Conversation Manager"]
        CPT_DB["CPT Code Database"]
        RULES["Rules Engine"]
    end

    subgraph AI["AI Engine"]
        LM_STUDIO["LM Studio Engine"]
        TOOLS["Tool Functions"]
    end

    subgraph Storage["Persistence Layer"]
        CONV_STORE["Conversation Storage"]
        CPT_DATA["CPT Code Data (Excel)"]
    end

    %% Connections
    CLI --&gt; ENT_AGENT
    API --&gt; ENT_AGENT
    
    AG_CONFIG --&gt; ENT_AGENT
    
    ENT_AGENT --&gt; CONV_MGR
    ENT_AGENT --&gt; CPT_DB
    ENT_AGENT --&gt; RULES
    ENT_AGENT --&gt; LM_STUDIO
    
    CONV_MGR &lt;--&gt; CONV_STORE
    CPT_DB &lt;--&gt; CPT_DATA
    
    LM_STUDIO --&gt; TOOLS
    TOOLS --&gt; CPT_DB
    TOOLS --&gt; RULES
    
    %% Styling
    classDef primary fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef secondary fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    classDef tertiary fill:#fff3e0,stroke:#e65100,stroke-width:2px
    classDef data fill:#f3e5f5,stroke:#6a1b9a,stroke-width:2px
    
    class ENT_AGENT,CONV_MGR primary
    class CPT_DB,RULES secondary
    class LM_STUDIO,TOOLS tertiary
    class CONV_STORE,CPT_DATA,AG_CONFIG data
</file>
    <file name="api_docs.md"># 6. API Documentation

When running in server mode, the API documentation is available at:

- OpenAPI UI: `http://localhost:8000/docs`
- ReDoc UI: `http://localhost:8000/redoc`

## 6.1 API Endpoints

- `POST /api/query`: Submit a query to the agent
- `POST /api/search`: Search for CPT codes
- `POST /api/validate`: Validate a CPT code
- `POST /api/analyze`: Analyze a procedure description
- `GET /api/conversations`: List all conversations
- `GET /api/conversations/{session_id}`: Get a specific conversation
- `DELETE /api/conversations/{session_id}`: Delete a specific conversation
</file>
    <file name="usage_examples.md"># ENT CPT Code Agent - Usage Examples

This document provides examples of using the ENT CPT Code Agent in different scenarios to help you get started.

## 1. Basic Querying

### Example 1: Finding codes for a specific procedure

**Query:**
```
What is the CPT code for bilateral myringotomy with tube insertion?
```

**Response:**
```
Based on your description, the appropriate CPT code for bilateral myringotomy with tube insertion is:

69436 - Tympanostomy (requiring insertion of ventilating tube), general anesthesia, bilateral

This code is used when performing a bilateral myringotomy (making an incision in both eardrums) with the insertion of ventilation tubes under general anesthesia.

If the procedure was performed under local anesthesia or with conscious sedation rather than general anesthesia, the appropriate code would be:

69433 - Tympanostomy (requiring insertion of ventilating tube), local or topical anesthesia, bilateral

Key coding considerations:
1. The -50 modifier is not used with codes 69433 and 69436 because these codes already specify bilateral procedures
2. Documentation should clearly indicate that the procedure was performed on both ears
3. Ensure that medical necessity is properly documented in the patient's chart
```

### Example 2: Explaining coding rules

**Query:**
```
Explain the coding rules for CPT code 31231
```

**Response:**
```
Coding guidelines for CPT 31231:

Description: Nasal endoscopy, diagnostic, unilateral or bilateral (separate procedure)

General coding rules:
1. Code 31231 is used for diagnostic nasal endoscopy, which involves examining the nasal cavity using an endoscope.
2. This code can be used for either unilateral (one side) or bilateral (both sides) diagnostic nasal endoscopy.
3. The term "separate procedure" means that if this procedure is performed as part of another, more comprehensive procedure, it should not be reported separately.
4. This code should not be reported with surgical endoscopy codes (31237-31294) when performed on the same side.

Documentation requirements:
1. Medical record must document medical necessity for the diagnostic procedure
2. Documentation should specify which side(s) were examined (right, left, or bilateral)
3. Findings from the endoscopy must be clearly documented

Bundling considerations:
- Code 31231 is often bundled with surgical nasal/sinus endoscopy procedures
- It should not be billed separately when a surgical endoscopy is performed during the same encounter on the same side
- It may be reported with modifier -59 if performed on the contralateral side of a surgical endoscopy

Related codes to consider: 31233, 31235, 31237, 31575

Always verify current coding guidelines, as they may change over time.
```

## 2. Using the Rules Engine

### Example 3: Analyzing a procedure description

**Query:**
```
Analyze this procedure: "Patient underwent bilateral endoscopic sinus surgery including maxillary antrostomy, anterior ethmoidectomy, and removal of polyps from both maxillary sinuses."
```

**Response:**
```
Analysis of procedure: Patient underwent bilateral endoscopic sinus surgery including maxillary antrostomy, anterior ethmoidectomy, and removal of polyps from both maxillary sinuses.

Recommended CPT codes:
- 31267-50: Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus (Modifier 50 for bilateral procedure)
- 31254-50: Nasal/sinus endoscopy, surgical; with ethmoidectomy, partial (anterior) (Modifier 50 for bilateral procedure)

Recommendation details:
- Added modifier 50 to code 31267 for bilateral procedure.
- Added modifier 50 to code 31254 for bilateral procedure.
- Code 31267 includes the maxillary antrostomy with removal of tissue (polyps) from the maxillary sinus
- Code 31254 addresses the anterior ethmoidectomy component

Coding tips:
1. Documentation should clearly indicate the extent of each sinus entered and the work performed in each sinus
2. When coding sinus procedures, it's important to code for each sinus operated on separately
3. Ensure that the procedural documentation supports bilateral procedures
4. Verify medical necessity documentation for each sinus procedure
5. Modifier 50 (bilateral) is appropriate since the procedures were performed on both sides

Note: The order of the codes may affect reimbursement due to multiple procedure payment reduction rules. The highest valued procedure should typically be listed first.
```

### Example 4: Validating a CPT code

**Query:**
```
Is 42820 the correct code for tonsillectomy and adenoidectomy in an adult?
```

**Response:**
```
CPT code 42820 is valid, but it's not the most appropriate code for tonsillectomy and adenoidectomy in an adult.

The description for 42820 is: "Tonsillectomy and adenoidectomy; younger than age 12"

For an adult patient, the correct code would be:
42821 - Tonsillectomy and adenoidectomy; age 12 or over

Key points about these codes:
1. Age is a determining factor in code selection between 42820 and 42821
2. For adult patients (age 12 or over), 42821 is the appropriate code
3. The procedure includes both tonsillectomy and adenoidectomy
4. No modifier is needed to indicate that both procedures were performed since the code description already includes both

If only one of the procedures was performed, you would use a different code:
- 42825 or 42826 for tonsillectomy alone (based on age)
- 42830 or 42831 for adenoidectomy alone (based on age)

Always ensure your documentation clearly indicates medical necessity for both the tonsillectomy and adenoidectomy components.
```

## 3. Advanced Queries

### Example 5: Comparing related codes

**Query:**
```
What's the difference between CPT codes 69421 and 69424 for myringotomy?
```

**Response:**
```
Here's a comparison of CPT codes 69421 and 69424 for myringotomy procedures:

CPT Code 69421:
- Description: Myringotomy including aspiration and/or eustachian tube inflation; requiring general anesthesia
- Key elements: Includes incision of the tympanic membrane (eardrum) with aspiration and/or eustachian tube inflation
- Anesthesia requirement: Must be performed under general anesthesia
- Typical patients: Often used for younger children who cannot tolerate the procedure while awake
- Does NOT include insertion of ventilation tubes

CPT Code 69424:
- Description: Myringotomy including aspiration and/or eustachian tube inflation; requiring local or topical anesthesia
- Key elements: Includes the same procedure (incision of tympanic membrane with aspiration and/or eustachian tube inflation)
- Anesthesia requirement: Performed under local or topical anesthesia
- Typical patients: Generally used for older children or adults who can tolerate the procedure with local anesthesia
- Does NOT include insertion of ventilation tubes

Key differences:
1. The primary distinction is the type of anesthesia used
2. Code selection is based solely on the anesthesia method, not the procedure itself
3. Neither code includes the insertion of ventilation/PE tubes

If tubes are inserted, you would use different codes:
- 69433 (local anesthesia) or 69436 (general anesthesia) for tympanostomy with tube insertion

Documentation tips:
- Clearly document the type of anesthesia used
- Specify whether aspiration was performed
- Note whether eustachian tube inflation was performed
- Document medical necessity for the procedure
```

### Example 6: Complex scenario with multiple procedures

**Query:**
```
What are the correct CPT codes for: Septoplasty, bilateral inferior turbinate reduction, and bilateral maxillary sinus surgery with tissue removal?
```

**Response:**
```
For this complex ENT procedure involving septoplasty, bilateral inferior turbinate reduction, and bilateral maxillary sinus surgery with tissue removal, the appropriate CPT codes are:

1. 30520 - Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft
   - This code represents the septoplasty procedure
   - No modifiers are needed as septoplasty is inherently a single procedure (not bilateral)

2. 30140-50 - Submucous resection inferior turbinate, partial or complete, any method
   - The -50 modifier indicates the procedure was performed bilaterally
   - This code covers the bilateral inferior turbinate reduction

3. 31267-50 - Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus
   - The -50 modifier indicates the procedure was performed on both maxillary sinuses
   - This code includes both the antrostomy (creating an opening) and tissue removal

Coding guidelines to consider:
1. These procedures are typically reported together when performed during the same operative session
2. There are no specific NCCI edits that would prohibit reporting these codes together when properly documented
3. Some payers may require modifier -51 (multiple procedures) on the second and third procedures
4. The order of the codes may affect reimbursement (typically highest RVU procedure first)

Documentation requirements:
1. Medical necessity for each procedure must be clearly documented
2. Separate diagnoses supporting each procedure improve reimbursement likelihood
3. Detailed operative notes should describe each procedure separately
4. For the turbinate procedure, documentation should specify "bilateral" and the method used
5. For the sinus procedure, documentation should indicate both sinuses were treated and describe the tissue removed

Always verify current coding guidelines with your specific payer, as policies may vary.
```

## 4. Tool Usage Examples

### Example 7: Using the Search Tool

**Query:**
```
Search for CPT codes related to cochlear implants
```

**Response:**
```
I'll search for CPT codes related to cochlear implants.

Found 4 CPT codes matching 'cochlear implants':

1. Code 69930: Cochlear device implantation, with or without mastoidectomy
   Related codes: 92601, 92602

2. Code 69949: Unlisted procedure, inner ear
   Related codes: None

3. Code 92601: Diagnostic analysis of cochlear implant, patient younger than 7 years of age; with programming
   Related codes: 69930, 92602

4. Code 92602: Diagnostic analysis of cochlear implant, patient younger than 7 years of age; subsequent reprogramming
   Related codes: 69930, 92601

Additionally, there are related codes for older patients and external components:

5. Code 92603: Diagnostic analysis of cochlear implant, age 7 years or older; with programming
   Related codes: 92604

6. Code 92604: Diagnostic analysis of cochlear implant, age 7 years or older; subsequent reprogramming
   Related codes: 92603

The main surgical code is 69930, which covers the implantation of the cochlear device. The other codes relate to programming and analysis of the implant, with different codes based on patient age.

Would you like more specific information about any of these codes?
```

### Example 8: Using the Analyze Tool

**Query:**
```
Can you analyze this procedure and tell me the correct codes: "Functional endoscopic sinus surgery with left maxillary antrostomy, left ethmoidectomy, left sphenoidotomy, and septoplasty"
```

**Response:**
```
Analysis of procedure: Functional endoscopic sinus surgery with left maxillary antrostomy, left ethmoidectomy, left sphenoidotomy, and septoplasty

Recommended CPT codes:
- 31267: Nasal/sinus endoscopy, surgical, with maxillary antrostomy; with removal of tissue from maxillary sinus
- 31287: Nasal/sinus endoscopy, surgical, with sphenoidotomy
- 31255: Nasal/sinus endoscopy, surgical; with ethmoidectomy, total (anterior and posterior)
- 30520: Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft

Recommendation details:
- Code 31267 represents the left maxillary antrostomy
- Code 31287 covers the left sphenoidotomy
- Code 31255 is used for the left ethmoidectomy (assuming total ethmoidectomy from the description)
- Code 30520 addresses the septoplasty procedure
- No bilateral modifiers are needed as all sinus procedures are specified as left-sided
- When reporting multiple endoscopic sinus procedures, each sinus is coded separately

Coding guidelines:
1. Proper sequencing is important - typically, the most resource-intensive procedure should be listed first
2. No NCCI (National Correct Coding Initiative) edits prohibit reporting these codes together
3. Some payers may require modifier -51 (multiple procedures) on the second and subsequent procedures
4. Documentation must support medical necessity for each individual sinus procedure
5. For the septoplasty (30520), be sure documentation indicates significant septal deviation requiring correction

Note: If the ethmoidectomy was only partial/anterior rather than total, use code 31254 instead of 31255.
```

## 5. Web UI Examples

The Web UI provides a user-friendly interface for interacting with the ENT CPT Code Agent. Here are some key features:

### Main Chat Interface

The main chat interface allows you to:

- Ask questions about ENT procedures and CPT codes
- View responses with detected CPT codes highlighted
- Start new conversation sessions
- Review conversation history

### Tools Panel

The Tools panel provides specialized functions:

1. **Search Tab**
   - Search for CPT codes by keyword or description
   - View matching codes with descriptions
   - Add codes to the conversation with one click

2. **Validate Tab**
   - Validate specific CPT codes
   - View code descriptions and validity
   - Learn more about validated codes

3. **Analyze Tab**
   - Submit detailed procedure descriptions for analysis
   - Specify candidate codes (optional)
   - View recommended codes with explanations
   - Discuss analysis results in the main chat

### Detected Codes Panel

This panel displays all CPT codes detected in the conversation, allowing you to:

- See a list of all codes mentioned in the conversation
- Click on any code to validate it
- Keep track of relevant codes for the current discussion

## 6. API Integration Examples

### Python Example

```python
import requests
import json

API_URL = "http://localhost:8000/api"

# Query the agent
def query_agent(question, session_id=None):
    response = requests.post(
        f"{API_URL}/query",
        json={
            "query": question,
            "session_id": session_id
        }
    )
    return response.json()

# Search for CPT codes
def search_codes(search_term):
    response = requests.post(
        f"{API_URL}/search",
        json={"search_term": search_term}
    )
    return response.json()

# Validate a CPT code
def validate_code(code):
    response = requests.post(
        f"{API_URL}/validate",
        json={"code": code}
    )
    return response.json()

# Analyze a procedure
def analyze_procedure(procedure_text, candidate_codes=None):
    data = {
        "procedure_text": procedure_text
    }
    if candidate_codes:
        data["candidate_codes"] = candidate_codes
    
    response = requests.post(
        f"{API_URL}/analyze",
        json=data
    )
    return response.json()

# Example usage
if __name__ == "__main__":
    # Query about a procedure
    result = query_agent("What is the CPT code for myringotomy with tube insertion?")
    print(json.dumps(result, indent=2))
    
    # Use the returned session ID for follow-up questions
    session_id = result.get("session_id")
    result = query_agent("What if it's bilateral?", session_id)
    print(json.dumps(result, indent=2))
    
    # Search for related codes
    search_result = search_codes("tympanoplasty")
    print(json.dumps(search_result, indent=2))
```

### JavaScript (Node.js) Example

```javascript
const axios = require('axios');

const API_URL = 'http://localhost:8000/api';

// Query the agent
async function queryAgent(question, sessionId = null) {
  try {
    const response = await axios.post(`${API_URL}/query`, {
      query: question,
      session_id: sessionId
    });
    return response.data;
  } catch (error) {
    console.error('Error querying agent:', error.message);
    return null;
  }
}

// Search for CPT codes
async function searchCodes(searchTerm) {
  try {
    const response = await axios.post(`${API_URL}/search`, {
      search_term: searchTerm
    });
    return response.data;
  } catch (error) {
    console.error('Error searching codes:', error.message);
    return null;
  }
}

// Example usage
async function main() {
  // Query about a procedure
  const result = await queryAgent('What is the CPT code for balloon sinuplasty?');
  console.log(JSON.stringify(result, null, 2));
  
  // Use the returned session ID for follow-up questions
  const sessionId = result.session_id;
  const followUpResult = await queryAgent('What documentation is required?', sessionId);
  console.log(JSON.stringify(followUpResult, null, 2));
  
  // Search for related codes
  const searchResult = await searchCodes('sinuplasty');
  console.log(JSON.stringify(searchResult, null, 2));
}

main();
```

### cURL Examples

**Query the Agent:**
```bash
curl -X POST http://localhost:8000/api/query \
  -H "Content-Type: application/json" \
  -d '{
    "query": "What is the CPT code for nasal endoscopy?",
    "session_id": null
  }'
```

**Search for CPT Codes:**
```bash
curl -X POST http://localhost:8000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "search_term": "endoscopy"
  }'
```

**Validate a CPT Code:**
```bash
curl -X POST http://localhost:8000/api/validate \
  -H "Content-Type: application/json" \
  -d '{
    "code": "31231"
  }'
```

**Analyze a Procedure:**
```bash
curl -X POST http://localhost:8000/api/analyze \
  -H "Content-Type: application/json" \
  -d '{
    "procedure_text": "Bilateral myringotomy with tube placement under general anesthesia",
    "candidate_codes": ["69433", "69436"]
  }'
```

## 7. Workflow Examples

### Typical Coding Workflow

#### Example A: New Patient with Sinusitis

1. **Initial Assessment**:
   - Query: "What CPT codes are used for a new patient comprehensive ENT evaluation?"
   - Agent suggests E&amp;M codes (99202-99205) based on complexity

2. **Diagnostic Procedures**:
   - Query: "The physician performed a nasal endoscopy. What code should I use?"
   - Agent suggests 31231 (Nasal endoscopy, diagnostic) with guidance on documentation requirements

3. **Treatment Planning**:
   - Query: "The patient needs functional endoscopic sinus surgery for chronic sinusitis affecting the maxillary and ethmoid sinuses bilaterally. What codes apply?"
   - Agent analyzes the case and suggests appropriate surgical codes with modifiers

4. **Code Validation**:
   - Use the validation tool to verify all selected codes
   - Review any bundling issues or modifier requirements

#### Example B: Follow-up Visit After Surgery

1. **Post-op Visit Coding**:
   - Query: "How do I code a follow-up visit 2 weeks after FESS surgery?"
   - Agent explains post-op period bundling rules and when separate E&amp;M codes can be used

2. **Additional Procedures**:
   - Query: "The surgeon performed nasal debridement during the follow-up. Is this billable?"
   - Agent provides guidance on 31237 (Nasal/sinus endoscopy, surgical with debridement) and appropriate modifiers

3. **Rule Clarification**:
   - Query: "Can you explain the global period for CPT 31255?"
   - Agent explains the standard global period and documentation requirements for separately billable services

### Audit Preparation Workflow

1. **Documentation Review**:
   - Query: "What documentation is required to support billing CPT 69436?"
   - Agent provides comprehensive documentation requirements

2. **Code Selection Verification**:
   - Query: "Analyze this operative note: 'Patient underwent bilateral myringotomy with insertion of ventilation tubes under general anesthesia. Procedure performed due to recurrent otitis media with effusion refractory to medical management.'"
   - Agent analyzes the note and confirms correct code selection

3. **Modifier Usage Review**:
   - Query: "When should modifier 59 be used with endoscopic sinus procedures?"
   - Agent explains appropriate use of modifier 59 for separate and distinct procedures

## 8. Educational Examples

### Learning About Coding Principles

**Query:**
```
Explain the concept of bundling in ENT CPT coding
```

**Response:**
```
Bundling in ENT CPT Coding:

Bundling refers to the practice of including multiple components of a procedure under a single CPT code rather than reporting them separately. This concept is fundamental to proper ENT coding and helps prevent inappropriate unbundling (reporting separate codes for procedures that should be reported together).

Key principles of bundling in ENT coding:

1. Comprehensive Codes: Many ENT CPT codes describe comprehensive procedures that include multiple steps or components. For example, code 69436 (bilateral tympanostomy tube insertion) includes the myringotomy (incision of the eardrum), aspiration of middle ear fluid, and placement of the tubes.

2. "Separate Procedure" Designation: Some CPT codes are designated as "separate procedures." This means that when the procedure is performed as part of a more comprehensive service, it should not be reported separately. For example, 31231 (diagnostic nasal endoscopy) is labeled as a separate procedure and should not be reported when a surgical nasal endoscopy is performed.

3. NCCI Edits: The National Correct Coding Initiative (NCCI) maintains a database of procedure code pairs that should not be reported together. For ENT procedures, many diagnostic endoscopies are bundled with surgical endoscopies of the same anatomical site.

4. Global Surgical Packages: Surgical procedures include a "global period" during which certain services are bundled with the procedure. For ENT surgeries, this typically includes:
   - Preoperative evaluation on the day of surgery
   - The surgical procedure itself
   - Uncomplicated postoperative care for 10 or 90 days (depending on the procedure)
   - Treatment of complications that don't require a return to the operating room

Common bundling scenarios in ENT coding:

1. Endoscopic Sinus Surgery: When multiple sinuses are operated on during the same session, each sinus has its own CPT code, but diagnostic nasal endoscopy (31231) would be bundled.

2. Ear Procedures: Microscopic examination of the ear is bundled into procedures like tympanostomy tube placement or tympanoplasty.

3. Septoplasty with Turbinate Reduction: These are separate procedures with different CPT codes (30520 and 30140) that can be reported together when performed during the same operative session.

To avoid improper unbundling:
- Thoroughly understand CPT code descriptions and included services
- Regularly review NCCI edits for ENT procedures
- Document each procedure component separately and clearly
- Use appropriate modifiers only when truly separate, distinct services are performed

Remember that improper unbundling can be considered fraudulent billing and may result in denied claims, audits, or compliance issues.
```

### Understanding Complex Coding Scenarios

**Query:**
```
Explain how to code for a patient who had a septoplasty and then returned a week later with complications requiring surgical intervention
```

**Response:**
```
Coding for Septoplasty with Subsequent Complication Requiring Surgery:

This scenario involves two parts: the initial septoplasty and then the separate return to surgery for a complication. Here's how to approach coding for this situation:

Initial Septoplasty:
- CPT Code: 30520 (Septoplasty or submucous resection, with or without cartilage scoring, contouring or replacement with graft)
- This code has a 90-day global period, meaning postoperative care is bundled into the payment for 90 days after surgery

Return for Surgical Treatment of Complication:

The key coding principle here is whether the complication required a return to the operating room (OR). Complications treated in the OR during the global period are typically coded with:

1. The appropriate CPT code for the procedure performed
2. Modifier -78 (Unplanned Return to the Operating/Procedure Room by the Same Physician or Other Qualified Health Care Professional Following Initial Procedure for a Related Procedure During the Postoperative Period)

For example, if the patient developed a septal hematoma requiring drainage:
- CPT Code: 30020-78 (Drainage of nasal septal abscess or hematoma, with modifier -78)

If the patient required revision septoplasty:
- CPT Code: 30520-78 (Septoplasty with modifier -78)

Important coding guidelines:

1. Documentation Requirements:
   - The medical record must clearly establish that the complication is related to the initial procedure
   - Documentation should specify the nature of the complication and why a return to the OR was necessary
   - The operative report for the second procedure should reference the initial procedure

2. Modifier -78:
   - This modifier indicates an unplanned return to the OR for a related procedure
   - It bypasses the global period restrictions
   - The second procedure is typically reimbursed at a reduced rate (usually about 70% of the fee schedule)
   - No additional E/M service should be reported for the decision to perform the second surgery

3. Other Possible Modifiers:
   - If the complication is treated without returning to the OR, no additional procedure coding is warranted (it's included in the global package)
   - If the patient requires hospitalization for the complication, inpatient E/M services may be reported with modifier -24 (Unrelated E/M Service)

4. Diagnosis Coding:
   - The ICD-10 code for the second procedure should reflect the complication
   - Consider using appropriate complication codes (T81.XXX series) that specify postprocedural complications
   - Link the complication diagnosis to both the initial procedure and the complication

Example scenario:
A patient undergoes septoplasty (30520) on March 1st. On March 8th, the patient returns with a septal hematoma requiring drainage in the OR. The correct coding would be:
- 30020-78 (Drainage of nasal septal hematoma with return to OR modifier)
- Diagnosis: T81.0XXA (Hemorrhage and hematoma complicating a procedure, initial encounter)

Remember that proper documentation is crucial for supporting the medical necessity of the second procedure and establishing its relationship to the initial surgery.
```

## 9. Continuous Learning and Improvement

The ENT CPT Code Agent continuously learns from interactions and improves its responses. Here are ways to help enhance the system:

1. **Provide Feedback**: When the agent provides incorrect or incomplete information, inform it directly in the conversation.

2. **Ask for Clarification**: If a response is unclear, ask follow-up questions to get more specific information.

3. **Request Updates**: When coding rules change, inform the agent so it can provide the most current guidance.

4. **Suggest New Features**: If you find yourself repeatedly performing certain tasks manually, suggest new tools or capabilities.

5. **Share Complex Cases**: Challenging coding scenarios help the system improve its reasoning capabilities.

By actively engaging with the ENT CPT Code Agent and providing constructive feedback, you contribute to making it a more valuable coding resource for everyone.</file>
    <file name="installation_guide.md"># ENT CPT Code Agent - Installation &amp; Setup Guide

This guide will walk you through the installation and setup process for the ENT CPT Code Agent system.

## 1. Prerequisites

Before starting, ensure you have the following installed:

- **Python 3.8+**: Required for running the application
- **pip**: Python package manager
- **LM Studio**: Required for running the language models locally
- **Excel**: For viewing/editing the CPT codes database

## 2. Installation

### 2.1 Clone the Repository

```bash
git clone https://github.com/your-organization/ent-cpt-agent.git
cd ent-cpt-agent
```

### 2.2 Create a Virtual Environment

```bash
# Create a virtual environment
python -m venv venv

# Activate the virtual environment
# On Windows:
venv\Scripts\activate
# On macOS/Linux:
source venv/bin/activate
```

### 2.3 Install Dependencies

```bash
pip install -r requirements.txt
```

The `requirements.txt` file should include:

```
lmstudio
pandas
openpyxl
flask
fastapi
uvicorn
requests
python-dotenv
logging
argparse
```

## 3. Configuration

### 3.1 Initialize Default Configuration

```bash
python main-app.py init
```

This will create a default `config.json` file with the following structure:

```json
{
  "model": {
    "name": "qwen2.5-7b-instruct",
    "temperature": 0.2,
    "max_tokens": 1024,
    "context_length": 8192
  },
  "cpt_database": {
    "file_path": "CPT codes for ENT.xlsx",
    "sheet_name": "Sheet1"
  },
  "agent": {
    "log_level": "INFO",
    "save_conversations": true,
    "conversation_dir": "conversations"
  },
  "server": {
    "host": "localhost",
    "port": 8000,
    "enable_api": false
  }
}
```

### 3.2 Prepare the CPT Codes Database

1. Ensure that the `CPT codes for ENT.xlsx` file is in the root directory
2. The Excel file should have the following columns:
   - CPT Code
   - Description
   - Category
   - Related Codes (comma-separated)

### 3.3 Set Up LM Studio

1. Install and launch LM Studio
2. Download the recommended model (default: qwen2.5-7b-instruct)
3. Ensure LM Studio's Python SDK is properly installed:
   
   ```bash
   pip install lmstudio
   ```

4. Set up LM Studio to run in server mode:
   
   ```bash
   lms server start
   ```

## 4. Running the Application

### 4.1 Interactive Mode

Run the application in interactive command-line mode:

```bash
python main-app.py interactive
```

This will start an interactive session where you can ask questions about ENT procedures and CPT codes.

### 4.2 API Server Mode

Run the application as an API server:

```bash
python main-app.py server --host localhost --port 8000
```

This will start the API server on the specified host and port.

### 4.3 Web UI Mode

Run the web UI application:

```bash
# Set environment variables for API connection
export API_HOST=localhost
export API_PORT=8000
export WEB_PORT=5000
export DEBUG=False

# Run the web UI
python web_ui.py
```

Then open your web browser and navigate to `http://localhost:5000` to access the web UI.

### 4.4 Single Query Mode

Process a single query and exit:

```bash
python main.py query "What is the CPT code for tympanostomy tube insertion?"
```

## 5. Advanced Configuration

### 5.1 Changing the Language Model

You can change the LM Studio model used by the agent in the `config.json` file:

```json
{
  "model": {
    "name": "llama-3.1-8b-instruct",
    "temperature": 0.2,
    "max_tokens": 1024
  }
}
```

Ensure that the model is downloaded and available in LM Studio.

### 5.2 Logging Configuration

You can adjust the logging level in the `config.json` file:

```json
{
  "agent": {
    "log_level": "DEBUG"
  }
}
```

Available logging levels: DEBUG, INFO, WARNING, ERROR, CRITICAL

### 5.3 Conversation Storage

By default, conversations are stored in the `conversations` directory. You can change this in the `config.json` file:

```json
{
  "agent": {
    "save_conversations": true,
    "conversation_dir": "custom_conversations_dir"
  }
}
```

## 6. API Documentation

When running in server mode, the API documentation is available at:

- OpenAPI UI: `http://localhost:8000/docs`
- ReDoc UI: `http://localhost:8000/redoc`

### 6.1 API Endpoints

- `POST /api/query`: Submit a query to the agent
- `POST /api/search`: Search for CPT codes
- `POST /api/validate`: Validate a CPT code
- `POST /api/analyze`: Analyze a procedure description
- `GET /api/conversations`: List all conversations
- `GET /api/conversations/{session_id}`: Get a specific conversation
- `DELETE /api/conversations/{session_id}`: Delete a specific conversation

## 7. Troubleshooting

### 7.1 Common Issues

#### LM Studio Connection Issues

If you encounter issues connecting to LM Studio:

1. Ensure LM Studio is running in server mode: `lms server start`
2. Check the logs for any error messages: `lms log stream`
3. Verify the model is properly loaded in LM Studio

#### CPT Database Issues

If you encounter issues with the CPT database:

1. Ensure the `CPT codes for ENT.xlsx` file is in the correct location
2. Verify the Excel file has the required columns
3. Check for any error messages in the logs

#### API Connection Issues

If the web UI cannot connect to the API:

1. Ensure the API server is running: `python main.py server`
2. Verify the API host and port settings are correct
3. Check for any firewall issues that might block the connection

### 7.2 Logs

Logs are saved to `ent_cpt_agent.log` by default. You can check this file for detailed error messages and debugging information.

## 8. Contributing

We welcome contributions to improve the ENT CPT Code Agent. Please follow these steps:

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## 9. License

This project is licensed under the MIT License - see the LICENSE file for details.
</file>
  </folder>
  <folder name="conversations" />
  <folder name="scripts">
    <file name="install.sh">#!/bin/bash
# Installation script for ENT CPT Code Agent

# Exit on error
set -e

echo "Installing ENT CPT Code Agent..."

# Create virtual environment if it doesn't exist
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python -m venv venv
fi

# Activate virtual environment
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
    # Windows
    source venv/Scripts/activate
else
    # Unix-like
    source venv/bin/activate
fi

# Install dependencies
echo "Installing dependencies..."
pip install -r requirements.txt

# Initialize default configuration if it doesn't exist
if [ ! -f "config.json" ]; then
    echo "Initializing default configuration..."
    python main.py init
fi

# Create required directories
echo "Creating required directories..."
mkdir -p data conversations

# Check if CPT codes database exists
if [ ! -f "data/CPT codes for ENT.xlsx" ]; then
    echo "WARNING: CPT codes database file not found at 'data/CPT codes for ENT.xlsx'"
    echo "Please add the database file before running the application."
fi

# Install package in development mode
echo "Installing package in development mode..."
pip install -e .

echo "Installation complete!"
echo ""
echo "To start the interactive mode, run: python main.py interactive"
echo "To start the API server, run: python main.py server"
echo "To start the web UI, run: python web_ui.py"</file>
    <file name="run_server.sh">#!/bin/bash
# Script to run the ENT CPT Code Agent API and Web UI servers

# Exit on error
set -e

# Default ports
API_PORT=8000
WEB_PORT=5000
HOST="localhost"
DEBUG=false

# Process command line arguments
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --api-port)
        API_PORT="$2"
        shift
        shift
        ;;
        --web-port)
        WEB_PORT="$2"
        shift
        shift
        ;;
        --host)
        HOST="$2"
        shift
        shift
        ;;
        --debug)
        DEBUG=true
        shift
        ;;
        *)
        echo "Unknown option: $key"
        echo "Usage: $0 [--api-port PORT] [--web-port PORT] [--host HOST] [--debug]"
        exit 1
        ;;
    esac
done

# Activate virtual environment
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
    # Windows
    source venv/Scripts/activate
else
    # Unix-like
    source venv/bin/activate
fi

# Start API server in the background
echo "Starting API server on $HOST:$API_PORT..."
python main.py server --host $HOST --port $API_PORT &amp;
API_PID=$!

# Wait for API server to start
echo "Waiting for API server to start..."
sleep 3

# Start Web UI server
echo "Starting Web UI on $HOST:$WEB_PORT..."
export API_HOST=$HOST
export API_PORT=$API_PORT
export WEB_PORT=$WEB_PORT
export DEBUG=$DEBUG
python web_ui.py

# Clean up when Web UI is terminated
kill $API_PID</file>
  </folder>
  <folder name="data">
    <file name="CPT codes for ENT.xlsx">Error reading file: 'utf-8' codec can't decode bytes in position 15-16: invalid continuation byte</file>
  </folder>
  <folder name="src">
    <file name="__init__.py">"""
ENT CPT Code Agent package.
An AI-powered assistant for ENT CPT code selection and validation.
"""

__version__ = '1.0.0'</file>
    <file name="main.py">"""
Main module for the ENT CPT Code Agent.
Contains the main functionality for the CLI application.
"""

import argparse
import logging
import os
import sys
from typing import Dict, Any

from .config.agent_config import AgentConfig, setup_logging
from .conversation.conversation_manager import ConversationManager
from .agent.ent_cpt_agent import ENTCPTAgent
from .api.api_interface import APIInterface

def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description="ENT CPT Code Agent - An AI assistant for ENT procedure coding"
    )
    
    # General arguments
    parser.add_argument(
        "--config", 
        type=str, 
        default="config.json",
        help="Path to configuration file"
    )
    parser.add_argument(
        "--log-level", 
        type=str, 
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        default=None,
        help="Logging level (overrides config file)"
    )
    
    # Subcommands
    subparsers = parser.add_subparsers(dest="command", help="Command to run")
    
    # Interactive mode
    interactive_parser = subparsers.add_parser(
        "interactive", 
        help="Run in interactive command-line mode"
    )
    
    # Server mode
    server_parser = subparsers.add_parser(
        "server", 
        help="Run as an API server"
    )
    server_parser.add_argument(
        "--host", 
        type=str, 
        default=None,
        help="Host to run the server on (overrides config file)"
    )
    server_parser.add_argument(
        "--port", 
        type=int, 
        default=None,
        help="Port to run the server on (overrides config file)"
    )
    
    # Single query mode
    query_parser = subparsers.add_parser(
        "query", 
        help="Process a single query and exit"
    )
    query_parser.add_argument(
        "text", 
        type=str,
        help="Query text to process"
    )
    
    # Initialize config
    init_parser = subparsers.add_parser(
        "init", 
        help="Initialize default configuration file"
    )
    
    return parser.parse_args()

def run_interactive_mode(agent: ENTCPTAgent):
    """Run the agent in interactive CLI mode."""
    agent.run_interactive_session()

def run_server_mode(agent: ENTCPTAgent, config: AgentConfig, host: str = None, port: int = None):
    """Run the agent as an API server."""
    # Use provided host/port or get from config
    host = host or config.get("server", "host")
    port = port or config.get("server", "port")
    
    # Create and start API server
    api = APIInterface(agent, config, host, port)
    api.start()

def run_single_query(agent: ENTCPTAgent, query: str):
    """Process a single query and print the result."""
    response = agent.process_query(query)
    print(response)

def main():
    """Main entry point for the application."""
    # Parse command line arguments
    args = parse_arguments()
    
    # Initialize configuration
    config = AgentConfig(args.config)
    
    # Handle 'init' command first
    if args.command == "init":
        config.create_default_config()
        print(f"Initialized default configuration at {args.config}")
        return
    
    # Override config with command line arguments if provided
    if args.log_level:
        config.set("agent", "log_level", args.log_level)
    
    # Setup logging
    setup_logging(config)
    logger = logging.getLogger("ent_cpt_agent.main")
    
    try:
        # Initialize conversation manager
        conversation_manager = ConversationManager(
            config.get("agent", "conversation_dir")
        )
        
        # Initialize the agent
        logger.info("Initializing ENT CPT Agent")
        agent = ENTCPTAgent(config, conversation_manager)
        
        # Run the appropriate command
        if args.command == "interactive":
            logger.info("Starting interactive session")
            run_interactive_mode(agent)
        
        elif args.command == "server":
            logger.info("Starting API server")
            # Override config with command line arguments if provided
            host = args.host or config.get("server", "host")
            port = args.port or config.get("server", "port")
            run_server_mode(agent, config, host, port)
        
        elif args.command == "query":
            logger.info(f"Processing single query: {args.text}")
            run_single_query(agent, args.text)
        
        else:
            # No command specified, default to interactive mode
            logger.info("No command specified, starting interactive session")
            run_interactive_mode(agent)
    
    except KeyboardInterrupt:
        logger.info("Application terminated by user")
    except Exception as e:
        logger.error(f"Error running application: {e}", exc_info=True)
        return 1
    
    return 0
</file>
  </folder>
  <folder name="src/config">
    <file name="__init__.py">"""
Configuration module for the ENT CPT Code Agent.
Handles loading, saving, and accessing configuration settings.
"""

from .agent_config import AgentConfig, setup_logging

__all__ = ['AgentConfig', 'setup_logging']</file>
    <file name="agent_config.py">import json
import os
from typing import Dict, Any, Optional
import logging

logger = logging.getLogger("ent_cpt_agent.config")

class AgentConfig:
    """
    Configuration manager for the ENT CPT Code Agent.
    Handles loading, saving, and accessing configuration settings.
    """
    
    DEFAULT_CONFIG = {
        "model": {
            "name": "qwen2.5-7b-instruct",
            "temperature": 0.2,
            "max_tokens": 1024,
            "context_length": 8192
        },
        "cpt_database": {
            "file_path": "CPT codes for ENT.xlsx",
            "sheet_name": "Sheet1"
        },
        "agent": {
            "log_level": "INFO",
            "save_conversations": True,
            "conversation_dir": "conversations"
        },
        "server": {
            "host": "localhost",
            "port": 8000,
            "enable_api": False
        }
    }
    
    def __init__(self, config_path: Optional[str] = "config.json"):
        """
        Initialize the configuration manager.
        
        Args:
            config_path: Path to the configuration file (default: "config.json")
        """
        self.config_path = config_path
        self.config = self.DEFAULT_CONFIG.copy()
        self.load_config()
    
    def load_config(self) -&gt; None:
        """Load configuration from file if it exists."""
        if not self.config_path or not os.path.exists(self.config_path):
            logger.info(f"Config file not found at {self.config_path}, using defaults")
            return
        
        try:
            with open(self.config_path, 'r') as f:
                loaded_config = json.load(f)
                
            # Update the default config with loaded values
            self._update_nested_dict(self.config, loaded_config)
            logger.info(f"Loaded configuration from {self.config_path}")
        except Exception as e:
            logger.error(f"Error loading config file: {e}")
    
    def _update_nested_dict(self, d: Dict[str, Any], u: Dict[str, Any]) -&gt; Dict[str, Any]:
        """
        Update a nested dictionary with values from another dictionary.
        
        Args:
            d: Target dictionary to update
            u: Source dictionary with new values
            
        Returns:
            Updated dictionary
        """
        for k, v in u.items():
            if isinstance(v, dict) and k in d and isinstance(d[k], dict):
                self._update_nested_dict(d[k], v)
            else:
                d[k] = v
        return d
    
    def save_config(self) -&gt; None:
        """Save the current configuration to file."""
        if not self.config_path:
            logger.warning("No config path specified, cannot save configuration")
            return
        
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(os.path.abspath(self.config_path)), exist_ok=True)
            
            with open(self.config_path, 'w') as f:
                json.dump(self.config, f, indent=2)
            
            logger.info(f"Saved configuration to {self.config_path}")
        except Exception as e:
            logger.error(f"Error saving config file: {e}")
    
    def get(self, section: str, key: Optional[str] = None) -&gt; Any:
        """
        Get a configuration value.
        
        Args:
            section: Configuration section (e.g., "model", "agent")
            key: Specific key within the section (optional)
            
        Returns:
            Configuration value or section dictionary
        """
        if section not in self.config:
            return None
        
        if key is None:
            return self.config[section]
        
        return self.config[section].get(key)
    
    def set(self, section: str, key: str, value: Any) -&gt; None:
        """
        Set a configuration value.
        
        Args:
            section: Configuration section (e.g., "model", "agent")
            key: Specific key within the section
            value: Value to set
        """
        if section not in self.config:
            self.config[section] = {}
        
        self.config[section][key] = value
    
    def create_default_config(self) -&gt; None:
        """Create a default configuration file if it doesn't exist."""
        if not self.config_path:
            logger.warning("No config path specified, cannot create default configuration")
            return
        
        if os.path.exists(self.config_path):
            logger.info(f"Config file already exists at {self.config_path}")
            return
        
        try:
            # Ensure directory exists
            os.makedirs(os.path.dirname(os.path.abspath(self.config_path)), exist_ok=True)
            
            with open(self.config_path, 'w') as f:
                json.dump(self.DEFAULT_CONFIG, f, indent=2)
            
            logger.info(f"Created default configuration at {self.config_path}")
        except Exception as e:
            logger.error(f"Error creating default config file: {e}")


def setup_logging(config: AgentConfig) -&gt; None:
    """
    Set up logging based on configuration.
    
    Args:
        config: Agent configuration object
    """
    log_level_name = config.get("agent", "log_level")
    log_level = getattr(logging, log_level_name, logging.INFO)
    
    logging.basicConfig(
        level=log_level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(),
            logging.FileHandler("ent_cpt_agent.log")
        ]
    )</file>
  </folder>
  <folder name="src/web">
    <file name="__init__.py">"""
Web module for the ENT CPT Code Agent.
Provides a web-based user interface for interacting with the agent.
"""
__all__ = []</file>
    <file name="web_ui.py">#!/usr/bin/env python3
"""
Web UI server for the ENT CPT Code Agent.
This script starts the web interface server for the ENT CPT Code Agent.
"""

import os
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("ent_cpt_agent_web_ui")

if __name__ == "__main__":
    try:
        # Get port from environment variable or use default
        port = int(os.environ.get("WEB_PORT", "5000"))
        host = os.environ.get("WEB_HOST", "0.0.0.0")
        debug = os.environ.get("DEBUG", "False").lower() == "true"
        
        logger.info(f"Starting web UI server on {host}:{port} (debug={debug})")
        
        # Start the Flask application
        app.run(host=host, port=port, debug=debug)
    except Exception as e:
        logger.error(f"Error starting web UI server: {e}")
        exit(1)</file>
  </folder>
  <folder name="src/web/templates">
    <file name="index.html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;ENT CPT Code Assistant&lt;/title&gt;
    &lt;!-- Bootstrap CSS --&gt;
    &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet"&gt;
    &lt;!-- Font Awesome --&gt;
    &lt;link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet"&gt;
    &lt;style&gt;
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            padding-top: 20px;
        }
        .chat-container {
            height: 500px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            background-color: white;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .user-message {
            background-color: #f0f7ff;
            border-radius: 15px 15px 0 15px;
            padding: 10px 15px;
            margin-bottom: 10px;
            max-width: 80%;
            align-self: flex-end;
            margin-left: auto;
        }
        .assistant-message {
            background-color: #f1f3f4;
            border-radius: 15px 15px 15px 0;
            padding: 10px 15px;
            margin-bottom: 10px;
            max-width: 80%;
        }
        .code-pill {
            background-color: #e7f2fa;
            color: #1a73e8;
            border: 1px solid #c2e0f4;
            border-radius: 16px;
            padding: 4px 12px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-right: 5px;
            margin-bottom: 5px;
            display: inline-block;
            cursor: pointer;
        }
        .code-pill:hover {
            background-color: #d3e7f8;
        }
        .message-time {
            font-size: 0.7rem;
            color: #6c757d;
            margin-top: 5px;
            text-align: right;
        }
        .message-container {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }
        .spinner-border {
            width: 1.5rem;
            height: 1.5rem;
        }
        .tools-container {
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .session-info {
            font-size: 0.8rem;
            color: #6c757d;
            margin-bottom: 10px;
        }
        .loading-message {
            display: flex;
            align-items: center;
            font-style: italic;
            color: #6c757d;
        }
        .nav-tabs .nav-link {
            color: #495057;
        }
        .nav-tabs .nav-link.active {
            font-weight: 500;
        }
        .tooltip-inner {
            max-width: 300px;
        }
        #codesList {
            margin-top: 10px;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="row mb-4"&gt;
            &lt;div class="col-12"&gt;
                &lt;h1 class="text-center mb-3"&gt;ENT CPT Code Assistant&lt;/h1&gt;
                &lt;p class="text-center text-muted"&gt;Intelligent coding assistance for ENT procedures&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div class="row"&gt;
            &lt;!-- Main Chat Area --&gt;
            &lt;div class="col-lg-8"&gt;
                &lt;div class="session-info"&gt;
                    Session ID: &lt;span id="sessionId"&gt;{{ session_id }}&lt;/span&gt;
                    &lt;button id="newSessionBtn" class="btn btn-sm btn-outline-secondary ms-2"&gt;
                        &lt;i class="fas fa-plus-circle"&gt;&lt;/i&gt; New Session
                    &lt;/button&gt;
                &lt;/div&gt;
                
                &lt;div class="chat-container" id="chatContainer"&gt;
                    &lt;!-- Messages will appear here --&gt;
                    &lt;div class="message-container"&gt;
                        &lt;div class="assistant-message"&gt;
                            Hello! I'm your ENT CPT Code Assistant. I can help you find the right CPT codes for ENT procedures. How can I help you today?
                        &lt;/div&gt;
                        &lt;div class="message-time"&gt;
                            Today, &lt;span id="currentTime"&gt;&lt;/span&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;form id="queryForm" class="mb-4"&gt;
                    &lt;div class="input-group"&gt;
                        &lt;input type="text" id="queryInput" class="form-control" placeholder="Describe the ENT procedure or ask a question..." required&gt;
                        &lt;button class="btn btn-primary" type="submit"&gt;
                            &lt;i class="fas fa-paper-plane"&gt;&lt;/i&gt; Send
                        &lt;/button&gt;
                    &lt;/div&gt;
                &lt;/form&gt;
            &lt;/div&gt;
            
            &lt;!-- Tools Panel --&gt;
            &lt;div class="col-lg-4"&gt;
                &lt;div class="tools-container"&gt;
                    &lt;ul class="nav nav-tabs" id="toolsTabs" role="tablist"&gt;
                        &lt;li class="nav-item" role="presentation"&gt;
                            &lt;button class="nav-link active" id="search-tab" data-bs-toggle="tab" data-bs-target="#search" type="button" role="tab" aria-controls="search" aria-selected="true"&gt;Search&lt;/button&gt;
                        &lt;/li&gt;
                        &lt;li class="nav-item" role="presentation"&gt;
                            &lt;button class="nav-link" id="validate-tab" data-bs-toggle="tab" data-bs-target="#validate" type="button" role="tab" aria-controls="validate" aria-selected="false"&gt;Validate&lt;/button&gt;
                        &lt;/li&gt;
                        &lt;li class="nav-item" role="presentation"&gt;
                            &lt;button class="nav-link" id="analyze-tab" data-bs-toggle="tab" data-bs-target="#analyze" type="button" role="tab" aria-controls="analyze" aria-selected="false"&gt;Analyze&lt;/button&gt;
                        &lt;/li&gt;
                    &lt;/ul&gt;
                    
                    &lt;div class="tab-content p-3" id="toolsTabContent"&gt;
                        &lt;!-- Search Tab --&gt;
                        &lt;div class="tab-pane fade show active" id="search" role="tabpanel" aria-labelledby="search-tab"&gt;
                            &lt;form id="searchForm"&gt;
                                &lt;div class="mb-3"&gt;
                                    &lt;label for="searchTerm" class="form-label"&gt;Search CPT Codes&lt;/label&gt;
                                    &lt;div class="input-group"&gt;
                                        &lt;input type="text" class="form-control" id="searchTerm" placeholder="Enter keywords..." required&gt;
                                        &lt;button class="btn btn-outline-primary" type="submit"&gt;
                                            &lt;i class="fas fa-search"&gt;&lt;/i&gt; Search
                                        &lt;/button&gt;
                                    &lt;/div&gt;
                                    &lt;div class="form-text"&gt;Search for CPT codes by keyword or description&lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/form&gt;
                            &lt;div id="searchResults" class="mt-3"&gt;&lt;/div&gt;
                        &lt;/div&gt;
                        
                        &lt;!-- Validate Tab --&gt;
                        &lt;div class="tab-pane fade" id="validate" role="tabpanel" aria-labelledby="validate-tab"&gt;
                            &lt;form id="validateForm"&gt;
                                &lt;div class="mb-3"&gt;
                                    &lt;label for="codeToValidate" class="form-label"&gt;Validate CPT Code&lt;/label&gt;
                                    &lt;div class="input-group"&gt;
                                        &lt;input type="text" class="form-control" id="codeToValidate" placeholder="Enter CPT code..." pattern="\d{5}" required&gt;
                                        &lt;button class="btn btn-outline-primary" type="submit"&gt;
                                            &lt;i class="fas fa-check-circle"&gt;&lt;/i&gt; Validate
                                        &lt;/button&gt;
                                    &lt;/div&gt;
                                    &lt;div class="form-text"&gt;Enter a 5-digit CPT code to validate&lt;/div&gt;
                                &lt;/div&gt;
                            &lt;/form&gt;
                            &lt;div id="validateResults" class="mt-3"&gt;&lt;/div&gt;
                        &lt;/div&gt;
                        
                        &lt;!-- Analyze Tab --&gt;
                        &lt;div class="tab-pane fade" id="analyze" role="tabpanel" aria-labelledby="analyze-tab"&gt;
                            &lt;form id="analyzeForm"&gt;
                                &lt;div class="mb-3"&gt;
                                    &lt;label for="procedureText" class="form-label"&gt;Analyze Procedure&lt;/label&gt;
                                    &lt;textarea class="form-control" id="procedureText" rows="3" placeholder="Describe the ENT procedure in detail..." required&gt;&lt;/textarea&gt;
                                &lt;/div&gt;
                                &lt;div class="mb-3"&gt;
                                    &lt;label for="candidateCodes" class="form-label"&gt;Candidate Codes (Optional)&lt;/label&gt;
                                    &lt;input type="text" class="form-control" id="candidateCodes" placeholder="Comma-separated CPT codes, e.g., 69436,69450"&gt;
                                    &lt;div class="form-text"&gt;If you have specific codes in mind, enter them here&lt;/div&gt;
                                &lt;/div&gt;
                                &lt;button type="submit" class="btn btn-outline-primary"&gt;
                                    &lt;i class="fas fa-microscope"&gt;&lt;/i&gt; Analyze Procedure
                                &lt;/button&gt;
                            &lt;/form&gt;
                            &lt;div id="analyzeResults" class="mt-3"&gt;&lt;/div&gt;
                        &lt;/div&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
                
                &lt;!-- Detected Codes Panel --&gt;
                &lt;div class="tools-container"&gt;
                    &lt;h5&gt;&lt;i class="fas fa-tags"&gt;&lt;/i&gt; Detected CPT Codes&lt;/h5&gt;
                    &lt;p class="small text-muted"&gt;Codes detected in the conversation&lt;/p&gt;
                    &lt;div id="codesList"&gt;
                        &lt;p class="text-muted fst-italic"&gt;No codes detected yet&lt;/p&gt;
                    &lt;/div&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    
    &lt;!-- Bootstrap Bundle with Popper --&gt;
    &lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"&gt;&lt;/script&gt;
    &lt;!-- jQuery --&gt;
    &lt;script src="https://code.jquery.com/jquery-3.6.0.min.js"&gt;&lt;/script&gt;
    
    &lt;script&gt;
        $(document).ready(function() {
            // Initialize tooltips
            var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
            var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                return new bootstrap.Tooltip(tooltipTriggerEl)
            });
            
            // Set current time
            const now = new Date();
            $('#currentTime').text(now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }));
            
            // Scroll to bottom of chat
            function scrollToBottom() {
                const chatContainer = document.getElementById('chatContainer');
                chatContainer.scrollTop = chatContainer.scrollHeight;
            }
            
            // Format timestamp
            function formatTime(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            }
            
            // Add message to chat
            function addMessage(content, role, timestamp = new Date().toISOString(), codes = []) {
                const messageClass = role === 'user' ? 'user-message' : 'assistant-message';
                const messageContainer = $('&lt;div class="message-container"&gt;&lt;/div&gt;');
                const messageElement = $(`&lt;div class="${messageClass}"&gt;&lt;/div&gt;`).text(content);
                const timeElement = $('&lt;div class="message-time"&gt;&lt;/div&gt;').text(`Today, ${formatTime(timestamp)}`);
                
                messageContainer.append(messageElement).append(timeElement);
                $('#chatContainer').append(messageContainer);
                
                // If there are codes in the message, extract and display them
                if (codes &amp;&amp; codes.length &gt; 0) {
                    updateDetectedCodes(codes);
                }
                
                scrollToBottom();
            }
            
            // Add loading message
            function addLoadingMessage() {
                const loadingContainer = $('&lt;div class="message-container" id="loadingMessage"&gt;&lt;/div&gt;');
                const loadingMessage = $('&lt;div class="assistant-message loading-message"&gt;&lt;/div&gt;')
                    .append('&lt;div class="spinner-border text-primary me-2" role="status"&gt;&lt;span class="visually-hidden"&gt;Loading...&lt;/span&gt;&lt;/div&gt;')
                    .append('&lt;span&gt;Thinking...&lt;/span&gt;');
                
                loadingContainer.append(loadingMessage);
                $('#chatContainer').append(loadingContainer);
                scrollToBottom();
            }
            
            // Remove loading message
            function removeLoadingMessage() {
                $('#loadingMessage').remove();
            }
            
            // Update detected codes list
            function updateDetectedCodes(newCodes) {
                const codesListElement = $('#codesList');
                
                // Clear "no codes" message if present
                if (codesListElement.find('.text-muted.fst-italic').length &gt; 0) {
                    codesListElement.empty();
                }
                
                // Add new codes
                newCodes.forEach(code =&gt; {
                    // Only add if not already present
                    if (codesListElement.find(`[data-code="${code}"]`).length === 0) {
                        const codePill = $(`&lt;div class="code-pill" data-code="${code}" data-bs-toggle="tooltip" title="Click to validate this code"&gt;${code}&lt;/div&gt;`);
                        codesListElement.append(codePill);
                        
                        // Initialize tooltip
                        new bootstrap.Tooltip(codePill[0]);
                        
                        // Add click handler to validate code
                        codePill.on('click', function() {
                            // Set the code in the validate tab and switch to it
                            $('#codeToValidate').val(code);
                            $('#validate-tab').tab('show');
                            $('#validateForm').submit();
                        });
                    }
                });
            }
            
            // Extract CPT codes from text
            function extractCPTCodes(text) {
                const pattern = /\b\d{5}\b/g;
                return text.match(pattern) || [];
            }
            
            // Process query submission
            $('#queryForm').on('submit', function(e) {
                e.preventDefault();
                
                const queryInput = $('#queryInput');
                const query = queryInput.val().trim();
                
                if (!query) return;
                
                // Add user message to chat
                addMessage(query, 'user');
                
                // Clear input
                queryInput.val('');
                
                // Show loading message
                addLoadingMessage();
                
                // Send query to API
                $.ajax({
                    url: '/api/query',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        query: query,
                        session_id: $('#sessionId').text()
                    }),
                    success: function(response) {
                        // Remove loading message
                        removeLoadingMessage();
                        
                        if (response.status === 'success') {
                            // Add assistant message to chat
                            addMessage(response.message, 'assistant', new Date().toISOString(), 
                                       response.data &amp;&amp; response.data.codes ? response.data.codes : []);
                            
                            // Update session ID if provided
                            if (response.session_id) {
                                $('#sessionId').text(response.session_id);
                            }
                        } else {
                            // Add error message
                            addMessage(`Error: ${response.message}`, 'assistant');
                        }
                    },
                    error: function(xhr, status, error) {
                        // Remove loading message
                        removeLoadingMessage();
                        
                        // Add error message
                        addMessage(`Sorry, there was an error processing your request: ${error}`, 'assistant');
                    }
                });
            });
            
            // Process search form submission
            $('#searchForm').on('submit', function(e) {
                e.preventDefault();
                
                const searchTerm = $('#searchTerm').val().trim();
                
                if (!searchTerm) return;
                
                const searchResults = $('#searchResults');
                searchResults.html('&lt;div class="d-flex align-items-center"&gt;&lt;div class="spinner-border text-primary me-2" role="status"&gt;&lt;/div&gt;&lt;span&gt;Searching...&lt;/span&gt;&lt;/div&gt;');
                
                // Send search request to API
                $.ajax({
                    url: '/api/search',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        search_term: searchTerm
                    }),
                    success: function(response) {
                        if (response.status === 'success' &amp;&amp; response.data) {
                            const codes = response.data.codes;
                            if (codes &amp;&amp; codes.length &gt; 0) {
                                let resultsHtml = `&lt;div class="alert alert-success"&gt;Found ${codes.length} matching CPT codes&lt;/div&gt;`;
                                resultsHtml += '&lt;div class="list-group"&gt;';
                                
                                codes.forEach(code =&gt; {
                                    resultsHtml += `
                                        &lt;div class="list-group-item list-group-item-action"&gt;
                                            &lt;div class="d-flex w-100 justify-content-between"&gt;
                                                &lt;h6 class="mb-1"&gt;Code ${code.code}&lt;/h6&gt;
                                                &lt;button class="btn btn-sm btn-outline-primary add-to-chat" data-code="${code.code}"&gt;
                                                    &lt;i class="fas fa-plus"&gt;&lt;/i&gt; Add to Chat
                                                &lt;/button&gt;
                                            &lt;/div&gt;
                                            &lt;p class="mb-1"&gt;${code.description}&lt;/p&gt;
                                            ${code.related_codes &amp;&amp; code.related_codes.length &gt; 0 ? 
                                              `&lt;small class="text-muted"&gt;Related codes: ${code.related_codes.join(', ')}&lt;/small&gt;` : ''}
                                        &lt;/div&gt;
                                    `;
                                });
                                
                                resultsHtml += '&lt;/div&gt;';
                                searchResults.html(resultsHtml);
                                
                                // Add event handler for "Add to Chat" buttons
                                $('.add-to-chat').on('click', function() {
                                    const code = $(this).data('code');
                                    $('#queryInput').val(`Tell me about CPT code ${code}`);
                                    $('#queryForm').submit();
                                });
                            } else {
                                searchResults.html('&lt;div class="alert alert-warning"&gt;No CPT codes found matching your search term.&lt;/div&gt;');
                            }
                        } else {
                            searchResults.html(`&lt;div class="alert alert-danger"&gt;Error: ${response.message || 'Unknown error'}&lt;/div&gt;`);
                        }
                    },
                    error: function(xhr, status, error) {
                        searchResults.html(`&lt;div class="alert alert-danger"&gt;Error: ${error}&lt;/div&gt;`);
                    }
                });
            });
            
            // Process validate form submission
            $('#validateForm').on('submit', function(e) {
                e.preventDefault();
                
                const code = $('#codeToValidate').val().trim();
                
                if (!code) return;
                
                const validateResults = $('#validateResults');
                validateResults.html('&lt;div class="d-flex align-items-center"&gt;&lt;div class="spinner-border text-primary me-2" role="status"&gt;&lt;/div&gt;&lt;span&gt;Validating...&lt;/span&gt;&lt;/div&gt;');
                
                // Send validate request to API
                $.ajax({
                    url: '/api/validate',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        code: code
                    }),
                    success: function(response) {
                        if (response.status === 'success') {
                            validateResults.html(`
                                &lt;div class="alert alert-success"&gt;
                                    &lt;h6&gt;CPT Code ${code} is valid&lt;/h6&gt;
                                    &lt;p&gt;${response.message || 'Valid CPT code'}&lt;/p&gt;
                                    &lt;button class="btn btn-sm btn-outline-primary learn-more" data-code="${code}"&gt;
                                        &lt;i class="fas fa-info-circle"&gt;&lt;/i&gt; Learn More
                                    &lt;/button&gt;
                                &lt;/div&gt;
                            `);
                            
                            // Add event handler for "Learn More" button
                            $('.learn-more').on('click', function() {
                                const code = $(this).data('code');
                                $('#queryInput').val(`Explain the coding rules for CPT code ${code}`);
                                $('#queryForm').submit();
                            });
                        } else {
                            validateResults.html(`&lt;div class="alert alert-danger"&gt;Error: ${response.message || 'Invalid CPT code'}&lt;/div&gt;`);
                        }
                    },
                    error: function(xhr, status, error) {
                        validateResults.html(`&lt;div class="alert alert-danger"&gt;Error: ${error}&lt;/div&gt;`);
                    }
                });
            });
            
            // Process analyze form submission
            $('#analyzeForm').on('submit', function(e) {
                e.preventDefault();
                
                const procedureText = $('#procedureText').val().trim();
                const candidateCodesText = $('#candidateCodes').val().trim();
                const candidateCodes = candidateCodesText ? candidateCodesText.split(',').map(code =&gt; code.trim()) : [];
                
                if (!procedureText) return;
                
                const analyzeResults = $('#analyzeResults');
                analyzeResults.html('&lt;div class="d-flex align-items-center"&gt;&lt;div class="spinner-border text-primary me-2" role="status"&gt;&lt;/div&gt;&lt;span&gt;Analyzing...&lt;/span&gt;&lt;/div&gt;');
                
                // Send analyze request to API
                $.ajax({
                    url: '/api/analyze',
                    type: 'POST',
                    contentType: 'application/json',
                    data: JSON.stringify({
                        procedure_text: procedureText,
                        candidate_codes: candidateCodes
                    }),
                    success: function(response) {
                        if (response.status === 'success' &amp;&amp; response.data) {
                            const analysis = response.data;
                            
                            let resultsHtml = `&lt;div class="alert alert-info"&gt;
                                &lt;h6&gt;Procedure Analysis&lt;/h6&gt;
                                &lt;p class="small"&gt;${analysis.procedure_text}&lt;/p&gt;
                            &lt;/div&gt;`;
                            
                            if (analysis.recommended_codes &amp;&amp; analysis.recommended_codes.length &gt; 0) {
                                resultsHtml += `&lt;h6 class="mt-3"&gt;Recommended Codes:&lt;/h6&gt;
                                &lt;ul class="list-group mb-3"&gt;`;
                                
                                analysis.recommended_codes.forEach(code =&gt; {
                                    resultsHtml += `&lt;li class="list-group-item d-flex justify-content-between align-items-center"&gt;
                                        ${code}
                                        &lt;button class="btn btn-sm btn-outline-primary add-to-chat" data-code="${code.split('-')[0]}"&gt;
                                            &lt;i class="fas fa-plus"&gt;&lt;/i&gt;
                                        &lt;/button&gt;
                                    &lt;/li&gt;`;
                                });
                                
                                resultsHtml += `&lt;/ul&gt;`;
                                
                                // Add explanations if available
                                if (analysis.explanations &amp;&amp; analysis.explanations.length &gt; 0) {
                                    resultsHtml += `&lt;h6&gt;Explanation:&lt;/h6&gt;
                                    &lt;ul class="list-group"&gt;`;
                                    
                                    analysis.explanations.forEach(explanation =&gt; {
                                        resultsHtml += `&lt;li class="list-group-item"&gt;${explanation.message}&lt;/li&gt;`;
                                    });
                                    
                                    resultsHtml += `&lt;/ul&gt;`;
                                }
                                
                                // Add "Add to Chat" button for the analysis
                                resultsHtml += `&lt;div class="mt-3"&gt;
                                    &lt;button class="btn btn-primary add-analysis-to-chat"&gt;
                                        &lt;i class="fas fa-comment"&gt;&lt;/i&gt; Discuss in Chat
                                    &lt;/button&gt;
                                &lt;/div&gt;`;
                            } else {
                                resultsHtml += `&lt;div class="alert alert-warning"&gt;No recommended codes found for this procedure.&lt;/div&gt;`;
                            }
                            
                            analyzeResults.html(resultsHtml);
                            
                            // Add event handler for "Add to Chat" buttons
                            $('.add-to-chat').on('click', function() {
                                const code = $(this).data('code');
                                $('#queryInput').val(`Tell me about CPT code ${code}`);
                                $('#queryForm').submit();
                            });
                            
                            // Add event handler for "Discuss in Chat" button
                            $('.add-analysis-to-chat').on('click', function() {
                                $('#queryInput').val(`Can you explain why you recommended ${analysis.recommended_codes.join(', ')} for this procedure: "${procedureText}"`);
                                $('#queryForm').submit();
                            });
                        } else {
                            analyzeResults.html(`&lt;div class="alert alert-danger"&gt;Error: ${response.message || 'Unknown error'}&lt;/div&gt;`);
                        }
                    },
                    error: function(xhr, status, error) {
                        analyzeResults.html(`&lt;div class="alert alert-danger"&gt;Error: ${error}&lt;/div&gt;`);
                    }
                });
            });
            
            // New session button
            $('#newSessionBtn').on('click', function() {
                // Confirm before starting new session
                if (confirm('Start a new session? This will clear the current conversation.')) {
                    // Request new session from server
                    $.ajax({
                        url: '/api/new_session',
                        type: 'POST',
                        contentType: 'application/json',
                        data: JSON.stringify({}),
                        success: function(response) {
                            if (response.status === 'success') {
                                // Update session ID
                                $('#sessionId').text(response.session_id);
                                
                                // Clear chat
                                $('#chatContainer').empty();
                                
                                // Add welcome message
                                addMessage("Hello! I'm your ENT CPT Code Assistant. I can help you find the right CPT codes for ENT procedures. How can I help you today?", 'assistant');
                                
                                // Clear codes list
                                $('#codesList').html('&lt;p class="text-muted fst-italic"&gt;No codes detected yet&lt;/p&gt;');
                            } else {
                                alert(`Error starting new session: ${response.message}`);
                            }
                        },
                        error: function(xhr, status, error) {
                            alert(`Error starting new session: ${error}`);
                        }
                    });
                }
            });
            
            // Health check on page load
            $.ajax({
                url: '/api/health',
                type: 'GET',
                success: function(response) {
                    if (response.status !== 'success') {
                        alert(`Warning: ${response.message}`);
                    }
                },
                error: function(xhr, status, error) {
                    alert(`Error: Cannot connect to the backend API (${error}). Some features may not work.`);
                }
            });
        });
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</file>
  </folder>
  <folder name="src/agent">
    <file name="ent_cpt_agent.py">import os
import pandas as pd
import re
import lmstudio as lms
from typing import List, Dict, Any, Optional, Tuple
import argparse
import logging
import json
from pathlib import Path

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler()]
)
logger = logging.getLogger("ent_cpt_agent")

class CPTCodeDatabase:
    """
    Handles loading, processing, and querying of CPT codes for ENT procedures.
    """
    def __init__(self, file_path: str):
        """
        Initialize the CPT code database from the provided Excel file.
        
        Args:
            file_path: Path to the Excel file containing CPT codes
        """
        self.file_path = file_path
        self.df = None
        self.code_descriptions = {}
        self.code_categories = {}
        self.related_codes = {}
        self.load_data()
    
    def load_data(self) -&gt; None:
        """Load CPT code data from Excel file and process it."""
        logger.info(f"Loading CPT codes from {self.file_path}")
        try:
            self.df = pd.read_excel(self.file_path)
            
            # Process the dataframe to create lookup dictionaries
            for _, row in self.df.iterrows():
                code = str(row.get('CPT Code', '')).strip()
                if code and not pd.isna(code):
                    # Store description
                    self.code_descriptions[code] = row.get('Description', '')
                    
                    # Store category
                    category = row.get('Category', '')
                    if category and not pd.isna(category):
                        if category not in self.code_categories:
                            self.code_categories[category] = []
                        self.code_categories[category].append(code)
                    
                    # Store related codes
                    related = row.get('Related Codes', '')
                    if related and not pd.isna(related):
                        related_codes = [r.strip() for r in str(related).split(',')]
                        self.related_codes[code] = related_codes
            
            logger.info(f"Loaded {len(self.code_descriptions)} CPT codes")
        except Exception as e:
            logger.error(f"Error loading CPT codes: {e}")
            raise
    
    def search_codes(self, query: str) -&gt; List[Dict[str, Any]]:
        """
        Search for CPT codes based on a text query.
        
        Args:
            query: Search terms for finding relevant CPT codes
            
        Returns:
            List of matching CPT codes with descriptions
        """
        query = query.lower()
        results = []
        
        for code, description in self.code_descriptions.items():
            if query in description.lower() or query in code:
                results.append({
                    "code": code,
                    "description": description,
                    "related_codes": self.related_codes.get(code, [])
                })
        
        return results
    
    def get_code_details(self, code: str) -&gt; Dict[str, Any]:
        """
        Get detailed information about a specific CPT code.
        
        Args:
            code: The CPT code to look up
            
        Returns:
            Dictionary containing detailed information about the code
        """
        if code not in self.code_descriptions:
            return {"error": f"CPT code {code} not found"}
        
        return {
            "code": code,
            "description": self.code_descriptions.get(code, ""),
            "related_codes": self.related_codes.get(code, [])
        }
    
    def get_codes_by_category(self, category: str) -&gt; List[Dict[str, Any]]:
        """
        Get all CPT codes belonging to a specific category.
        
        Args:
            category: The category to look up codes for
            
        Returns:
            List of CPT codes in the specified category
        """
        if category not in self.code_categories:
            return []
        
        results = []
        for code in self.code_categories[category]:
            results.append({
                "code": code,
                "description": self.code_descriptions.get(code, ""),
                "related_codes": self.related_codes.get(code, [])
            })
        
        return results
    
    def get_code_validation(self, code: str) -&gt; Dict[str, Any]:
        """
        Validate if a CPT code exists and is valid.
        
        Args:
            code: The CPT code to validate
            
        Returns:
            Dictionary with validation results
        """
        if code in self.code_descriptions:
            return {"valid": True, "description": self.code_descriptions[code]}
        else:
            return {"valid": False, "error": f"Invalid CPT code: {code}"}


class ENTCPTAgent:
    """
    Agent for processing ENT procedure queries and determining appropriate CPT codes.
    """
    def __init__(self, config, conversation_manager=None):
        """
        Initialize the ENT CPT Agent.
        
        Args:
            config: AgentConfig object with configuration settings
            conversation_manager: Optional ConversationManager instance
        """
        self.config = config
        
        # Get configuration values
        self.model_name = config.get("model", "name")
        self.model_temperature = config.get("model", "temperature")
        self.model_max_tokens = config.get("model", "max_tokens")
        self.cpt_db_path = config.get("cpt_database", "file_path")
        
        # Initialize components
        self.cpt_db = CPTCodeDatabase(self.cpt_db_path)
        self.rules_engine = RulesEngine()
        self.conversation_manager = conversation_manager or ConversationManager(
            config.get("agent", "conversation_dir")
        )
        
        # Initialize LM Studio model
        self.model = None
        self.system_prompt = self._create_system_prompt()
        self.initialize_model()
    
    def _create_system_prompt(self) -&gt; str:
        """
        Create the system prompt for the agent.
        
        Returns:
            System prompt string
        """
        return """
        You are an expert ENT (Ear, Nose, Throat) medical coding assistant specialized in CPT codes. 
        Your goal is to help medical professionals find the correct CPT codes for ENT procedures.
        
        You have access to the following tools:
        1. search_cpt_codes: Search for CPT codes based on a procedure description
        2. validate_cpt_code: Validate if a CPT code exists and is correct
        3. get_category_codes: Get all CPT codes for a specific ENT category
        4. explain_coding_rules: Explain the rules for using a specific CPT code
        5. analyze_procedure: Analyze a procedure description to determine appropriate CPT codes
        
        When recommending CPT codes:
        - Always verify that the procedure description matches the code exactly
        - Check for any modifiers that may be needed (e.g., bilateral procedures)
        - Explain why you're recommending specific codes
        - Consider bundling rules and related codes
        - Format CPT codes clearly using the format: XXXXX (description)
        
        Always provide educational explanations of your reasoning process so
        medical professionals can learn the correct coding principles.
        """
    
    def initialize_model(self) -&gt; None:
        """Initialize the LM Studio model."""
        logger.info(f"Initializing LM Studio model: {self.model_name}")
        try:
            # Configure model with parameters from config
            self.model = lms.llm(self.model_name, config={
                "temperature": self.model_temperature,
                "maxTokens": self.model_max_tokens
            })
            logger.info("Model initialized successfully")
        except Exception as e:
            logger.error(f"Error initializing model: {e}")
            raise
    
    def search_cpt_codes(self, query: str) -&gt; str:
        """
        Tool function: Search for CPT codes based on a procedure description.
        
        Args:
            query: The procedure or keywords to search for
            
        Returns:
            Formatted search results as a string
        """
        results = self.cpt_db.search_codes(query)
        if not results:
            return f"No CPT codes found matching '{query}'"
        
        response = f"Found {len(results)} CPT codes matching '{query}':\n\n"
        for idx, result in enumerate(results, 1):
            response += f"{idx}. Code {result['code']}: {result['description']}\n"
            if result['related_codes']:
                response += f"   Related codes: {', '.join(result['related_codes'])}\n"
        
        return response
    
    def validate_cpt_code(self, code: str) -&gt; str:
        """
        Tool function: Validate if a CPT code exists and is correct.
        
        Args:
            code: The CPT code to validate
            
        Returns:
            Validation result as a string
        """
        result = self.cpt_db.get_code_validation(code)
        if result["valid"]:
            return f"CPT code {code} is valid: {result['description']}"
        else:
            return result["error"]
    
    def get_category_codes(self, category: str) -&gt; str:
        """
        Tool function: Get all CPT codes for a specific ENT category.
        
        Args:
            category: The ENT category to get codes for
            
        Returns:
            List of codes in the category as a formatted string
        """
        results = self.cpt_db.get_codes_by_category(category)
        if not results:
            return f"No CPT codes found for category '{category}'"
        
        response = f"CPT codes for category '{category}':\n\n"
        for idx, result in enumerate(results, 1):
            response += f"{idx}. Code {result['code']}: {result['description']}\n"
        
        return response
    
    def explain_coding_rules(self, code: str) -&gt; str:
        """
        Tool function: Explain the rules for using a specific CPT code.
        
        Args:
            code: The CPT code to explain rules for
            
        Returns:
            Explanation of coding rules as a string
        """
        # First get the code details
        result = self.cpt_db.get_code_details(code)
        if "error" in result:
            return result["error"]
        
        # Basic code information
        response = f"Coding guidelines for CPT {code}:\n\n"
        response += f"Description: {result['description']}\n\n"
        
        # Get coding tips from rules engine
        tips = self.rules_engine.get_coding_tips(code, result['description'])
        
        response += "Coding guidelines:\n"
        for idx, tip in enumerate(tips, 1):
            response += f"{idx}. {tip}\n"
        
        # Add information about related codes
        if result['related_codes']:
            response += f"\nRelated codes to consider: {', '.join(result['related_codes'])}\n"
            response += "\nAlways check if one of these related codes may be more appropriate based on specific procedure details."
        
        return response
    
    def analyze_procedure(self, procedure_text: str) -&gt; str:
        """
        Tool function: Analyze a procedure description to determine appropriate CPT codes.
        
        Args:
            procedure_text: Description of the ENT procedure
            
        Returns:
            Analysis results as a formatted string
        """
        # Search for potential codes
        search_results = self.cpt_db.search_codes(procedure_text)
        candidate_codes = [result["code"] for result in search_results]
        
        if not candidate_codes:
            return f"No potential CPT codes found for this procedure description. Please provide more details about the procedure."
        
        # Analyze with rules engine
        analysis = self.rules_engine.analyze_procedure(
            procedure_text, candidate_codes, self.cpt_db)
        
        if analysis["status"] != "success":
            return f"Error analyzing procedure: {analysis.get('message', 'Unknown error')}"
        
        # Format the response
        response = f"Analysis of procedure: {procedure_text}\n\n"
        
        # Add recommended codes
        response += "Recommended CPT codes:\n"
        for code in analysis["recommended_codes"]:
            # Get description for the code
            code_info = self.cpt_db.get_code_details(code.split('-')[0])  # Handle codes with modifiers
            description = code_info.get("description", "Unknown") if "error" not in code_info else "Unknown"
            response += f"- {code}: {description}\n"
        
        # Add explanations
        if analysis["explanations"]:
            response += "\nRecommendation details:\n"
            for explanation in analysis["explanations"]:
                response += f"- {explanation['message']}\n"
        
        # Add excluded codes if any
        if analysis["excluded_codes"]:
            response += "\nExcluded codes (may be bundled or inappropriate):\n"
            for code in analysis["excluded_codes"]:
                code_info = self.cpt_db.get_code_details(code)
                description = code_info.get("description", "Unknown") if "error" not in code_info else "Unknown"
                response += f"- {code}: {description}\n"
        
        return response
    
    def process_query(self, query: str, conversation=None) -&gt; str:
        """
        Process a user query about ENT procedures and CPT codes.
        
        Args:
            query: The user's question or procedure description
            conversation: Optional Conversation object to use
            
        Returns:
            Agent's response with CPT code recommendations
        """
        logger.info(f"Processing query: {query}")
        
        # Use provided conversation or create a temporary one
        if conversation is None:
            chat = lms.Chat(self.system_prompt)
            chat.add_user_message(query)
        else:
            # Convert existing conversation to LM Studio chat
            chat = conversation.to_lmstudio_chat(self.system_prompt)
        
        # Define the tool functions
        tools = [
            self.search_cpt_codes,
            self.validate_cpt_code,
            self.get_category_codes,
            self.explain_coding_rules,
            self.analyze_procedure
        ]
        
        # Let the model use tools to process the query
        result = self.model.act(
            chat,
            tools,
            on_message=lambda msg: conversation.add_message("assistant", msg.content) if conversation else None
        )
        
        return result.content
    
    def run_interactive_session(self) -&gt; None:
        """Run an interactive session where the user can ask questions about CPT codes."""
        print("\nENT CPT Code Assistant")
        print("=" * 50)
        print("Ask questions about ENT procedures and CPT codes.")
        print("Type 'quit' or 'exit' to end the session.")
        print("Type 'new' to start a new conversation.")
        print("=" * 50)
        
        # Create initial conversation
        conversation = self.conversation_manager.create_conversation()
        print(f"\nSession ID: {conversation.session_id}\n")
        
        while True:
            query = input("\nQuestion: ")
            
            # Handle special commands
            if query.lower() in ['quit', 'exit']:
                # Save conversation before exiting
                self.conversation_manager.save_conversation(conversation)
                print("Conversation saved. Goodbye!")
                break
            
            elif query.lower() == 'new':
                # Save current conversation and create a new one
                self.conversation_manager.save_conversation(conversation)
                conversation = self.conversation_manager.create_conversation()
                print(f"\nStarted new conversation. Session ID: {conversation.session_id}\n")
                continue
            
            # Add user message to conversation
            conversation.add_message("user", query)
            
            # Process query
            response = self.process_query(query, conversation)
            
            # Extract CPT codes from response
            codes = self.conversation_manager.extract_cpt_codes(response)
            if codes:
                # Update the last assistant message with found codes
                if conversation.messages and conversation.messages[-1]["role"] == "assistant":
                    conversation.messages[-1]["codes"] = codes
            
            # Save conversation after each interaction
            self.conversation_manager.save_conversation(conversation)
            
            # Display response
            print("\nResponse:")
            print(response)
            
            # Display found CPT codes separately
            if codes:
                print("\nCPT Codes found:")
                for code in codes:
                    description = ""
                    code_info = self.cpt_db.get_code_details(code)
                    if "error" not in code_info:
                        description = code_info.get("description", "")
                    print(f"- {code}: {description}")
            
            print("-" * 50)


def main():
    """Main entry point for the ENT CPT Code Agent."""
    parser = argparse.ArgumentParser(description="ENT CPT Code Agent")
    parser.add_argument(
        "--cpt_db", 
        type=str, 
        default="CPT codes for ENT.xlsx",
        help="Path to the CPT code database Excel file"
    )
    parser.add_argument(
        "--model", 
        type=str, 
        default="qwen2.5-7b-instruct",
        help="Name of the LM Studio model to use"
    )
    args = parser.parse_args()
    
    try:
        agent = ENTCPTAgent(args.cpt_db, args.model)
        agent.run_interactive_session()
    except KeyboardInterrupt:
        print("\nSession terminated by user.")
    except Exception as e:
        logger.error(f"Error running ENT CPT Agent: {e}")


if __name__ == "__main__":
    main()
</file>
    <file name="__init__.py">"""
Agent module for the ENT CPT Code Agent.
Contains the core agent components for CPT code assistance.
"""

from .ent_cpt_agent import ENTCPTAgent
from .cpt_database import CPTCodeDatabase
from .rules_engine import RulesEngine

__all__ = ['ENTCPTAgent', 'CPTCodeDatabase', 'RulesEngine']</file>
    <file name="cpt_database.py">import pandas as pd
import logging
from typing import List, Dict, Any

logger = logging.getLogger("ent_cpt_agent.cpt_database")

class CPTCodeDatabase:
    """
    Handles loading, processing, and querying of CPT codes for ENT procedures.
    
    The CPTCodeDatabase class is responsible for:
    - Loading CPT code data from an Excel file
    - Providing search functionality for codes
    - Retrieving code details and validating codes
    - Organizing codes by category
    
    This serves as the data layer for the ENT CPT Code Agent.
    """
    def __init__(self, file_path: str):
        """
        Initialize the CPT code database from the provided Excel file.
        
        Args:
            file_path: Path to the Excel file containing CPT codes
        """
        self.file_path = file_path
        self.df = None
        # Dictionary of code to description mappings
        self.code_descriptions = {}
        # Dictionary of category to list of codes mappings
        self.code_categories = {}
        # Dictionary of code to related codes mappings
        self.related_codes = {}
        self.load_data()
    
    def load_data(self) -&gt; None:
        """
        Load CPT code data from Excel file and process it.
        
        This method reads the Excel file and populates the internal
        data structures for efficient code lookup and search.
        """
        logger.info(f"Loading CPT codes from {self.file_path}")
        try:
            # Load the Excel file into a pandas DataFrame
            self.df = pd.read_excel(self.file_path)
            
            # Process the dataframe to create lookup dictionaries
            for _, row in self.df.iterrows():
                code = str(row.get('CPT Code', '')).strip()
                if code and not pd.isna(code):
                    # Store description
                    self.code_descriptions[code] = row.get('Description', '')
                    
                    # Store category
                    category = row.get('Category', '')
                    if category and not pd.isna(category):
                        if category not in self.code_categories:
                            self.code_categories[category] = []
                        self.code_categories[category].append(code)
                    
                    # Store related codes
                    related = row.get('Related Codes', '')
                    if related and not pd.isna(related):
                        related_codes = [r.strip() for r in str(related).split(',')]
                        self.related_codes[code] = related_codes
            
            logger.info(f"Loaded {len(self.code_descriptions)} CPT codes")
        except Exception as e:
            logger.error(f"Error loading CPT codes: {e}")
            raise
    
    def search_codes(self, query: str) -&gt; List[Dict[str, Any]]:
        """
        Search for CPT codes based on a text query.
        
        This method searches for codes whose descriptions or code numbers
        contain the search query.
        
        Args:
            query: Search terms for finding relevant CPT codes
            
        Returns:
            List of matching CPT codes with descriptions
        """
        query = query.lower()
        results = []
        
        # Search in both code numbers and descriptions
        for code, description in self.code_descriptions.items():
            if query in description.lower() or query in code:
                results.append({
                    "code": code,
                    "description": description,
                    "related_codes": self.related_codes.get(code, [])
                })
        
        return results
    
    def get_code_details(self, code: str) -&gt; Dict[str, Any]:
        """
        Get detailed information about a specific CPT code.
        
        This method retrieves all available information about a
        specific CPT code, including its description and related codes.
        
        Args:
            code: The CPT code to look up
            
        Returns:
            Dictionary containing detailed information about the code
        """
        if code not in self.code_descriptions:
            return {"error": f"CPT code {code} not found"}
        
        return {
            "code": code,
            "description": self.code_descriptions.get(code, ""),
            "related_codes": self.related_codes.get(code, [])
        }
    
    def get_codes_by_category(self, category: str) -&gt; List[Dict[str, Any]]:
        """
        Get all CPT codes belonging to a specific category.
        
        This method retrieves all codes that are classified under
        a particular category (e.g., "Ear", "Nose", "Throat").
        
        Args:
            category: The category to look up codes for
            
        Returns:
            List of CPT codes in the specified category
        """
        if category not in self.code_categories:
            return []
        
        results = []
        for code in self.code_categories[category]:
            results.append({
                "code": code,
                "description": self.code_descriptions.get(code, ""),
                "related_codes": self.related_codes.get(code, [])
            })
        
        return results
    
    def get_code_validation(self, code: str) -&gt; Dict[str, Any]:
        """
        Validate if a CPT code exists and is valid.
        
        This method checks if a given CPT code exists in the database
        and returns its validation status.
        
        Args:
            code: The CPT code to validate
            
        Returns:
            Dictionary with validation results
        """
        if code in self.code_descriptions:
            return {"valid": True, "description": self.code_descriptions[code]}
        else:
            return {"valid": False, "error": f"Invalid CPT code: {code}"}</file>
    <file name="rules_engine.py">from typing import List, Dict, Any, Optional, Tuple
import re
import logging
from dataclasses import dataclass

logger = logging.getLogger("ent_cpt_agent.rules_engine")

@dataclass
class CodeRule:
    """Represents a rule for CPT code selection."""
    rule_id: str
    description: str
    conditions: List[Dict[str, Any]]
    priority: int = 0
    
    def __str__(self) -&gt; str:
        return f"Rule {self.rule_id}: {self.description} (Priority: {self.priority})"


class RulesEngine:
    """
    Implements a rules engine for CPT code selection based on medical coding guidelines.
    """
    def __init__(self):
        """Initialize the rules engine with ENT-specific CPT coding rules."""
        self.rules = []
        self.initialize_rules()
    
    def initialize_rules(self) -&gt; None:
        """Load default rules for ENT CPT coding."""
        # Rule: Bundled procedures
        self.rules.append(CodeRule(
            rule_id="R001",
            description="Check for bundled procedures",
            conditions=[
                {"type": "bundled_codes", "codes": []}
            ],
            priority=10
        ))
        
        # Rule: Bilateral procedures
        self.rules.append(CodeRule(
            rule_id="R002",
            description="Check for bilateral procedures (use modifier 50)",
            conditions=[
                {"type": "procedure_bilateral", "keywords": ["bilateral", "both sides", "both ears"]}
            ],
            priority=8
        ))
        
        # Rule: Follow-up visits
        self.rules.append(CodeRule(
            rule_id="R003",
            description="Check for post-operative visits (usually included in surgical package)",
            conditions=[
                {"type": "post_op", "keywords": ["follow-up", "post-op", "postoperative"]}
            ],
            priority=9
        ))
        
        # Rule: Check for multiple procedures
        self.rules.append(CodeRule(
            rule_id="R004",
            description="Check for multiple procedures (additional procedures may require modifier 51)",
            conditions=[
                {"type": "multiple_procedures", "patterns": [
                    r"\bmultiple\s+procedures\b",
                    r"\bseveral\s+procedures\b"
                ]}
            ],
            priority=7
        ))
        
        # Rule: Check for medical necessity
        self.rules.append(CodeRule(
            rule_id="R005",
            description="Verify medical necessity documentation",
            conditions=[
                {"type": "medical_necessity", "required": True}
            ],
            priority=6
        ))
        
        logger.info(f"Initialized {len(self.rules)} CPT coding rules")
    
    def add_rule(self, rule: CodeRule) -&gt; None:
        """
        Add a new rule to the engine.
        
        Args:
            rule: The rule to add
        """
        self.rules.append(rule)
        # Sort rules by priority (higher priority first)
        self.rules.sort(key=lambda r: r.priority, reverse=True)
        logger.info(f"Added rule: {rule}")
    
    def evaluate_bundled_codes(self, procedure_text: str, candidate_codes: List[str], 
                               code_db) -&gt; Tuple[List[str], List[str], List[Dict[str, Any]]]:
        """
        Check for bundled procedure codes.
        
        Args:
            procedure_text: Description of the procedure
            candidate_codes: List of potential CPT codes
            code_db: Database of CPT codes
            
        Returns:
            Tuple of (recommended_codes, excluded_codes, explanations)
        """
        recommended = []
        excluded = []
        explanations = []
        
        # Check each candidate code
        for code in candidate_codes:
            details = code_db.get_code_details(code)
            
            # Skip if code not found
            if "error" in details:
                continue
            
            # Check related codes for potential bundling
            related_codes = details.get("related_codes", [])
            bundled_with = []
            
            for related in related_codes:
                if related in candidate_codes:
                    bundled_with.append(related)
            
            if bundled_with:
                # This code might be bundled with others
                # In a real implementation, we would check a bundling database
                explanations.append({
                    "rule_id": "R001",
                    "code": code,
                    "message": f"Code {code} may be bundled with {', '.join(bundled_with)}. "
                               f"Check coding guidelines to determine which code to use."
                })
                
                # For demonstration, we'll add the main code and exclude related codes
                # (This logic should be updated based on actual bundling rules)
                if code not in excluded:
                    recommended.append(code)
                    excluded.extend(bundled_with)
            elif code not in excluded:
                recommended.append(code)
        
        return recommended, excluded, explanations
    
    def evaluate_bilateral_procedures(self, procedure_text: str, candidate_codes: List[str],
                                     code_db) -&gt; Tuple[List[str], List[Dict[str, Any]]]:
        """
        Check for bilateral procedures that require modifier 50.
        
        Args:
            procedure_text: Description of the procedure
            candidate_codes: List of potential CPT codes
            code_db: Database of CPT codes
            
        Returns:
            Tuple of (modified_codes, explanations)
        """
        modified_codes = []
        explanations = []
        
        # Check if the procedure description indicates a bilateral procedure
        bilateral_keywords = ["bilateral", "both sides", "both ears", "right and left"]
        is_bilateral = any(keyword in procedure_text.lower() for keyword in bilateral_keywords)
        
        if is_bilateral:
            for code in candidate_codes:
                # In a real implementation, we would check if the code is eligible for modifier 50
                modified_codes.append(f"{code}-50")
                explanations.append({
                    "rule_id": "R002",
                    "code": code,
                    "message": f"Added modifier 50 to code {code} for bilateral procedure."
                })
        else:
            modified_codes = candidate_codes
        
        return modified_codes, explanations
    
    def analyze_procedure(self, procedure_text: str, candidate_codes: List[str], 
                         code_db) -&gt; Dict[str, Any]:
        """
        Analyze a procedure description and apply coding rules to suggest the
        most appropriate CPT codes.
        
        Args:
            procedure_text: Description of the procedure
            candidate_codes: List of potential CPT codes
            code_db: Database of CPT codes
            
        Returns:
            Dictionary with analysis results and recommendations
        """
        logger.info(f"Analyzing procedure: {procedure_text}")
        logger.info(f"Candidate codes: {candidate_codes}")
        
        if not candidate_codes:
            return {
                "status": "error",
                "message": "No candidate codes provided for analysis",
                "recommended_codes": []
            }
        
        recommended_codes = candidate_codes.copy()
        excluded_codes = []
        explanations = []
        modifiers = {}
        
        # Apply each rule in priority order
        for rule in self.rules:
            logger.info(f"Applying rule: {rule}")
            
            try:
                if rule.rule_id == "R001":  # Bundled procedures
                    rec, exc, exp = self.evaluate_bundled_codes(
                        procedure_text, recommended_codes, code_db)
                    recommended_codes = rec
                    excluded_codes.extend(exc)
                    explanations.extend(exp)
                
                elif rule.rule_id == "R002":  # Bilateral procedures
                    rec, exp = self.evaluate_bilateral_procedures(
                        procedure_text, recommended_codes, code_db)
                    recommended_codes = rec
                    explanations.extend(exp)
                
                # Additional rule implementations would go here
                
            except Exception as e:
                logger.error(f"Error applying rule {rule.rule_id}: {e}")
        
        # Prepare the result
        result = {
            "status": "success",
            "procedure_text": procedure_text,
            "recommended_codes": recommended_codes,
            "excluded_codes": excluded_codes,
            "explanations": explanations
        }
        
        logger.info(f"Analysis complete. Recommended codes: {recommended_codes}")
        return result
    
    def get_rule_explanations(self) -&gt; Dict[str, str]:
        """
        Get explanations for all rules.
        
        Returns:
            Dictionary mapping rule IDs to descriptions
        """
        return {rule.rule_id: rule.description for rule in self.rules}
    
    def get_coding_tips(self, code: str, procedure_text: str) -&gt; List[str]:
        """
        Get coding tips for a specific CPT code based on the procedure description.
        
        Args:
            code: CPT code to get tips for
            procedure_text: Description of the procedure
            
        Returns:
            List of coding tips
        """
        tips = []
        
        # General tips
        tips.append("Ensure the documentation supports medical necessity.")
        tips.append("Check that the procedure description matches the code definition exactly.")
        
        # Specific tips based on procedure text
        if "consultation" in procedure_text.lower():
            tips.append("Initial consultations may require different codes than follow-up visits.")
        
        if "biopsy" in procedure_text.lower():
            tips.append("Verify if the biopsy was for diagnostic or therapeutic purposes.")
        
        if "endoscopic" in procedure_text.lower():
            tips.append("Endoscopic procedures often have specific bundling rules.")
        
        return tips</file>
  </folder>
  <folder name="src/api">
    <file name="__init__.py" />
    <file name="api_interface.py">from fastapi import FastAPI, HTTPException, Depends, Query, Body
from fastapi.middleware.cors import CORSMiddleware
from typing import List, Dict, Any, Optional
import uvicorn
import logging
import os
from pydantic import BaseModel, Field
import json

# Import our agent components
# Note: These would be actual imports in a real implementation
# from agent_config import AgentConfig
# from cpt_database import CPTCodeDatabase
# from rules_engine import RulesEngine
# from conversation_manager import ConversationManager, Conversation
# from ent_cpt_agent import ENTCPTAgent

logger = logging.getLogger("ent_cpt_agent.api")

# Pydantic models for request/response validation
class QueryRequest(BaseModel):
    """Request model for querying the agent."""
    query: str = Field(..., description="The query about ENT procedures or CPT codes")
    session_id: Optional[str] = Field(None, description="Session ID for conversation continuity")

class CodeSearchRequest(BaseModel):
    """Request model for searching CPT codes."""
    search_term: str = Field(..., description="Term to search for in CPT code descriptions")

class CodeValidationRequest(BaseModel):
    """Request model for validating CPT codes."""
    code: str = Field(..., description="CPT code to validate")

class ProcedureAnalysisRequest(BaseModel):
    """Request model for analyzing a procedure description."""
    procedure_text: str = Field(..., description="Description of the ENT procedure")
    candidate_codes: Optional[List[str]] = Field(None, description="Optional list of candidate CPT codes")

class AgentResponse(BaseModel):
    """Generic response model for agent API."""
    status: str = Field(..., description="Status of the request (success/error)")
    message: Optional[str] = Field(None, description="Response message or error details")
    data: Optional[Dict[str, Any]] = Field(None, description="Response data")
    session_id: Optional[str] = Field(None, description="Session ID for conversation continuity")

class APIInterface:
    """API interface for the ENT CPT Code Agent."""
    
    def __init__(self, agent, config, host="localhost", port=8000):
        """
        Initialize the API interface.
        
        Args:
            agent: Instance of ENTCPTAgent
            config: Instance of AgentConfig
            host: Host to run the API server on
            port: Port to run the API server on
        """
        self.agent = agent
        self.config = config
        self.host = host
        self.port = port
        self.app = FastAPI(
            title="ENT CPT Code Agent API",
            description="API for querying ENT CPT codes and analyzing medical procedures",
            version="1.0.0"
        )
        
        # Add CORS middleware
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],  # In production, restrict this to specific origins
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # Register routes
        self.register_routes()
    
    def register_routes(self):
        """Register API routes."""
        
        @self.app.get("/", tags=["General"])
        async def root():
            """Root endpoint providing API information."""
            return {
                "name": "ENT CPT Code Agent API",
                "version": "1.0.0",
                "status": "running"
            }
        
        @self.app.post("/api/query", response_model=AgentResponse, tags=["Agent"])
        async def query_agent(request: QueryRequest):
            """
            Submit a query to the ENT CPT Code Agent.
            
            This endpoint processes natural language queries about ENT procedures
            and CPT codes, using the agent to determine the most appropriate response.
            """
            try:
                # Get or create session
                session_id = request.session_id
                conversation_manager = self.agent.conversation_manager
                
                if session_id and conversation_manager.get_conversation(session_id):
                    conversation = conversation_manager.get_conversation(session_id)
                else:
                    conversation = conversation_manager.create_conversation()
                    session_id = conversation.session_id
                
                # Add user message to conversation
                conversation.add_message("user", request.query)
                
                # Process the query
                response = self.agent.process_query(request.query, conversation)
                
                # Extract CPT codes from response
                codes = conversation_manager.extract_cpt_codes(response)
                
                # Add assistant message to conversation
                conversation.add_message("assistant", response, codes)
                
                # Save conversation
                conversation_manager.save_conversation(conversation)
                
                return {
                    "status": "success",
                    "message": response,
                    "data": {
                        "codes": codes
                    },
                    "session_id": session_id
                }
            
            except Exception as e:
                logger.error(f"Error processing query: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/api/search", response_model=AgentResponse, tags=["CPT Codes"])
        async def search_codes(request: CodeSearchRequest):
            """
            Search for CPT codes by description or keywords.
            
            This endpoint searches the CPT code database for codes matching
            the provided search term in their description.
            """
            try:
                results = self.agent.cpt_db.search_codes(request.search_term)
                
                return {
                    "status": "success",
                    "data": {
                        "codes": results,
                        "count": len(results)
                    }
                }
            
            except Exception as e:
                logger.error(f"Error searching codes: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/api/validate", response_model=AgentResponse, tags=["CPT Codes"])
        async def validate_code(request: CodeValidationRequest):
            """
            Validate a CPT code.
            
            This endpoint checks if a CPT code exists and is valid according
            to the CPT code database.
            """
            try:
                result = self.agent.cpt_db.get_code_validation(request.code)
                
                return {
                    "status": "success" if result.get("valid", False) else "error",
                    "message": result.get("description") if result.get("valid", False) else result.get("error"),
                    "data": result
                }
            
            except Exception as e:
                logger.error(f"Error validating code: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/api/analyze", response_model=AgentResponse, tags=["Analysis"])
        async def analyze_procedure(request: ProcedureAnalysisRequest):
            """
            Analyze an ENT procedure description to determine appropriate CPT codes.
            
            This endpoint uses the rules engine to analyze a procedure description
            and suggest appropriate CPT codes based on coding guidelines.
            """
            try:
                # If candidate codes weren't provided, search for them
                candidate_codes = request.candidate_codes
                if not candidate_codes:
                    search_results = self.agent.cpt_db.search_codes(request.procedure_text)
                    candidate_codes = [result["code"] for result in search_results]
                
                # Analyze the procedure using the rules engine
                analysis = self.agent.rules_engine.analyze_procedure(
                    request.procedure_text, candidate_codes, self.agent.cpt_db)
                
                return {
                    "status": "success",
                    "data": analysis
                }
            
            except Exception as e:
                logger.error(f"Error analyzing procedure: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/api/conversations", response_model=AgentResponse, tags=["Conversations"])
        async def list_conversations():
            """
            List all saved conversations.
            
            This endpoint returns a list of all saved conversations with their metadata.
            """
            try:
                conversations = self.agent.conversation_manager.list_conversations()
                
                return {
                    "status": "success",
                    "data": {
                        "conversations": conversations,
                        "count": len(conversations)
                    }
                }
            
            except Exception as e:
                logger.error(f"Error listing conversations: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/api/conversations/{session_id}", response_model=AgentResponse, tags=["Conversations"])
        async def get_conversation(session_id: str):
            """
            Get a specific conversation by session ID.
            
            This endpoint returns the details of a specific conversation.
            """
            try:
                conversation = self.agent.conversation_manager.get_conversation(session_id)
                
                if not conversation:
                    raise HTTPException(status_code=404, detail=f"Conversation {session_id} not found")
                
                return {
                    "status": "success",
                    "data": conversation.to_dict(),
                    "session_id": session_id
                }
            
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Error getting conversation: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.delete("/api/conversations/{session_id}", response_model=AgentResponse, tags=["Conversations"])
        async def delete_conversation(session_id: str):
            """
            Delete a specific conversation by session ID.
            
            This endpoint deletes a specific conversation and its associated data.
            """
            try:
                result = self.agent.conversation_manager.delete_conversation(session_id)
                
                if not result:
                    raise HTTPException(status_code=404, detail=f"Conversation {session_id} not found")
                
                return {
                    "status": "success",
                    "message": f"Conversation {session_id} deleted successfully"
                }
            
            except HTTPException:
                raise
            except Exception as e:
                logger.error(f"Error deleting conversation: {e}")
                raise HTTPException(status_code=500, detail=str(e))
    
    def start(self):
        """Start the API server."""
        logger.info(f"Starting API server on {self.host}:{self.port}")
        uvicorn.run(self.app, host=self.host, port=self.port)
    
    def get_app(self):
        """Get the FastAPI application instance."""
        return self.app</file>
  </folder>
  <folder name="src/conversation">
    <file name="__init__.py">"""
Conversation management module for the ENT CPT Code Agent.
Handles conversation sessions, persistence, and history.
"""

from .conversation_manager import ConversationManager, Conversation

__all__ = ['ConversationManager', 'Conversation']</file>
    <file name="conversation_manager.py">import json
import os
import datetime
import uuid
import re  # Added missing import for regex pattern matching
from typing import List, Dict, Any, Optional
import logging
import lmstudio as lms

logger = logging.getLogger("ent_cpt_agent.conversation")

class Conversation:
    """
    Represents a conversation session with the ENT CPT Code Agent.
    
    This class handles individual conversations between the user and agent,
    including message history, metadata, and serialization/deserialization.
    """
    def __init__(self, session_id: Optional[str] = None):
        """
        Initialize a new conversation.
        
        Args:
            session_id: Optional session ID (generates a new one if not provided)
        """
        self.session_id = session_id or str(uuid.uuid4())
        self.start_time = datetime.datetime.now()
        self.messages = []
        self.metadata = {
            "session_id": self.session_id,
            "start_time": self.start_time.isoformat(),
            "total_messages": 0,
            "total_codes_identified": 0
        }
    
    def add_message(self, role: str, content: str, codes: List[str] = None) -&gt; None:
        """
        Add a message to the conversation.
        
        Args:
            role: Message role (user, assistant, system)
            content: Message content
            codes: List of CPT codes mentioned in the message (optional)
        """
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        if codes:
            message["codes"] = codes
            self.metadata["total_codes_identified"] += len(codes)
        
        self.messages.append(message)
        self.metadata["total_messages"] = len(self.messages)
    
    def to_lmstudio_chat(self, system_prompt: str) -&gt; lms.Chat:
        """
        Convert the conversation to an LM Studio Chat object.
        
        This method transforms our internal conversation representation
        to the format expected by LM Studio's API.
        
        Args:
            system_prompt: System prompt to use for the chat
            
        Returns:
            LM Studio Chat object representing this conversation
        """
        chat = lms.Chat(system_prompt)
        
        for message in self.messages:
            if message["role"] == "user":
                chat.add_user_message(message["content"])
            elif message["role"] == "assistant":
                chat.add_assistant_message(message["content"])
            # System messages are handled by the initial system prompt
        
        return chat
    
    def to_dict(self) -&gt; Dict[str, Any]:
        """
        Convert the conversation to a dictionary.
        
        Returns:
            Dictionary representation of the conversation
        """
        return {
            "session_id": self.session_id,
            "metadata": self.metadata,
            "messages": self.messages
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -&gt; 'Conversation':
        """
        Create a conversation from a dictionary.
        
        This factory method reconstructs a Conversation object
        from a previously serialized dictionary representation.
        
        Args:
            data: Dictionary representation of a conversation
            
        Returns:
            Conversation object
        """
        conversation = cls(session_id=data.get("session_id"))
        conversation.metadata = data.get("metadata", {})
        conversation.messages = data.get("messages", [])
        
        # Parse start_time from metadata if available
        start_time_str = conversation.metadata.get("start_time")
        if start_time_str:
            try:
                conversation.start_time = datetime.datetime.fromisoformat(start_time_str)
            except (ValueError, TypeError):
                logger.warning(f"Could not parse start_time: {start_time_str}")
        
        return conversation


class ConversationManager:
    """
    Manages multiple conversations, including loading/saving to disk.
    
    This class handles the lifecycle of conversations, including:
    - Creating new conversations
    - Loading existing conversations from disk
    - Saving conversations to disk
    - Listing available conversations
    - Extracting CPT codes from conversation text
    """
    def __init__(self, conversation_dir: str = "conversations"):
        """
        Initialize the conversation manager.
        
        Args:
            conversation_dir: Directory to store conversation files
        """
        self.conversation_dir = conversation_dir
        self.current_conversation = None
        self.conversations = {}
        
        # Create conversation directory if it doesn't exist
        os.makedirs(self.conversation_dir, exist_ok=True)
        
        # Load existing conversations
        self.load_conversations()
    
    def load_conversations(self) -&gt; None:
        """
        Load all saved conversations from the conversation directory.
        
        This method scans the conversation directory for JSON files,
        loads them, and reconstructs Conversation objects.
        """
        if not os.path.exists(self.conversation_dir):
            logger.warning(f"Conversation directory not found: {self.conversation_dir}")
            return
        
        try:
            for filename in os.listdir(self.conversation_dir):
                if not filename.endswith('.json'):
                    continue
                
                file_path = os.path.join(self.conversation_dir, filename)
                
                with open(file_path, 'r') as f:
                    data = json.load(f)
                
                conversation = Conversation.from_dict(data)
                self.conversations[conversation.session_id] = conversation
                
            logger.info(f"Loaded {len(self.conversations)} conversations")
        except Exception as e:
            logger.error(f"Error loading conversations: {e}")
    
    def save_conversation(self, conversation: Conversation) -&gt; None:
        """
        Save a conversation to disk.
        
        Args:
            conversation: Conversation to save
        """
        if not conversation:
            logger.error("Cannot save empty conversation")
            return
        
        file_path = os.path.join(self.conversation_dir, f"{conversation.session_id}.json")
        
        try:
            with open(file_path, 'w') as f:
                json.dump(conversation.to_dict(), f, indent=2)
            
            logger.info(f"Saved conversation {conversation.session_id}")
        except Exception as e:
            logger.error(f"Error saving conversation: {e}")
    
    def create_conversation(self) -&gt; Conversation:
        """
        Create a new conversation.
        
        Returns:
            Newly created conversation
        """
        conversation = Conversation()
        self.conversations[conversation.session_id] = conversation
        self.current_conversation = conversation
        return conversation
    
    def get_conversation(self, session_id: str) -&gt; Optional[Conversation]:
        """
        Get a conversation by session ID.
        
        Args:
            session_id: Session ID of the conversation to retrieve
            
        Returns:
            Conversation object or None if not found
        """
        return self.conversations.get(session_id)
    
    def list_conversations(self) -&gt; List[Dict[str, Any]]:
        """
        Get a list of all conversations with their metadata.
        
        Returns:
            List of conversation metadata dictionaries
        """
        result = []
        for session_id, conversation in self.conversations.items():
            result.append({
                "session_id": session_id,
                "start_time": conversation.metadata.get("start_time"),
                "total_messages": conversation.metadata.get("total_messages", 0),
                "total_codes_identified": conversation.metadata.get("total_codes_identified", 0)
            })
        
        # Sort by start time (newest first)
        result.sort(key=lambda x: x.get("start_time", ""), reverse=True)
        
        return result
    
    def delete_conversation(self, session_id: str) -&gt; bool:
        """
        Delete a conversation.
        
        Args:
            session_id: Session ID of the conversation to delete
            
        Returns:
            True if deleted successfully, False otherwise
        """
        if session_id not in self.conversations:
            logger.warning(f"Conversation not found: {session_id}")
            return False
        
        # Remove from memory
        del self.conversations[session_id]
        
        # Remove from disk
        file_path = os.path.join(self.conversation_dir, f"{session_id}.json")
        if os.path.exists(file_path):
            try:
                os.remove(file_path)
                logger.info(f"Deleted conversation file: {file_path}")
            except Exception as e:
                logger.error(f"Error deleting conversation file: {e}")
                return False
        
        # Reset current conversation if it was deleted
        if self.current_conversation and self.current_conversation.session_id == session_id:
            self.current_conversation = None
        
        return True
    
    def extract_cpt_codes(self, text: str) -&gt; List[str]:
        """
        Extract CPT codes from text using regex pattern matching.
        
        This method identifies potential CPT codes in text by looking
        for 5-digit numbers that may be followed by modifiers.
        
        Args:
            text: Text to extract CPT codes from
            
        Returns:
            List of extracted CPT codes
        """
        # CPT codes are typically 5 digits or 5 digits followed by F or T or a two-digit modifier
        pattern = r'\b\d{5}(?:[FT]|\d{2})?\b'
        matches = re.findall(pattern, text)
        return matches</file>
  </folder>
</directory>